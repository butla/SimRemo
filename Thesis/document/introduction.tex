\chapter{Wprowadzenie}
\label{intro}
Niniejsza praca magisterska jest próbą rozwiązania problemu napotkanego w~mojej pracy zawodowej. Polegała ona na rozwijaniu rozproszonego systemu przeznaczonego do tworzenia i~wykonywania zautomatyzowanych testów.
Można przyjąć, że system ten miał architekturę klient-serwer. Serwer uruchamiał na sobie testowany kod sparametryzowany danymi przesyłanymi przez klienta i następnie zwracał mu wyniki. Oba te elementy działały na platformie .NET pod systemem Windows (oczywiście na różnych maszynach) i~komunikowały się za pomocą Windows Communication Foundation (WCF, czyli web service'y Microsoftu).
Całe to rozwiązanie miało już swoje lata (zaczęte jeszcze w .NET 2), było ciężkie w~utrzymaniu i~mało modularne. Tylko wspomnę, że wszystkie technologie i~techniki wymieniane w~tym i~następnych akapitach będą szerzej przybliżone w~dalszej części pracy.

Postawiono przede mną zadanie dodania do systemu możliwości uruchamiania testów na platformie Android. Wielki nacisk położono na kompatybilność wsteczną. Ponieważ w aplikacji klienta nie można było robić drastycznych zmian (takich jak przepisanie na inny język), nowy serwer na Androida (który miał zostać napisany w domyślnej dla tej platformy Javie) musiał tłumaczyć dane wejściowe i wyjściowe pomiędzy językami -- Javą a~C\#.  Właśnie to umożliwiają różne systemy zdalnego wywoływania kodu w środowiskach heterogenicznych, takie jak web service'y (jedną z~ich implementacji jest WCF). Niestety, Java na Androida -- a~ta różni się od standardowej -- nie ma żadnego odpowiednika serwera WCF\@. Trzeba go było stworzyć.

Mój system do RPC (\emph{Remote Procedure Call}, z~ang.\ zdalne wywoływanie metody) nie musiał się przejmować dużą częścią bolączek istniejących przemysłowych rozwiązań, takich jak kolejkowanie wiadomości, równoległa obsługa wielu klientów, czy bezpieczeństwo komunikacji. To dlatego, że model użycia był stosunkowo prosty -- na raz łączyły się tylko dwa węzły (klient i~serwer), a wszystkie dane (podróżujące w zaufanej wewnętrznej sieci) miały być łatwo podglądanie, aby wspierać debugowanie. Głównym problemem pozostało tłumaczenie danych. Udało mi się je zrealizować przez napisanie kodu w~Javie który serializował obiekty do XML w~taki sam sposób jak .NET (przy użyciu klasy DataContractSerializer) oraz potrafił deserializować dokumenty XML od niego otrzymane. Ponieważ nie mogłem znaleźć żadnych zasad opisujących tworzenie XML przez DataContractSerializer, sam musiałem je wydedukować poprzez analizę wyjścia dla różnych drzew obiektów, np.\ tablic, list, obiektów zawierających listy list itp. Takie podejście nie dawało, niestety, pewności, że program będzie działał poprawnie (a więc tak samo, jak .NET) dla wszystkich możliwych danych. Ale dla wszystkich z~jakimi został sprawdzony oraz dla tych które podawali użytkownicy (programiści piszący testy bazujące na naszym \emph{frameworku}) działał, więc projekt został uznany za sukces.

Sukces ten jednak nie był bardzo satysfakcjonujący. Po pierwsze przez wspomnianą niepewność poprawności działania, po drugie przez to, że kod był słabej jakości. Co prawda działał poprawnie, ale był mało czytelny i zagmatwany. Po części to wina pośpiechu przy jego tworzeniu, po części tego, że kilka razy już po jego wprowadzeniu do użytku odkrywano nowe przypadki serializacji, które nieraz zmieniały założenia już istniejące. Oczywiste stało się, że rozwiązanie trzeba było przepisać, aby mogło żyć dalej i~stać się produktem, na którym można polegać. Co więcej tym razem trzeba było się dużo poważniej zastanowić nad miejscem mojej biblioteki w~świecie systemów rozproszonych i~nad uzasadnieniem jej stworzenia. Bo może jednak jest gdzieś na świecie coś, co spełniałoby nasz scenariusz użycia a~wcześniej zostało przeoczone. Albo przez ostatnie dwa lata, czyli od skończenia mojej pracy nad starym projektem, ktoś coś takiego stworzył.

Tak zostały wytyczone zgrubne cele niniejszej pracy magisterskiej: przeszukanie istniejącego oprogramowania w~celu wyłonienia kandydatów na gotowe rozwiązanie (bądź jego składniki), praktyczne porównanie możliwości istniejących bibliotek oraz w końcu, jeśli będzie taka potrzeba, stworzenie własnego produktu. Owocem mojej pracy powinno być coś, co przede wszystkim pozwoli zminimalizować nakład pracy programisty przy tworzeniu kanału komunikacyjnego między aplikacjami wykonanymi w~różnych technologiach, chociaż podstawowym celem jest łączenie Androida z~.NETem. To idzie w~parze z~wielkim atutem mojego programu -- dynamicznym (nie wymagającym specjalnych oznaczeń) polimorfizmem danych. Był już obecny nawet w~moim prototypie, a~nie jest cechą często spotykaną w~systemach RPC.

Aktualnie zakładam, że nowy system (owoc niniejszej pracy magisterskiej) będzie wykorzystywał mój format serializacji obiektów (danych) polegający na użyciu JSONa (lub jakiejś jego pochodnej) z~zapisywaniem dodatkowej informacji o~typie tychże obiektów dla wspomożenia polimorfizmu. Było już parę innych koncepcji (które będą przybliżone w~późniejszym rozdziale), a~dla jednej nawet powstał prosty prototyp, ale wszystkie zawierały jakąś poważną skazę. Ponieważ obecny pomysł zakłada, że zarówno biblioteka serwera (Android) jak i~klienta (.NET) będą potrafiły porozumiewać się w~obie strony tym samym językiem, nic nie stoi na przeszkodzie (poza czasem i~chęciami) aby powstały klienty i~serwery na inne platformy i~inne języki. Wnosi to chociażby tyle, że referencyjna implementacja obu części architektury może powstać w~Pythonie, który jest moim ulubionym językiem i~pozwala na szybkie przelewanie myśli na kod. W trakcie pracy przeprowadzę jeszcze sporo badań, co, mam nadzieję, dostarczy ostatecznego uzasadnienia aktualnej koncepcji systemu, ale może też zaowocować powstaniem nowej.

System który ostatecznie stworzę nie znajdzie, najprawdopodobniej, zastosowania w~przemysłowych projektach, ponieważ umyślnie będę pomijał niezbędne elementy dużych rozproszonych architektur -- bezpieczeństwo komunikacji, zrównoleglanie żądań itp. To, na czym głównie się skupiam, to pokazanie, że łączenie heterogenicznych aplikacji może być całkiem bezbolesne. W~trakcie pisania pracy będę brał pod uwagę jedynie współpracę dwóch programów na raz, ale małe sieci (do kilkunastu klientów na serwer) powinny również działać dobrze (co będę sprawdzał). W przypadku, gdy mój projekt się powiedzie, to oczywiście będzie go można rozwijać dalej. Bycie otwartym i~publicznie dostępnym może tylko w~tym pomóc. Poza tym, jeśli znajdzie gdzieś rzeczywiste zastosowanie (co mnie by bardzo cieszyło, a~mu dałoby szansę na ,,życie''), to najpewniej właśnie w~innych projektach z~domeny Open Source.

%Wydaje mi się, że niniejsza praca jest trudniejsza w~realizacji niż większość innych na naszym wydziale. Rzucony na otwartą wodę szerokiej dziedziny musiałem sobie radzić sam. Z~wytyczonym z~grubsza celem sam musiałem go dookreślić (aby w~ogóle powstał temat) i~wyszukać możliwe rozwiązania. Podczas gdy wiele prac polega na sprawdzeniu lub zrealizowaniu jednego pomysłu, ja musiałem najpierw stworzyć sam pomysł -- i~to nie jeden. Mimo, że mój ostateczny produkt nie powinien być bardzo skomplikowany (taką mam nadzieję), to droga, którą musiałem pokonać 
%wysiłek umysłowy potrzebny do odnalezienia się w~tym świecie i zaproponowaniu czegoś, czego jeszcze nie ma jest znaczny. Droga potrzebna do odnalezienia tego rozwiązania jest męcząca -- ją przedstawię. Cały czas się zastanawiam, czy ma to sens.

%Nie było tam za bardzo zarządzania połączeniami i innych cech dojrzałego systemu - tylko prosta map obietków i przesyłanie zserializowanych poleceń. Dlatego postanowiłem, że dobrze zrobić nowy system. Skoro i tak nie było to zgodne ze standardnem (własne łączenie, przesyłanie z serializowanych rzeczy), to nie jest dużym problemem wymienienie kawałka po stronie .NET (serializatora) i zrobienie tego tak, żeby było też ,,wygodnie'' po stronie Javy. Czyli po prostu mieć kod po obu stronach, który wygląda (choć w innym języku) i zachowuje się tak samo. Poza tym brakuje takich rozwiązań, których można użyć we własnym projekcie bez używania jakiś standardowych i ciężkich rozwiązań. Poza tym, te rozwiązania i tak nie są zgodne i wspierają różne części standardu \emph{(Jakieś źródło)}.

\section{Cele pracy}
W tym miejscu zdefiniowane i uzasadnione zostaną cele niniejszej pracy.

%Każdy punkt powinien mieć dwie podsekcje - co? (wyjaśnia co dokładnie będzie zrobione) i dlaczego? (moje pobódki, co mi i innym to da). Jak? Po co? dla każdego celu zostanie odpowiedziane już w pracy.

\subsection{Przybliżenie tematyki}
Aby dało się zrozumieć pobudki, wywody oraz produkty tej pracy należy zaznajomić się z~tematyką zdalnego wywoływania kodu oraz charakterystyką docelowych platform. Zrobienie tego w~stopniu wystarczającym powinien umożliwić rozdział~\ref{intro}.

\subsection{Porównanie istniejącego oprogramowania}
Przybliżone i~porównane zostaną co bardziej interesujące (dla mojego zastosowania) istniejące biblioteki oraz frameworki z~dziedziny RPC i~serializacji. Będzie to obszerna i~bardzo ważna część tej pracy.

Tylko przez takie badania można stwierdzić, że mój produkt znajdzie dla siebie jakąś niszę, a~zatem tworzenie go nie będzie pozbawione praktycznego sensu.

Technologie będą rozpatrywane w kategoriach:
\begin{itemize}
	\item obecności pożądanych przeze mnie cech (wymienianych w~\ref{lib-requirements}),
	\item spełniania obietnic, co do swoich możliwości,
	\item zdolności współpracy z~innymi technologiami.
\end{itemize}

Po tej analizie stwierdzę na których rozwiązaniach mogę się wzorować lub wykorzystać jako elementy swojego.

\subsection{Stworzenie wieloplatformowej biblioteki}
\label{lib-requirements}
Oprogramowanie które stworzę będzie miało postać kilku (dwóch lub więcej) bibliotek na różne systemy. Każda z~nich będzie miała analogiczny interfejs i~taką samą funkcjonalność. Poniżej wyliczone są cechy, których obecność ma definiować moje rozwiązanie.

\begin{description}
\itemtitle{Wywoływanie kodu na Androidzie z~poziomu C\#}
Cel główny, w~końcu to jest mój problem wyjściowy. Moje dzieło ma pozwolić na wywoływanie metod (i~otrzymanie od nich wartości zwrotnych) napisanych w~języku Java pod Androidem przez program napisany w C\#. Można powiedzieć, że jest to zarządzanie Androidem z Windowsa (bo C\# działa na .NET, a ten z kolei domyślnie działa na Windowsie).

%Nie zapewnie polimorfizmu parametrycznego, czyli szblonów.
\itemtitle{Polimorfizm zdalnych metod}
Zdalne metody powinny być polimorficzne. To znaczy, że każdy z~ich argumentów (jeśli jest to metoda przyjmująca argumenty) nie jest ograniczony do przynależności do jednego typu\cite{polymorphism}. Będzie to osiągnięte na dwa sposoby. Pierwszy -- przeciążanie metod (polimorfizm ad-hoc), polega na tym, że może istnieć zbiór różnych metod o~tej samej nazwie, pod warunkiem, że przyjmują różne zestawy argumentów. Drugi -- to nadanie argumentom cechy nazywanej z~angielskiego \emph{inclusion polymorphism}. Można by to przetłumaczyć jako polimorfizm zawierania. Znaczy to tyle, że jeden typ posiada te same metody i~pola co inny typ (zawiera go); najczęściej posiada też właściwe dla siebie cechy (metody i~pola). W~językach obiektowych zazwyczaj taki polimorfizm realizowany jest przez dziedziczenie -- jeden typ dziedziczy po drugim, w ten sposób przejmując jego cechy. Dzięki temu typ dziedziczący może być traktowany tak samo, jak typ dziedziczony. Podsumowując, pod każdy argument zdalnej metody można podstawić zarówno wartość typu określonego przez nią oczekiwanego, jak i dowolnego typu dziedziczącego po nim.

\itemtitle{Swoboda rozszerzania kodu}
Raz napisany kod zawierający moje zdalne metody powinien być rozszerzalny bez potrzeby jego zmiany \cite[str.~105]{design-patterns}. Jest to jedna z~podstaw obiektowego podejścia do programowania. Umożliwia jej działanie, między innymi, polimorfizm. Dla przykładu -- raz stworzonej zdalnej metodzie mogę przekazać argument nowego typu, który dziedziczy po spodziewanym. Przypuśćmy dalej, że metoda uruchamia jakąś metodę parametru, który otrzyma, a~ta metoda została rozszerzona w podtypie. Tym samym stara metoda zaowocuje uruchomieniem nowego kodu, a~ani jej, ani oryginalnego typu parametru nie trzeba było zmieniać.

\itemtitle{Prostota użycia}
Moja biblioteka powinna pozwalać na szybkie tworzenie zdalnych metod w~prosty sposób. Jej instalacja ma być oczywista, API przejrzyste. Jeśli wymagana będzie konfiguracja, to powinna być krótka i~zrozumiała. Jeśli trzeba będzie tworzyć opisy umożliwiające tłumaczenie obiektów danych (przedstawicieli klasy bez metod) z~jednego języka na odpowiadające obiekty w~drugim języku, to powinny być one generowane automatycznie przy minimalnej liczbie parametrów. Moje oprogramowanie może także mieć możliwość wygenerowania kodu klasy (danych) w~jednym języku na bazie kodu klasy napisanej w~drugim. Ogólnie powinno zdejmować z~programisty możliwie dużo trosk (zadań), które nie wymagają interwencji istoty obdarzonej zdolnością abstrakcyjnego myślenia i~mogą być rozwiązane przez automat.

%\itemtitle{Wsparcie wielu środowisk}
%Cel drugorzędny, do którego nie będę przywiązywał wielkiej wagi. Ale jeśli uda się umożliwić łączenie tak różnych środowisk jak Android (który jest platformą mobilną, a~więc ograniczoną) i~.NET, to może nie będzie wielkim problemem wsparcie kolejnych platform. Może połączenie tych środowisk będzie rozwiązywało na tyle uniwersalne problemy, że dodanie klienta/serwera dla, chociażby, Pythona, Windows Phone lub innych platform (w~tym osadzonych) będzie procesem, który będzie można wykonać bez większej refleksji. 
\end{description}

Istnieją zagadnienia ważne dla aplikacji rozproszonych, które będą przeze mnie pomijane, aby nie przesłaniać najważniejszych (według mnie) kwestii. Moja praca nic do nich nie wniesie, więc nie ma sensu się nimi zajmować. Są to, między innymi (bo nie sposób wymienić wszystkiego, co \emph{nie} wchodzi w~obszar zainteresowań):

\begin{description}
\itemtitle{Bezpieczeństwo komunikacji}
Krytyczny czynnik dla aplikacji rozproszonych \cite[str.~21]{web-services}. Polega na zapewnieniu poufności, uwierzytelniania (i~autoryzacji) i~spójności/nienaruszalności. Spójność można rozważać zarówno w~kontekscie zapewnienia poprawności danych przesyłanych przez sieć \cite{data-integrity}, jak i~zagwarantowaniu, że odbiorca będzie mógł zidentyfikować i~odrzucić wiadomość, która została przez kogoś celowo zmodyfikowana po wyjściu od nadawcy \cite{data-signature}. Nie będę starał się ich zapewnić, ale jako praktyk nie mogę całkiem o~nich zapomnieć. Dlatego jeśli nie będzie mnie to spowalniać, będę zostawiał miejsca, w~których będzie można zapewnić bezpieczeństwo przez dodanie lub wymianę modułu aplikacji. Na przykład przez zastąpienie zwykłych połączeń TCP (które i~tak zamierzam traktować abstrakcyjnie) połączeniami TLS (które tak naprawdę są nakładką na TCP \cite[str.~47]{tls}).

\itemtitle{Wydajność}
Jest niezmiernie ważna dla wszystkich serwerów, ponieważ muszą obsługiwać wielu klientów na raz. Jednak moja aplikacja nie musi być tak wydajna, nie muszę przejmować się ,,odmową usługi'' \cite{dos}(z~ang. DoS, \emph{Denial of Service}) przez serwer. Z~doświadczenia wiem, że program typu tworzonego przeze mnie, rozmawiający na raz z~kilkoma--kilkunastoma klientami nie powinien mieć problemów z~nadążeniem, jeśli nie będzie w~nim rażących błędów. Taka ilość połączeń póki co całkowicie mnie zadowala. Tym bardziej, że mój system wyjściowo miał działać przy połączeniu ,,1 do 1'', jako most między dwiema aplikacjami. Zajmuję w~tym przypadku podobną postawę wobec wydajności, co wobec bezpieczeństwa -- mimo ich pomijania dalej jestem świadom problemów z~nią związanych i~jeśli nie będzie to w~żaden sposób problematyczne będę zapewniał względną (względem czytelności) optymalność kodu.
\end{description}

%Ale ponieważ nie sposób choć trochę o~nich nie myśleć przy projektowaniu tego typu systemu, b to jeśli będzie to sprawiało minimalny problem, będę starał się o nie zadbać
%dążył do jak najwyższej ich wartości, albo zostawiał miejsce na ich zapewnienie w przyszłości.

%\section{Używany język (TODO)}
%W~pierwszym zdaniu tej pracy najprawdopodobniej rzuciła się Tobie, czytelniku, od razu w oczy nieformalna konstrukcja. Mogła nawet w~nie razić. Mimo, że może się ona wydawać nieadekwatna, to przenosi nie mniej informacji niż bezosobowe stwierdzenie ,,w~pracy zawodowej autora'', a~jest dla mnie -- tegoż właśnie autora -- przyjemniejsza w~użyciu, a~zatem lepsza. Więcej o~tym później.
%
%Napisać o tym, że język w mojej pracy może nie być do końca formalny. Mogę wtedy przekazywać informacje tak samo dobrze albo nawet lepiej (bo mogę być bardziej obrazowy, a nie muszę być od razu nieprecyzyjny) a zarówno pisanie jak i czytanie pracy będzie przyjemniejsze. Nauka powinna być frajdą. Coś przytoczyć może z tego headfirsta albo ich źródeł? W anglojęzycznej literaturze, która jest w sumie światowym standardem naukowym (jakiś cytat znaleźć) często tworzą jakieś nieformalne konstrukcje (sandwiche, cargo cult programming). Cytat z Head firsta o tym, że jak jest rozmowa to się lepiej czyta i pamięta. A zakładam, że ktoś poza mną przynajmniej raz będzie to czytał i chociaż jego zadanie będzie przyjemniejsze. Moje na pewno. Niby praca dyplomowa ma być napisana jasno i konkretnie (\url{http://www.slideshare.net/jszypryt/prace-dyplomowe-i-ich-cele-rodzaje-i}), a takie bezosobowe ściemnianie jest oczywistym tego przeciwieństwem. Bo przecież napisanie, że jakiś program ,,zrobiono'' albo, że ,,powstał'' ukrywa prawdę, że to właśnie JA zrobiłem. Za często trzeba się zastanawiać jak coś trafnie sformułować, żeby nie brzmiało nazbyt potocznie. Zdecydowałem się odrzucić takie problemy. Uznaję, że jeśli tekst przekazuje informacje precyzyjnie i zrozumiale dla osoby posługującej się współczesnym językiem polskim to jest to tekst poprawny.
%
%\emph{Mam jakies rzeczy w downloadsach.} \\
%\url{http://galaxy.agh.edu.pl/~wkowalsk/dydaktyka/skrypt.pdf}\\
%\url{http://chomikuj.pl/miechu17/Ksi*c4*85*c5*bcki/Uwagi+o+pisaniu+i+redagowaniu+prac+dyplomowych+na+studiach+technicznych+-+E.+Opoka,3372705642.pdf}\\
%\url{http://dyplom.best4u.pl/zasady-pisania-prac-dyplomowych}\\
%\url{http://zwa.univ.szczecin.pl/wp-content/uploads/2013/04/zasady-pisania-prac-dyplomowych_2012_2013.pdf}\\
%\url{http://www.slideshare.net/jszypryt/prace-dyplomowe-i-ich-cele-rodzaje-i}\\
%\url{http://www.ithg.wsg.byd.pl/userfiles/files/II%20Uwagi%20dotycz%C4%85ce%20pisania%20prac%20seminaryjnych(1).pdf}\\
%\url{http://dydaktyka.polsl.pl/kwmimkm/jak_pisac.pdf}\\
%\url{http://www.maraton.home.pl/por_aut.htm}\\
%
%Książki O'Reilly i Head First na przykłady. W ,,On Understanding Types, Data Abstraction and Polymorphism.pdf'' nawet jest ,,set of clothes'' i ,,naked'' representation.

\section{Docelowe platformy}
Tutaj zostaną opisane platformy technologiczne, na których będzie działać moja biblioteka.

\subsection{Android}
\label{android}

\subsubsection{Omówienie}
Android jest kompletną, otwartą (open-source) platformą dla urządzeń mobilnych opartą o~Linux\cite{learning-android}. Został stworzony przez organizację Open Handset Alliance. Organizacja skupia wielu operatorów komórkowych, producentów elektroniki, telefonów i~oprogramowania~\cite{oha}. Pomysłodawcą uformowania oraz liderem tej organizacji jest firma Google. Jej misją jest przyspieszenie innowacji na platformach mobilnych oraz dostarczenie konsumentom pełniejszego, tańszego i~ogólnie lepszego doznania z~korzystania z~telefonu. Wszystko to za sprawą Androida, który dodatkowo jest całkowicie otwarty.

Krótka historia systemu, która powinna rzucić na niego trochę światła:
\begin{itemize}
	\item W 2005 roku Google kupuje Android, Inc. -- świat oczekuje pojawienia się telefonu Googla (,,gPhone'').
	\item Długa cisza.
	\item 2007, ogłoszenie zawiązania Open Handset Alliance i~pojawienie się Androida.
	\item 2008, wypuszczenie Android SDK 1.0 (o~tym niżej); krótko po tym wypuszczenie pierwszego telefonu z~Androidem -- HTC G1.
	\item 2009, telefony z Androidem coraz powszechniejsze (ponad 20 modeli), współistnieje wiele wersji systemu: Cupcake(1.5), Donut(1.6), Eclair(2.0, 2.1).
	\item maj 2010, Android jest drugim (po Blackberry) pod względem popularności systemem dla smartfonów; wypuszczenie Froyo(2.2) i~ponad 60 modeli telefonów go posiadających.
	\item grudzień 2010, wielkie zmiany (poprawki) w~interfejsie użytkownika wprowadzone w~wersji Gingerbread(2.3).
	\item luty 2011, wydanie Honeycomb(3.0)~\cite{android-history}. Został wydany tylko na tablety, co przeczyło założeniu systemu uniwersalnego dla różnych urządzeń. Jego źródła nie zostały otwarte tym samym łamiąc obietnice całkowitej otwartości.
	\item październik 2011, Ice Cream Sandwich(4.0) wraca do ideałów będąc otwartym systemem zarówno na telefony, jak i~tablety (i~dowolne inne urzdzenia)
	\item 2014, zapowiedź Androida L, który ma znacznie zwiększyć wydajność (dzięki nowemu podejściu do kompilacji aplikacji\cite{android-art}), poprawić interfejs użytkownika i~wspierać aplikacje 64-bitowe\cite{android-l-ogolnie}.
\end{itemize}

Jako że Android jest przeznaczony dla urządzeń mobilnych, jego twórcy musieli wziąć pod uwagę ograniczenia, które miały być względnie niezmienne w~przewidywalnym czasie\cite{learning-android}.
To, że telefony są zasilane z~baterii (których pojemność bardzo się nie zmienia) oraz mają nieduży rozmiar, ograniczają moc procesora i~możliwą pamięć. Mimo tego, użytkownik powinien być zadowolony z~szybkości urządzenia, tak samo jak w~przypadku zasobożernych komputerów osobistych.
Rozwiązanie tego problemu wymaga dużej pomysłowości i~musi owocować pewnymi kosztami.

Ten system zrewolucjonizował rynek mobilny (i~nie tylko). Pierwszy raz otwarta platforma rozdziela sprzęt od oprogramowania na nim działającego. Ponieważ jej rdzeń jest przenośny i~nie ma założeń co do sprzętu, pozwala dużo większej niż do tej pory liczbie urządzeń na uruchamianie tych samych aplikacji i~tworzy bogatsze środowisko, zarówno dla programistów, jak i~konsumentów. Nie ogranicza się tylko do telefonów, tabletów, i~laptopów, ale zaczyna występować nawet w~telewizorach, samochodach i, zdaje się, wszystkich innych urządzeniach, w~których można osadzić mikrokomputer\footnote{Np.\ w~lodówkach~\cite{android-fridge}}.

Użytkownicy zauważą, że działa w~pełni od razu po zakupie urządzenia, bez potrzeby skomplikowanej konfiguracji. Mogą też go mocno zmodyfikować dopasowując go do swoich potrzeb.
Programistom dostarcza kompletny zbiór narzędzi -- Android SDK (Software Development Kit) -- potrzebnych do łatwego i~szybkiego tworzenia aplikacji. Nie ma nawet potrzeby posiadania fizycznego urządzenia, ponieważ Android SDK zawiera emulator.
Producenci mogą go widzieć jako kompleksowe rozwiązanie na oprogramowanie swoich urządzeń. Jedyne, czego brakuje Androidowi do nadania życia urządzeniu to warstwa sterowników bezpośrednio związana ze sprzętem.

Każdy element systemu jest objęty licencjami przyjaznymi dla firm komercyjnych (Apache, MIT), aby mógł być swobodnie rozszerzany i~używany dla różnorakich celów.
Jeśli jakiś producent sobie tego życzy, to może nie ujawniać części, które sam dodał. Ale poza tym, reszta systemu jest otwarta i~każdy może ją ściągnąć\footnote{Instrukcje można znaleźć tu: \url{https://source.android.com/source/building.html}} i~przejrzeć, albo nawet zmodyfikować.
Niektóre z~otwartych bibliotek, które były wcielone do systemu, zostały nawet przepisane specjalnie po to, aby nadać im takie licencje.

\subsubsection{Programowanie}
System jest niejako nadbudówką na Linuksa. Android dziedziczy jego dobre (i~pozostałe) cechy jak bezpieczeństwo, przenośność, czy zespół solidnych (ang. \emph{robust}) zasad zarządzania zasobami, a~także bogaty asortyment rozwijanych latami narzędzi.

Ma strukturę warstwową. Każda warstwa ma własną charakterystykę i~przeznaczenie. Nie są one jednak od siebie idealnie rozdzielone i~częściowo na siebie zachodzą.

Android jest platformą kompletną (ang. \emph{comprehensive platform}), co znaczy, że zawiera pełny stos oprogramowania dla urządzenia mobilnego. Stos ten zawiera wszystko od niskopoziomowych modułów jądra Linuksa, przez biblioteki natywne, platformę aplikacji (ang. \emph{framework}) po same aplikacje (widoczny na rysunku~\ref{fig:android_architecture}).

\begin{figure}
	\centering
		\includegraphics[scale=0.7]{img/android_architecture.jpg}
	\caption{Stos Androida, źródło: \cite{android-stack}}
	\label{fig:android_architecture}	
\end{figure}

Jeśli chodzi o~kod natywny(C/C++), to można pod niego programować mniej więcej tak, jak pod ,,standardowego'' Linuksa\cite{learning-android}. Ma podobny zestaw bibliotek. Część została włączona do systemu bez zmian. Ważnym wyjątkiem jest Bionic -- alternatywna implementacja biblioteki standardowej C (\emph{libc}). Google zdecydował się na jej przepisanie, aby zoptymalizować ją pod urządzenia z~ograniczonymi zasobami oraz żeby uniknąć problemów licencyjnych związanych z~,,infekcją'' przez licencję GPL (którą objęta jest \emph{libc}).

Trzeba powiedzieć, że pisanie programów w~C nie jest zalecanym sposobem pisania aplikacji na Androida. Podstawowym językiem jest Java 6, chociaż pojawia się już wsparcie dla siódmej wersji języka\cite{android-java-7}. API dla tego języka dostarczane przez Google pozwala na budowanie programów, które klasyfikowane są jako aplikacje Androidowe\cite{learning-android}. Te aplikacje przyjmują postać paczek APK (Application Package). Mogą one być łatwo instalowane i~wykorzystywane przez zwykłych użytkowników.

Java, w~przeciwieństwie do np.~C nie jest kompilowana do kodu maszynowego, który może być wykonany przez procesor. Zamiast tego jest kompilowana do kodu bajtowego Javy (\emph{Java bytecode}), który abstrahuje od właściwości (takich jak architektura procesora) komputera, na którym ma być wykonany \cite{jvm}. Za przełożenie wykonywanego kodu na prawdziwe instrukcje procesora, zwane JIT -- z~ang. \emph{just-in-time compilation}, a~więc kompilacja w~samą porę, jest odpowiedzialna maszyna wirtualna Javy (ang.: \emph{Java Virtual Machine (JVM)}). JVM posiada różne wersje (wszystkie zgodne z~jedną specyfikacją) dopasowane do środowisk, w~których mają działać. Inna będzie potrzebna na Linuksa, inna na Windowsa. Ale każda z~nich powinna być w~stanie wykonać z~takim samym efektem taki sam kod Javy. Zatem teoretycznie można napisać jeden program, który bez żadnych modyfikacji będzie działał na całkowicie odmiennych systemach operacyjnych.

Na potrzeby Androida stworzona została nowa, otwarta JVM o~nazwie Dalvik. Dalvik jest zoptymalizowany na urządzenia mobilne. Faktycznie operuje na innym niż standardowy kod bajtowy, ale kod dla Dalvika uzyskuje się przez dodatkową kompilację (optymalizację) zwykłego kodu bajtowego (zilustrowane na rysunku~\ref{fig:dalvik-compilation}). Teoretycznie, każdy język kompilowany do kodu bajtowego Javy (a~jest ich kilka, np. Scala) powinien móc być wykonany na Dalviku.
Poza tym, nowa maszyna wirtualna była potrzebna aby uniezależnić się od właściciela Javy (kiedyś Sun, obecnie Oracle). Narzędzia do języka (jak kompilatory) i~standardowe odmiany JVM są darmowe, ale należą do Oracle, a~ich kod nie jest otwarty. Istnieją też, co prawda, alternatywne otwarte implementacje JVM, jak ta dostarczana z OpenJDK.

\begin{figure}
	\centering
		\includegraphics[scale=0.75]{img/dalvik-compilation.jpg}
	\caption{Porównanie standardowej kompilacji Javy z~kompilacją dla Dalvika. Źródło: \cite{learning-android}}
	\label{fig:dalvik-compilation}
\end{figure}

Aktualnie istnieje już następca Dalvika -- Android Runtime (ART). Wprowadzono go jako alternatywną maszynę wirtualną w~ostatniej wersji Androida (4.4)\cite{android-art}. W~kolejnej wersji systemu -- Androidzie L -- będzie już domyślny\cite{android-l-preview}. Jego głównym celem jest przyspieszenie wykonywania aplikacji. Osiąga to przez usprawnione odśmiecanie pamięcie (ang. \emph{garbage collection}) oraz przez wprowadzenie techniki określanej jako \emph{ahead-of-time compilation} (AOT), czyli kompilacja przed czasem (kontrast dla JIT). AOT polega na tym, że w~trakcie instalacji aplikacja (skompilowana do kodu Dalvika) jest kompilowana jeszcze raz, już na kod maszynowy dopasowany do urządzenia, na którym odbywa się instalacja. Przez to zużywane jest dodatkowe miejsce, ale aplikacja może się wykonywać szybciej, ponieważ jej kod nie musi być interpretowany przez JVM.

Java która jest dostępna na Androidzie niestety nie ma pełnego zbioru standardowych bibliotek (z~Javy SE). Między innymi, brakuje wielu części pakietu \emph{javax}. Niektóre rzeczy, za które były one odpowiedzialne to świadczenie i~konsumowanie usług internetowych (bycie serwerem lub klientem dla web service'ów), czy interfejsy użytkownika (Swing, AWT). W~zamian zostały dodane pakiety ułatwiające pisanie aplikacji pod Androida. Umożliwiają one komunikację aplikacji między sobą i~z~systemem, składowanie danych, dostęp do sensorów i~funkcji telefonu oraz wiele inne przydatnych działań~\cite{android-package}. Wśród nich są też biblioteki odpowiedzialne za GUI Androida. Dzięki nim wszystkim ekosystem (programów) jest dość jednorodny i~ustandaryzowany.

Od jakiegoś czasu Java nie jest jedynym językiem, w którym można pisać aplikacje. Co prawda już kiedyś można dodać do APK bibliotekę C/C++ (pisaną przy użyciu NDK -- Native Development Kit\cite{android-ndk}) i~wołać ją z~Javy, ale zawsze potrzebny był Javowy szkielet. Teraz można oznaczyć, że APK korzysta z~\emph{NativeActivity}\cite{android-native-activity}, co pozwala całość zaimplementować natywnie. 

Warto też powiedzieć, że każda aplikacja instalowana z~APK jest identyfikowana jako odrębny Uniksowy użytkownik~\cite{android-permissions}. Dzięki temu można precyzyjnie zarządzać tym, do czego dana aplikacja ma dostęp, co zwiększa ogólne bezpieczeństwo systemu. W~systemach instalowanych na telefonach standardowo jest blokowane konto administratora systemu (\emph{root}). Użytkownik może je odblokować przez zabieg zwany rootowaniem.

Android nie ogranicza się do uruchamiania jedynie kodu napisanego w~C, C++ lub Javie (uznajmy je za języki ,,standardowe''). Istnieje aplikacja działająca jako interpreter innych języków -- SL4A~\cite{android-sl4a} -- która pozwala wykonywać skrypty napisane w~kilku językach, m.in.\ Python, Perl, Lua, JavaScript.\footnote{Inną aplikacją tego typu jest QPython (\url{http://qpython.com/}), która zawiera SL4A.}
Są też kompilatory tworzące kod bajtowy Dalvika z~języków inne niż standardowe (dla Androida). Tu przykładem jest Xamarin\footnote{\url{http://xamarin.com/}}, rozwiązanie umożliwiające pisanie w~C\# aplikacji na kilka platform, w~tym Androida.
Jednak zarówno SL4A i~Xamarin nie dają dostępu do wszystkich standardowych bibliotek. Jest tak dlatego, że użycie API Androida w~kodzie niestandardowego języka wymaga zmapowania do niego tychże API, co jest czasochłonne i~trudne do wykonania w~całości przez kogoś innego niż Google. Ponadto, niestandardowy dla Androida język, taki jak C\#, może mieć struktury, które nie dadzą się przetłumaczyć na kod bajtowy Javy. Tym samym nie będzie można go wykorzystać w~pełni. Odmiennym przypadkiem jest język Scala. Dzięki zgodności na poziomie kodu bajtowego (bo tak samo jak Java jest do niego kompilowana) Scala może być użyta do stworzenia kompletnego APK mającego dostęp do wszystkich bibliotek.

% W sumie jakiś powód musięli mieć, żeby nie dawać web serviceów.

%Może wypunktowana lista ze wspieranymi językami? Tu macie języki i jak mocno i przez co są wspierane (może tabelka? nazwa | czy można całą aplikację w tym zrobić | jakiś opis, przez co dostarczane, uwagi). Dalej co ważniejsze opisane. Oczywiście jest więcej.
%\url{http://www.dobreprogramy.pl/Google-testuje-nastepce-Dalvika-z-ARTem-Android-bedzie-dwukrotnie-szybszy,News,49129.html}
%\url{http://stackoverflow.com/questions/3316801/which-programming-languages-can-be-used-to-develop-in-android}
%\url{http://en.wikipedia.org/wiki/Android_software_development}
%https://github.com/jberkel/android-plugin
%https://github.com/jberkel/android-plugin/wiki/getting-started
%http://www.scala-sbt.org/release/tutorial/index.html

\subsection{.NET}
\label{dot-net}
.NET to technologia stworzona przez Microsoft, wspomagająca tworzenie i~uruchamianie aplikacji (w~tym usług sieciowych), głównie dla systemu Microsoft Windows\cite{dot-net-overview}. Jego główne cele:
\begin{itemize}
	\item Zapewnić jednorodne środowisko do programowania obiektowego, zarówno dla kodu lokalnego wykonywanego lokalnie, kodu rozproszonego wykonywanego lokalnie, czy wykonywanego w~całości zdalnie.
	\item Minimalizacja ilości zależności aplikacji oraz konfliktów wersji.
	\item Promowanie bezpiecznego wykonywania kodu, także od nieznanych lub częściowo zaufanych źródeł.
	\item Zlikwidowanie problemów wydajnościowych skryptów oraz kodów interpretowanych (nienatywnych).
	\item Zapewnić jednolity styl programowania na różnych platformach, np.\ przy aplikacjach okienkowych Windows i~aplikacjach internetowych.
	\item Oparcie całej komunikacji o~obowiązujące standardy, aby kod napisany pod .NETem mógł się integrować z~dowolnym innym kodem.
\end{itemize}

Cała platforma składa się z~dwóch elementów -- środowiska uruchomieniowego języka wspólnego (ang. \emph{common language runtime}) oraz biblioteki klas. Środowisko uruchomieniowe jest podstawą całej platformy. Przypomina maszynę wirtualną Javy (można je też samo nazywać maszyną wirtualną), będąc agentem, który zarządza kodem w~trakcie jego wykonywania, dostarczając przy okazji kluczową funkcjonalność jak zarządzanie pamięcią, wątkami, zdalne wywoływanie, wymuszanie bezpieczeństwa typów (ang. \emph{type safety}) i~innych form poprawności kodu zapewniających bezpieczeństwo i~solidność programów.

Kod wykonujący się w~środowisku uruchomieniowym zwany jest kodem zarządzanym (ang. \emph{managed code}). Pozostały kod, jak natywny, nazywany jest kodem niezarządanym (ang. \emph{unmanaged code}). Kod zarządzany jest kompilowany do Wspólnego Języka Pośredniego~\cite{cil} (ang. \emph{Common Intermediate Language, CIL}), który można porównać do kodu bajtowego Javy, choć jest bardziej czytelny dla człowieka. Podobnie cechuje go niezależność od sprzętu i~systemu operacyjnego.

Biblioteka klas jest obszernym zbiorem gotowych typów zgodnych z~zasadami programowania obiektowego, mogących służyć za gotowe komponenty różnych aplikacji. Są tam elementy do tworzenia aplikacji graficznych (GUI), internetowych (ASP.NET, Web Forms), kryptograficznych, czy całych usług internetowych (\emph{web services}) i~wiele innych.

Środowisko uruchomieniowe .NET może być osadzane w~aplikacji niezarządzanej w~celu ładowania kodu zarządzanego, tym samym tworząc środowisko mogące korzystać z~cech zarówno niezarządzanego jak i~zarządzanego kodu. Platforma dostarcza kilku takich ,,gospodarzy'' (\emph{hosts}) dla środowiska uruchomieniowego, wspomaga też ich tworzenie przez osoby trzecie.
Warto zaznaczyć, że Java również może być w~podobny sposób osadzana.
Przykładami gospodarzy dla środowiska .NET mogą być ASP.NET (,,framework'' do budowy aplikacji internetowych) lub Internet Explorer.

Na rysunku~\ref{fig:dotnet-ecosystem} przedstawione są zależności środowiska uruchomieniowego języka wspólnego (\emph{runtime}), biblioteki klas, systemu operacyjnego i~aplikacji użytkownika. Widać też gdzie działa kod zarządzany (\emph{managed code}) względem niezarządzanego (\emph{unamaged}).

\begin{figure}
	\centering
		\includegraphics[scale=0.6]{img/dotnet-ecosystem.png}
	\caption{Ekosystem .NETa, źródło: \cite{dot-net-overview}}
	\label{fig:dotnet-ecosystem}
\end{figure}

.NET posiada restrykcyjną infrastrukturę weryfikującą poprawność typów i~kodu zwaną CTS (\emph{Common Type System}). CTS sprawia, że cały zarządzany kod jest samo-opisujący. Różne kompilatory, zarówno te stworzone przez Microsoft, jak i~przez inne firmy mogą generować kod zgodny z~CTS\@. Dzięki temu dowolny kod zarządzany może konsumować dowolne inne zarządzane typy i~obiekty, jednocześnie surowo dbając o~bezpieczeństwo typów. To daje dużą swobodę programistom, którzy pisząc w~dowolnym zarządzanym (w~sensie kompilowanym do kodu zarządzanego .NETa) języku mogą korzystać z~pełnej standardowej biblioteki klas oraz z~zewnętrznych komponentów napisanych w~innych zarządzanych językach.

Do zarządzanych języków należą m.in.\ C\#, Visual Basic .NET, J\#, C++ (specjalna zarządzana odmiana), czy Iron Python (Python kompilowany do CIL). Jednym z~języków platformy .NET jest C\#. Typowany, imperatywny, przypomina Javę. Jest to język w~którym będę pisał .NETowe części mojej biblioteki.

Cała platforma .NET jest (słusznie\cite{dot-net-requirements}) kojarzona z~Windowsem, choć można uruchamiać napisane pod nią programy na innych systemach, jeśli tylko posiada się odpowiednią implementację środowiska uruchomieniowego, bo to ono tłumaczy wspólny kod (CIL) na natywne instrukcje (ponownie, znany z~Javy \emph{just-in-time compilation}). Niestety żadna z~alternatywnych implementacji nie wspiera wszystkich funkcji .NET\@.
Dlatego nie można z~pełną swobodą, np.\ pisać w~C\# pod Linuksa. Jednak dla wielu programów poziom wsparcia jest wystarczający.
Chyba najbardziej znana, nie pochodząca od Microsoftu implementacja -- Mono -- nie posiada kilka aspektów, takich jak WPF, WWF oraz ma ograniczone wersje WCF i~stosu asynchronicznego ASP.NET 4.5\cite{mono-compatibility}. Ale za to jest dostępna dla kilku systemów operacyjnych, m.in.\ na Linuxa, Mac OS czy Solaris\cite{mono-supported-platforms}. Także, w~przeciwieństwie do standardowej maszyny wirtualnej Microsoftu, może działać na architekturach procesorów innych niż x86 i AMD64\cite{dot-net-requirements}, np.\ na ARM, PowerPC, SPARC.

%\subsection{Odpowiedniość Javy i C\#}
%Porównać zdolności obu języków, znaleźć cechy nieprzetłumaczalne. Jak dużą zgodność można uzyskać teoretycznie?
%
%\url{http://stackoverflow.com/questions/78811/is-there-an-effective-tool-to-convert-c-sharp-code-to-java-code}\\
%\url{http://en.wikipedia.org/wiki/Comparison_of_C_Sharp_and_Java} tu wyjątkowo zacytuję Wikipedię, bo dobry artykuł\\
%\url{http://msdn.microsoft.com/pl-pl/library/ms836794.aspx} porównanie microsoftu
%
%Po prostu jest trochę różnic i nie wszystko się będzie dało przetłumaczyć 1 w 1. Ale i tak wszystkie cechy języka trudno będzie przetłumczyć. Np.\ propertiesy, adnotacje
%
%\subsection{Python}
%Pierwsza platforma jaką rozważałbym jako alternatywę dla podstawowych (Androida i .NETa) do implementacji mojej biblioteki. A to dlatego, że jest moją ulubioną. I może chodzić praktycznie na wszystkim.
%
%Z drugiej strony, ten projekt może nie mieć dla niego sensu, bo jest duck typing. Nie musi być faktycznych związków między typami. Jeśli jakieś pola albo metody znajdą się w trakcie odpalania, to dany obiekt może być uważany za taki typ. Ale nie ma żadnego problemu z zachowywaniem zależności. Właściwie można wszystko wysłać bez etykiet jako proste JSONy. Nawet jak nie zachowamy nazw typów, to mniej więcej wszystko będzie działać.
%
%Nie platforma a język, ale w sumie chodzi na wszystkim. I na windowsie, linuxie i androidzie. Lubię też w nim pisać. Można go sportować.
%
%Wzmianka, że podstawowa implementacja pythona, której będę używał (albo i nie) nie korzysta z wielu procesorów.

\section{Serializacja}
\subsection{Ogólnie}
Serializacja polega na przetworzeniu obiektu (lub grupy obiektów, lub innej struktury danych z~pamięci) w~postać nadającą się do zapisu na dysk albo do transportu przez sieć\cite{serialization-basics}. Nieodzownie łączy się też z~deserializacją -- odwrotnością serializacji, która odtwarza w~pamięci obiekt z~zapisu na dysku lub z~danych z~sieci. Kiedy będę używał określenia serializacja zazwyczaj w~domyśle będę mówił i~o~serializacji, i~o~deserializacji. Podstawową techniką serializacji jest ,,spłaszczenie'' obiektu w~jednowymiarowy strumień bitów, a~następnie, w~ramach deserializacji, na odtworzenie z~tego strumienia oryginalnego obiektu.

Warto zaznaczyć, że możliwe jest przeniesienie obiektu z~jednej platformy programistycznej na drugą (przetłumaczenie z~jednego języka programawania na inny) przez jego serializację na platformie źródłowej, a~następnie deserializację na docelowej.

Najczęściej kiedy mówi się o~serializacji nie ma się na myśli, jednak, tworzenia przenośnego (bo to cecha danych zserializowanych) ciągu bajtów. Zazwyczaj chodzi o~tekstowy zapis obiektu, mniej lub bardziej czytelny dla człowieka. Formy binarne wymagają raczej przetworzenia przez program aby sprawdzić poprawność lub ocenić, co reprezentują. W~przypadku reprezentacji tekstowej, człowiek może zidentyfikować zawartość i~poprawność po prostu czytając dokument (można tak nazwać wynik serializacji).

Serializacja binarna (do strumienia bajtów/bitów) jest na ogół szybsza i~daje mniejsze rozmiary dokumentu\footnote{Można nawet uzyskać brak narzutu względem reprezentacji obiektu w~pamięci.} niż serializacja tekstowa.
Ale obiekty przez nią zapisane mogą być trudne do odtworzenia na innych systemach operacyjnych niż źródłowy, z~uwagi na możliwą niezgodność kolejności bajtów (ang. \emph{endianness}). Wiele platform programistycznych, np.\ Java i~.NET, posiada zdolność serializacji binarnej, jednak tworzone zapisy nie są zgodne; strumień bajtów przedstawiający obiekt stworzony przez jedną platformę na ogół jest nieczytelny dla drugiej.

Serializacja tekstowa jest dużo popularniejsza od binarnej, przynajmniej w~aplikacjach heterogenicznych i~internetowych. Jest łatwiejsza w~rzeczywistym (np.\ biznesowym) użyciu, szczególnie podczas korzystania z~języków wysokopoziomowych.
Niestety wiąże się na ogół ze sporym narzutem rozmiaru danych\footnote{Szczególnie jeśli obiekt zawiera surowe dane binarne,np.\ w~formie tablicy bajtów, czy bitmapy.} i~prędkości ich przetwarzania.
Ale za to można uzyskać prostotę i~przenośność obiektów na różne platformy programistyczne.

Zapis przenośnej formy obiektów nie jest trywialny. Jeden obiekt może być powiązany z~wielką siecią innych. Czasem te połączone obiekty faktycznie zawierają się w~serializowanym, są jego logiczną częścią. Niekiedy można natrafić na duży zbiór zależnych, równoważnych sobie obiektów. W~sieci powiązań mogą też pojawić się cykle, sprawiające problemy dla automatów trawersujących graf (właśnie w~takiej formie można przedstawić obiekt) obiektu.

W~związku z~tymi problemami nie zawsze możliwe jest zachowanie całości oryginalnych danych w~transporcie.
Ale świadomość ograniczeń serializacji w~projektowaniu swoich obiektów oraz asortyment potężnych narzędzi (o~których będzie mowa w~tej pracy) pozwalają przenieść niemal wszystko.

%Wielkie porównanie różnych formatów.
%http://en.wikipedia.org/wiki/Comparison_of_data_serialization_formats

%Niestety przekazywane obiekty nie mogą mieć żadnej większej logiki związanej z dostępem do swoich danych. O ile można zmapować pola klasy w jednym języku na pola w drugim, to przetłumaczenie metod dostępowych, które mają jakąś logikę (np.\ zmień licznik odczytań, kiedy czytam zmienną) w automatyczny sposób byłoby niemal niemożliwe (wymagałoby automatu rozumiejącego sens kodu -- programu programisty).

%Binarnie można teoretycznie zapisać obiekt z pamięci jakiegoś języka nie tracąc niby żadnych informacji (chociaż powiązania dalej są problemami).
%Ale to nigdy nie będzie standardowe. Tekstowo też bym mógł w niestandardowy sposób zachować wszystko.

%A Marshalling?
%http://stackoverflow.com/questions/154185/what-is-object-marshalling
%http://stackoverflow.com/questions/770474/what-is-the-difference-between-serialization-and-marshaling
% W sumie to prawie to samo co serializacja, ale wiąże się niejako z przekazem większego sensu. Ma, chyba, na celu odtworzyć obiekt z jego tożsamością, a nie tylko jego kopię. Np.\ zmarszalowanie agenta w JADEie, przesłanie go przez sieć i odmarszalowanie w nowym kontenerze. Znika z pierwszego, pojawia się w drugim i tam już normalnie funkcjonuje; faktycznie można powiedzieć, że to ten sam obiekt, ale się przemieścił.

\subsection{Typy zapisu}
Zarówno serializacja binarna i tekstowa ma wiele odmian, o różnym stopniu rozpowszechnienia. Te bardziej rozpowszechnione można nazywać standardowymi. Tutaj niektóre zostaną przybliżone.

\subsubsection{Formaty binarne}
Platformy takie jak Java lub .NET mają swoje formaty, które mogą być wydajne ale działać tylko w~obrębie platformy.
Istnieją też różne biblioteki międzyplatformowe umożliwiające wydajną serializację danych w~taki sposób, że mogą być one rozumiane przez programy napisane w~różnych językach.
Jednak wszystkie są hermetyczne w~tym sensie, że trzeba użyć właśnie ich, żeby zdeserializować dane nimi zapisane. Ale to już cecha serializacji binarnej.

\subsubsection{Formaty tekstowe}

\begin{description}
\itemtitle{XML (EXtensible Markup Language)}
Znany od wielu lat, uniwersalny i~bardzo popularny format opisu danych. Dokument XML ma strukturę drzewa i~składa się z~elementów~\cite{xml-tutorial}. Zawsze musi być dokładnie jeden element nadrzędny, reszta dokumentu musi być zagnieżdżona w~elemencie nadrzędnym. Element zagnieżdżony nazywany jest dzieckiem, natomiast element zawierający inny element -- rodzicem. Element musi mieć nazwę, musi być zamknięty, może posiadać jedną wartość tekstową. Elementy mogą też zawierać atrybuty. W~dokumencie mogą istnieć przestrzenie nazw wspomagające przeszukiwanie dokumenty przez rozszerzenie adresowania elementów. Przykłady XML we fragmencie~\ref{kod:xml-example}.

\itemtitle{JSON (JavaScript Object Notation)}
Drzewiasty format opisu danych o~lżejszym zapisie niż XML~\cite{json-tutorial}. Wyrósł z~JavaScripta, ale nie jest z~nim powiązany. JSON ma kilka typów podstawowych do przedstawiania podstawowych jednostek danych jak tekst, liczba, czy prawda/fałsz. Można z~nich składać obiekty lub listy. Zarówno obiekty i~listy mogą zawierać inne obiekty i~inne tablice. Obiekt różni się od listy tym, że jego elementy są nazwane. Listy mogą zawierać elementy różnych typów. Nazwy pól oraz wartości tekstowe muszą się zawierać w~cudzysłowach. Przykład JSON we fragmencie~\ref{kod:json-example}

\itemtitle{Inne}
Warto zwrócić uwagę na YAML\footnote{\url{http://www.yaml.org/spec/1.2/spec.html}} który ma być przyjazny dla ludzi i~staje się obecnie coraz bardziej popularny. Korzystają z~niego takie projekty jak Ansible\footnote{\url{http://www.ansible.com/home}}, Travis\footnote{\url{https://travis-ci.org/}} czy Cloud Foundry\footnote{\url{http://www.cloudfoundry.org/index.html}}. 
Nowym formatem, który nie bardzo popularny jest AXON\footnote{\url{http://intellimath.bitbucket.org/blog/posts/axon_overcomes_json.html}, \url{http://intellimath.bitbucket.org/blog/posts/axon_best_of_json_xml_yaml.html}} -- format mający łączyć najlepsze cechy XML, JSON i~YAML.

\end{description}

\begin{lstlisting}[float, frame=single, caption={Przykłady XML. Komentarze poprzedzone przez ,,//'', mimo, że składnia komentarzy w~XML jest inna.}, label=kod:xml-example]
<?xml version="1.0" encoding="UTF-8"?> // nagłówek dokumentu XML
<lista_zakupow> // element nadrzędny dokumentu
  <pozycja>ser</pozycja> // element o nazwie ,,pozycja''
  <pozycja>mleko</pozycja> // tekstowa wartość ,,mleko''
  <pozycja niezbedne="nie">cukierki</pozycja> // atrybut ,,niezbędne''
</lista_zakupow> // zamkniecie elementu nadrzędnego

<?xml version="1.0" encoding="UTF-8"?> // nowy dokument XML
// wprowadzenie przestrzeni nazw ,,z''
<z:lista_zakupow xmlns:z="http://example.com/zakupy">
  <z:pozycja></pozycja>
  <z:pozycja/>  // elementy mogą być od razu zamknięte
</h:table>
\end{lstlisting}

\begin{lstlisting}[float, frame=single, caption={Przykłady JSON. Komentarze poprzedzone przez ,,//'', mimo, że składnia JSON nie posiada komentarzy.}, label=kod:json-example]
//przyklad 1 -- obiekt
{  // początek obiektu
  // pole obiektu o nazwie ,,liczba''
  "liczba": 13, // przecinek przed kolejnym polem
  "tekst": "wartosc tekstowa"
} // koniec obiektu

//przyklad 2 -- lista
[  // początek listy
  1,
  2,
  3,
  "czwarty element listy",
  5.0,
  true
]  // koniec listy

//przyklad 3 -- prosta wartość
"wiadomosc" // sam typ prosty to tez dokument JSON
\end{lstlisting}

%Mogą być formaty dopasowane do konretnego programu, języka albo bardziej uniwersalne.
%Może być dopasowan do jednego typu danych i jednego zastosowania (se sam napisałem jak moja klasa ma się zapisywać i odtwarzać), a może być bardziej dynamiczna i uniwersalna (binding w WCF albo JAX-WS)
%
%Jak się oznacza typy (że pole jest jakiejś klasy), np. w JSONie (JsonDataContractSerializer). W SOAPie są domyślnie, wszystko ma typ konkretny i jest bardzo ściśle. Oznaczanie typów, takie jawne, kiedy nie jest to pewne.
%
%\url{http://bsonspec.org/}\\
%\url{http://json.codeplex.com/} -- w sumie to to tylko przykład implementacji dla .NET\\

%Jakieś porównanie AXONa i JSONa. Jeśli AXON jest stabilny i wspierany na Androidzie i .NETcie (bardzo ważne) to powinienem go użyć, bo przecież parę problemów rozwiązuje.
%
%Tu coś napisać może o tym, że nie wszystkie cechy obiektu, na jakie pozwala język dają się zapisać tymi metodami. Chociaż, może to bardziej rzeczy związane z klasą są ciężkie do opisu, a jak mamy klasy opisane w normalnych językach a tylko obiekty zapisujemy, to może być spoko.


\subsection{XML Schema}
XML Schema Definition (w~skrócie XSD) to format dokumentu bazujący na XML, który określa wymagania na kształt (zawartość) innego dokumentu XML~\cite{xml-schema-tutorial}.

XSD definiuje:
\begin{itemize}
	\item elementy, które mogą pojawić się w~dokumencie,
	\item atrybuty, ktore mogą pojawić się w~dokumencie,
	\item które elementy są dziećmi,
	\item liczbę dzieci,
	\item czy element może być pusty, czy ma zawierać tekst,
	\item typy danych elementów i~atrybutów,
	\item domyślne i stałe wartości elementów i atrybutów.
\end{itemize}

Atutem XSD jest wsparcie typów danych. Dzięki niemu łatwiej można:
\begin{itemize}
	\item opisać dopuszczalną zawartość dokumentu,
	\item zweryfikować poprawność danych w~dokumencie,
	\item pracować z danymi z bazy danych,
	\item zdefiniować ograniczenia na dane (np. liczba większa niż zero),
	\item zdefiniować wzorce (formaty) danych,
	\item konwertować dane z jednego typu na drugi.
\end{itemize}

Przy pomocy XML Schema można tworzyć tzw.\ wiązania (\emph{bindings}). Najpierw trzeba stworzyć schemat XSD zgodny z~definicją klasy lub struktury danych z~jakiegoś języka programowania. Wtedy można tworzyć dokument XML na bazie, np.\ obiektu Javy, lub tworzyć obiekt Javy na bazie dokumentu XML zgodnego z~przygotowanym XSD. To właśnie można określić jako \emph{XML binding}.
Proces wiązania jest wykorzystywany w~części standardów zdalnego wołania metod.

%\subsection{Binding(TODO)}
%\url{http://rpbourret.com/xml/XMLDataBinding.htm}\\
%Pomagają przy automatycznej serializacji.
%
%A może najlepszym rozwiązaniem będzie generator customizowalnych bindingów (może nawet do JSONa) z wygodną konfiguracj)? Raz by się generowało mapowanie i wszystko działa na zawsze. 
%
%Czasem trzeba pomóc z palca, coś napisać, nadać etykietki, z czegoś zrezygnować. Czasem może działać automat. Zależy, jak zaprojektowane są dane, z jakiego języka pochodzą i jakich narzędzi używamy.
%
%NA TYM BĘDZIE DZIAŁAŁO TŁUMACZENIE KLAS
%W WSDL poza opisami operacji realizowanych przez usługę znajdują się też pliki XSD opisujące wszystkie struktury danych (klasy), które będą wymieniane. Dla tego posiadając WSDL usługi możemy wygenerować wszystkie klasy potrzebne do stworzenia klienta usługi.
%
%Złożony problem pojawia się wtedy, kiedy servicy mają działać w obie strony wykorzystując te same klasy danych. W bardziej skomplikowanych systemach rozproszonych może się pojawiać taka sytuacja. Załóżmy istnienie dwóch aplikacji: A i B. Są one napisane w różnych językach. Każda z nich udostępnia usługę zwracającą obiekt danych X. A korzysta z usługi wystawianej przez B, a B korzysta z usługi wystawianej przez A. Mimo tego, że obiekt X w obu aplikacjach będzie zawierał te same dane, to jednak jego kod będzie inny. Dlatego nie można mówić o jednej klasie X, a o dwóch. Nazwijmy je XA i XB. TUTAJ DALEJ WYTŁUMACZENIE PRZYKŁADU AŻ W KOŃCU DOJDZIEMY DO TEGO, ŻE TRZEBA NAPISAĆ KLASĘ W JEDNYM JĘZYKU, POTEM ZROBIĆ JEJ BINDING DO XSD I Z XSD DO DRUGIEGO JĘZYKA.
%
%Problem przesyłania typów polimorficznych (coś przeczytać, może). Ogólnie raczej się opisuje co ma być powiązane w jakiś modelach.
%
%Ciężko o pełną swobodę w korzystaniu z obiektowości używanych przeze mnie języków, czyli Javy i C\#. Oba niby są obiektowe, ale przy przechodzeniu przez warstwę zdalną potrafią tracić tę właściwość
%
%Może być różnie sparametryzowana i dawać rózne postaci dla takich samych obiektów, zależnie od tego, jak powiążemy xmla z klasą.\\
%\url{http://www.codeproject.com/Articles/483055/XML-Serialization-and-Deserialization-Part} w XML Serialization and Attributes\\
%
%\url{http://json-schema.org/}\\

\section{Zdalne wywoływanie kodu}
Zdalne wywoływanie kodu może być też nazywane zdalnym wywoływaniem metod lub procedur. Angielskie odpowiedniki to \emph{Remote Method Invocation} (RMI), \emph{Remote Procedure Call} (RPC) i~\emph{Remote Code Execution} (RCE). Ostatnie określenie często używane jest jako określenie na lukę bezpieczeństwa pozwalającą niepowołanym bytom na uruchomienie w~jakimś systemie niepożądanej logiki.

Aby wywołać kod zdalnie jakiś zewnętrzny klient musi, w~ogólności, wskazać obiekt, na którym ma być wywołana metoda, wybrać jedną metodę i~przekazać do niej parametry. Wszystko to można zakodować w~jednym obiekcie, którego będziemy nazywać wiadomością lub wywołaniem.
Wskazanie obiektu może polegać na podaniu jakiegoś unikatowego adresu rozpoznawanego przez serwer hostujący zdalny obiekt.
Metoda może być w~naturalny sposób zidentyfikowana przez swoją nazwę.
Obie te rzeczy można prosto zakodować we wiadomości jako obiekty typu \emph{string}.
Wyzwanie stanowi przekazanie parametrów, które mogą być dość skomplikowanymi strukturami (ogólnie -- problem serializacji).

Przekazywanie wiadomości musi odbywać się przez jakiś kanał komunikacyjny. Mogą one być bardzo różne, np. TCP, potoki (\emph{Unix pipe}), SSL, HTTP, HTTPS i~inne.
Nie ma sensu jednak poświęcać im więcej uwagi, ponieważ będę korzystał z~istniejących warstw komunikacyjnym na możliwie największym poziomie abstrakcji, aby zapewnić ich wymienność.

%Zrób tak, żeby najpierw zarysować RPC, web servicy itp a dopiero potem wiązanie danych (żeby było wiadomo po co jest)
%
%Dane (argumenty metod i~wartości przez nie zwracane) wymieniane pomiędzy klientem a serwerem będą miały postać obiektów (programowanie obiektowe). To znaczy, że typy dziedziczące i implementujące ten sam interfejs będą polimorficzne (źródło!). Często normalnie nie jest tak łatwo to osiągnąć w heterogenicznych środowiskach - ciężko o zachowanie związków między klasami po mapowaniu na drugi język
%
%Ogólnie trochę o RPC. Że wiele technologii to RPC (Web service'y, CORBA), że to zawiera i tłumaczenie i transport.
%Wywoływaniu kodu w innym procesie lub na innym kompie.
%
%\url{http://stackoverflow.com/questions/12450404/json-pojo-consumer-of-polymorphic-objects}
%
%Web-servicey, XML-RPC, REST z JSONem i XMLem. 

%Jak już się przetłumaczy, to zawsze trzeba jakoś przetransportować. Jak możemy przekazywać w ramach jednego kompa, jak pomiędzy kompami lokalnie, jak globalnie.
%Celuję w globalnie, ale zwsze szerszą metodę można zastosować wężej (chociaż może nie być tak wydajna jak te węższe)
%
%JAKIŚ OBRAZEK Z WARSTWAMI KOMUNIKACYJNYMI - FIZYCZNA, PAKIETY, TCP/IP, HTTP, SSL
%
%Nie będę się więcej na tym skupiał, to zagadnienie dla telekomunikacji. Ogólnie ta tematyka będzie u mnie w pracy pomijana i będę korzystał tylko z gotowych klocków (warstw) bez głębszego zastanowienia nad nimi. 
%
%\emph{TEŻ PRZYDAŁBY SIĘ JAKIŚ ARTYKUŁ CHOCIAŻ}
%
%\emph{TCP, PIPEy, SSL, HTTP, HTTPS}

\subsection{XML-RPC}
XML-RPC jest protokołem zdalnego wołania procedur przez Internet.\cite{xml-rpc}
Wiadomość w~tym protokole to wiadomość (zapytanie) POST protokołu HTTP. Ciałem zapytanie jest dokument XML.
W~odpowiedzi na wiadomość określony kod uruchamiany jest na serwerze po czym zwracana jest odpowiedź, również w~formie XML.
Przykłady wywołania i~odpowiedzi znajdują się odpowiednio we fragmentach~\ref{kod:xml-rpc-call} i~\ref{kod:xml-rpc-response}.

kod:xml-rpc-call
\begin{lstlisting}[float, frame=single, caption={Wywołanie metody XML-RPC.}, label=kod:xml-rpc-call]
POST /RPC2 HTTP/1.0
User-Agent: Frontier/5.1.2 (WinNT)
Host: betty.userland.com
Content-Type: text/xml
Content-length: 181


<?xml version="1.0"?>
<methodCall>
  <methodName>examples.getStateName</methodName>
  <params>
    <param>
      <value><i4>41</i4></value>
    </param>
  </params>
</methodCall>
\end{lstlisting}

\begin{lstlisting}[float, frame=single, caption={Odpowiedź XML-RPC.}, label=kod:xml-rpc-response]
HTTP/1.1 200 OK
Connection: close
Content-Length: 158
Content-Type: text/xml
Date: Fri, 17 Jul 1998 19:55:08 GMT
Server: UserLand Frontier/5.1.2-WinNT

<?xml version="1.0"?>
<methodResponse>
  <params>
    <param>
      <value><string>South Dakota</string></value>
    </param>
  </params>
</methodResponse>
\end{lstlisting}

Format URI w~pierwszej linii nagłówka HTTP nie jest określony. Może być pusty, może składać się pojedynczego ,,/'', jeśli serwer obsługuje tylko wywołania XML-RPC. Jeśli serwer obsługuję mieszankę różnych zapytań HTTP to można ustawić URI na coś, co pomoże w~obsłudzę wywołań RPC (w~przykładach ścieżka to ,,/RPC2'').

Ciało wiadomości zawarte jest jest w~elemencie \texttt{<methodCall>}. Musi on zawierać podelement \texttt{<methodName>} zawierający nazwę metody (procedury), która ma być wywołana.
Jeśli ma ona parametry, to w~wywołaniu musi się znaleźć element \texttt{<params>}. Wewnątrz niego znajdują się poszczególne parametry. Każdy z~nich musi zawierać się w~elemencie \texttt{<param>} i~posiadać element \texttt{<value>}, w~którym znajduje się właściwa wartość parametru.

Właściwie wywołania metod nie muszą być wysyłane po HTTP. Równie dobrze mogłoby to być TCP lub dowolny inny protokół, w~którym można wskazać adres odbiorcy.

XML-RPC to dość stary, ale prosty i~popularny protokół.

%\url{http://xmlrpc.scripting.com/default.html}\\
%\url{http://effbot.org/zone/xmlrpc-errata.htm}\\


\subsection{JSON-RPC}
\label{json-rpc}
Prosty, ciągle rozwijany, bezstanowy standard RPC podobny do XML-RPC. W~tym przypadku przesyłane są jednak dokumenty JSON, nie XML.
Podobnie jak XML-RPC może używać praktycznie czegokolwiek jako warstwy transportowej.
Wszystko, co pozwoli na przekazanie dokumentu JSON od klienta do serwera i~z~powrotem się nadaje.
Dzięki temu, że oparty jest o~JSON posiada bardziej zwięzłą składnię niż XML-RPC.
Składnię JSON-RPC można rozszerzać~\cite{json-rpc-extensions}.

Przykładowe wywołanie i~odpowiedź pokazane we fragmencie~\ref{kod:json-rpc-examples}.
Każda wiadomość jest obiektem JSON.
Elementy wiadomości~\cite{json-rpc-specification}:
\begin{description}
	\item[\texttt{jsonrpc}] Wartość typu \texttt{string} oznaczająca wersję protokołu JSON-RPC. Musi być równa ''2.0''.
	\item[\texttt{id}] Identyfikator ustalony przez klienta identyfikator, który musi zawierać \texttt{string}, liczbę lub wartość NULL jeśli jest zamieszczony. Jeśli jest zamieszczony jest uznawany za powiadomienie.
	\item[\texttt{method}] Wartość typu \texttt{string} zawierająca nazwę metody, która ma być wykonana. Nazwy zaczynające się od ,,rpc.'' są zarezerwowane dla rozszerzeń.
	\item[\texttt{params}] Lista zawierająca parametry, które mają być przekazane wywoływanej metodzie. Ten element może być pominięty, jeśli metoda nie przyjmuje parametrów.
	\item[\texttt{result}] Wartość zwracana przez metodę, może być NULL. Element musi istnieć, jeśli wywołanie zakończyło się sukcesem. Nie może istnieć, jeśli wystąpił błąd w~trakcie wywołania.
This member MUST NOT exist if there was an error invoking the method.
	\item[\texttt{error}] Element musi się pojawić, jeśli wystąpił błąd przy wywołaniu metody. Jej wartość musi być obiektem błędu.
	\item[Obiekt błędu] Może posiadać trzy pola: \texttt{code} -- kod błędu jako liczba całkowita, \texttt{message} -- wiadomość przekazywana z~wyjątkiem, \texttt{data}(opcjonalny) -- wartość lub obiekt zawierający dodatkowe informacje o~błędzie.
\end{description}

\begin{lstlisting}[float, frame=single, caption={Przykłady wiadomości w~JSON-RPC.}, label=kod:json-rpc-examples]
// wywołanie
{
	"jsonrpc": "2.0",
	"id": 1,
	"method": "subtract",
	"params": [42, 23]
}

// odpowiedź
{
	"jsonrpc": "2.0",
	"id": 1,
	"result": 19
}

// odpowiedź po błędzie
{
	"jsonrpc": "2.0",
	"id": "1",
	"error": {
		"code": -32601,
		"message": "Method not found"
	}
}
\end{lstlisting}


\subsection{Usługi internetowe (\emph{web services})}
Usługa internetowa to dowolna usługa dostępna przez Internet\footnote{W praktyce może działać w~mniejszych sieciach lub nawet w~obrębie jednej maszyny.} używająca ustandaryzowanego protokołu opartego o~XML~\cite{web-services}.
Nie jest bezpośrednio powiązana z~jednym systemem operacyjnym czy językiem, chociaż musi być w~jakimś zaimplementowana.
Jest kilka alternatywnych protokołów przesyłania wiadomości. Może to być XML-RPC, SOAP lub używanie wiadomości HTTP (GET i~POST) do przekazywania  arbitralnych dokumentów XML.

\emph{Web service} powinien się sam opisywać. Czyli zawsze do wystawionej pod jakimś adresem usługi powinien być załączony jej opis.
Język używany do tworzenia tych opisów to oparty o~XML WSDL (\emph{Web Service Description Language}).
Przy jego pomocy opisuje się publiczny interfejs usługi. Zawiera on definicje wszystkich publicznych funkcji, używanych przez nie typów danych\footnote{Zdefiniowanych przy użyciu XML Schema}, informacje na temat używanych protokołów transportowych oraz adresy potrzebne do zlokalizowania usługi. Przykład WSDL wzięty ze strony \url{http://www.tutorialspoint.com/wsdl/wsdl_example.htm} znajduje się na listingu~\ref{kod:wsdl-example}. Nawet dla prostych interfejsów WSDL będzie dość obszerny i~trudny do zrozumienia dla człowieka.
Jego plusem jest to, że zazwyczaj można na jego bazie wygenerować kod kliencki do wielu języków programowania.

\lstset{basicstyle=\footnotesize}
\begin{lstlisting}[float, frame=single, caption={Opis WSDL usługi posiadającej jedną metodę, \texttt{sayHello}, która zwraca tekst ,,Hello, world!''.}, label=kod:wsdl-example]
<definitions name="HelloService"
   targetNamespace="http://www.examples.com/wsdl/HelloService.wsdl"
   xmlns="http://schemas.xmlsoap.org/wsdl/"
   xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/"
   xmlns:tns="http://www.examples.com/wsdl/HelloService.wsdl"
   xmlns:xsd="http://www.w3.org/2001/XMLSchema">
 
   <message name="SayHelloRequest">
      <part name="firstName" type="xsd:string"/>
   </message>
   <message name="SayHelloResponse">
      <part name="greeting" type="xsd:string"/>
   </message>

   <portType name="Hello_PortType">
      <operation name="sayHello">
         <input message="tns:SayHelloRequest"/>
         <output message="tns:SayHelloResponse"/>
      </operation>
   </portType>

   <binding name="Hello_Binding" type="tns:Hello_PortType">
   <soap:binding style="rpc"
      transport="http://schemas.xmlsoap.org/soap/http"/>
   <operation name="sayHello">
      <soap:operation soapAction="sayHello"/>
      <input>
         <soap:body
            encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
            namespace="urn:examples:helloservice"
            use="encoded"/>
      </input>
      <output>
         <soap:body
            encodingStyle="http://schemas.xmlsoap.org/soap/encoding/"
            namespace="urn:examples:helloservice"
            use="encoded"/>
      </output>
   </operation>
   </binding>

   <service name="Hello_Service">
      <documentation>WSDL File for HelloService</documentation>
      <port binding="tns:Hello_Binding" name="Hello_Port">
         <soap:address
            location="http://www.examples.com/SayHello/">
      </port>
   </service>
</definitions>
\end{lstlisting}
\lstset{basicstyle=\normalsize}

SOAP to oparty o~XML protokół wymiany informacji, w~praktyce stosowany tylko przy~\emph{web services}. Podobnie jak WSDL jest mało zrozumiały dla ludzi, ale przenosi bardzo dokładne informacje (np. o~typach danych zawartych we wiadomości).

Usługi powinny dawać możliwość odkrywania (\emph{discovery}) się.
Do tego potrzebny jest prosty system w~którym obwieszcza się wystawienie usługi na zewnątrz.
Następnie potencjalny klient może sam znaleźć usługę i~z~niej skorzystać.
Jednym z~początkowych celów usług sieciowych była pełna automatyzacja procesu biznesowego polegającego na wyszukiwaniu usług potrzebnych danemu programowi i~wykorzystaniu ich w~swojej logice. W~praktyce nie działało to nigdy dać dobrze aby zostać szerzej przyjęte. 

Standaryzacji wprowadzonej przez \emph{web services} udało się ułatwić integrację systemów rozproszonych. Zwłaszcza tych heterogenicznych.
Mimo, że istnieją już prostsze i faktycznie pełniej wspierające heterogeniczność rozwiązania, usługi sieciowe nadal są dość popularne.
To dlatego, że dobrze sprawują się przy użyciu z~dużymi platformami programistycznymi jak .NET i~Java.
Umożliwiają szybką generację kodu popularnych języków, który często jest elegancki w~użyciu pozwala na obiektowe wołanie metod zdalnych.

Niestety, protokoły usług sieciowych są trudne w~implementacji i~nigdy nie mają pełnych możliwości na platformach mobilnych.
Też pełne implementacje, jak JAX-WS dla Javy i~WCF dla .NET nie posiadają tych samych możliwości, a~różne podzbiory ogólnego standardu.
Przez to niektóre bardziej zaawansowane aspekty \emph{web services} tracą swoją heterogeniczność.

%W sumie to przykład tłumaczenia danych  i transpotru.
%
%SOAP ma faulty -- ważną rzecz w obiektowych językach (exception).
%
%Jeden ze sposobów na zdalne wywoływanie kodu to usługi internetowe. Korzystając z otwartych standardów takich jak XML, SOAP, WSDL i UDDI umożliwiają integrację aplikacji poprzez Internet. XML jest używany do etykietowania danych, SOAP do ich pakowania i transferu (alternatywnie można używać też RESTa lub JSONa), WSDL opisuje interfejs usługi, a UDDI dostarcza spisu dostępnych usług (on nie leży w naszym obszarze zainteresowań). SOAP i WSDL są zapisywane przy pomocy XML. Web servicy używane są najczęściej do komunikacji aplikacji komercyjnych (np. serwery, portale) ze sobą lub z klientami. Pozwalają organizacjom na wymianę danych nie wymagając wiedzy o wewnętrznej strukturze informatycznej za firewallem.
%
%W przeciwieństwie do tradycyjnych modeli przetwarzania typu klient – serwer, takich jak np. system stron internetowych, usługi internetowe nie mają graficznego interfejsu użytkownika. Służą one do dzielenia logiki biznesowej, danych i procesów poprzez sieć, przy pomocy jednolitego interfejsu programistycznego. To aplikacje się komunikują, nie użytkownicy. Programiści mogą, co prawda, dodać usługę internetową do aplikacji, która posiada GUI (np. aplikacja okienkowa lub strona internetowa) aby zaoferować zwykłym użytkownikom jej funkcjonalność.
%
%Usługi internetowe pozwalają różnym aplikacjom wykonanych w różnych technologiach (np. całkowicie odmienne języki programowania) na porozumiewanie się ze sobą bez potrzeby czasochłonnego tworzenia kodu tłumaczącego. Nie ma też znaczenia to, czy obie aplikacje znajdują się na jednej maszynie, czy po drugiej stronie świata.
%Usługi sieciowe na platformie .NET realizowane są w ramach WCF. Javie obecnym standardem jest JAX-WS.
%
%co to webservicy i po co są?\\
%do czego mogą się przydać na androidzie?\\
%dlaczego ich nie ma? Chyba stwierdzili, że ogólne web servicey są za ciężkie i za bardzo obciążają (Windows phone też nie ma WCF)\\
%
%Druga rzecz, którą chcę uzyskać to możliwość łatwego tworzenia programów współpracujących między wyżej wymienionymi platformami. Kiedy wywołujemy zdalny kod często trzeba przekazać mu jakieś parametry, często też chcemy otrzymać wartości zwrotne. Pomijając sam fakt transportu danych z jednej platformy na drugą stajemy przed problemem niezgodności typów danych. Wiemy, że na obu końcach będą użyte dwa różne języki, więc struktury danych nie będą kompatybilne. Trzeba temu zaradzić.
%Ogólnie ujęte rozwiązanie dla powyższych problemów to serwer usług internetowych (ang. web services) wraz z narzędziami. Dzięki mechanizmowi usług sieciowych można wykonać dowolny kod na serwerze nie zależnie od technologii wykorzystywanych po obu stronach. Nie istnieje jeszcze (przynajmniej nie udało się znaleźć) serwer web service’ów dla Androida. Istnieją za to biblioteki pozwalające na przetłumaczenie klas z C\# na Javę.
%
%WCF to webservice'y, a jednocześnie rekomendcja microsoftu na komunikację między procesami (co prawda na innym bindingu), tak że web servicey są dość uniwersalne i dobre nie tylko w dużej sieci do komunikacji między aplikacjami.
%
%WSDL -- tylko on zapewnia używalność (cytat z RESTful).

\subsection{REST}
REST rozwija się do \emph{REpresentational State Transfer}\cite{restful-web-services}.
Jest podejściem do tworzenia rozproszonych programów w~Internecie, który polega na mechanizmach używanych przy ,,normalnej'' sieci, po której użytkownicy surfują przy pomocy przeglądarek. Czyli protokołu HTTP.
REST służy do tworzenia usług sieciowych, jednak są one czymś odmiennym niż klasyczne, ,,duże'' \emph{web services}.
REST jest konkurencją dla tych ,,dużych'' usług, chociaż ma nieco inne cele.

Popatrzmy na REST przez pryzmat klasycznego RPC. Obiekt usługi powiązany jest z~konkretnym adresem HTTP i~nazywany jest zasobem (z~ang. \emph{resource}).
Usługi nie mogą definiować dowolnych metod. Mogą zdefiniować maksymalnie cztery, które jednocześnie są czasownikami HTTP: GET, PUT, POST, DELETE. 
Parametry metod mogą być przyjmowane na kilka sposobów: przez adres, jak w~normalnym HTTP po znaku ,,?'', jako element ścieżki w~adresie, czy w~końcu jako dane w~ciele zapytania HTTP.
Format danych jest dowolny: JSON, XML lub binarne.
Ogólnie, z~RESTową usługą można się porozumiewać, jak ze zwykłą stroną Internetową.
Jest to na ogól dużo prostsze niż, bardziej intuicyjne i~łatwiejsze w~implementacji niż duże usługi sieciowe.

Mówi się, że REST to architektura skupiona na zasobach (ROA -- \emph{Resource Oriented Architecture}. Przeciwieństwem jest są standardowe architektury usług sieciowych -- SOA, czyli \emph{Service Oriented Architecture}. 

W~tej pracy będę jednak pomijał rozwiązania RESTowe ze względu na fakt, że są oparte o~HTTP.
Z~jednej strony obsługa HTTP na urządzeniu mobilnym jest bardziej problematyczna niż, chociażby, XML-RPC słane po TCP, z~drugiej -- wolałbym żeby moje rozwiązanie nie było związane z~jedną warstwą transportową.
Także REST nie daje innych możliwości niż standardowe RPC, jeśli chodzi o~polimorfizm danych.
Jego standard nic o~tym nie mówi, a~serializacja realizowana jest na ogół tymi samymi narzędziami, co w~implementacjach RPC.

%Cośtam o RESTcie \url{http://www.oracle.com/technetwork/articles/javase/index-137171.html}\\
%REST and POX \url{http://msdn.microsoft.com/en-us/library/vstudio/aa395208(v=vs.90).aspx}\\
%
%Korzysta z XMLa lub JSONa, ale raczej nie z SOAPa.
%
%Restful web services vs ,,big'' web services: \url{http://www2008.org/papers/pdf/p805-pautassoA.pdf}\\
%\url{http://www.infoq.com/articles/rest-soap-when-to-use-each}\\
%
%WADL -- taki WSDL. Ale rzadko używany raczej. Cytat z restful web services.
%
%Błędy można zwracać wiadomościami HTTP, ale jak z ich obiektowym odczytywaniem?