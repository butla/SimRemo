\chapter{Wprowadzenie}

Niniejsza praca magisterska jest próbą rozwiązania problemu napotkanego w~mojej pracy zawodowej. W poprzednim zdaniu najprawdopodobniej rzuciła się Tobie, czytelniku, od razu w oczy nieformalna konstrukcja pierwszego zdania. Mogła nawet w~nie razić. Mimo, że może się ona wydawać nieadekwatna, to przenosi nie mniej informacji niż bezosobowe stwierdzenie ``w~pracy zawodowej autora'', a~jest dla mnie -- tegoż właśnie autora -- przyjemniejsza w~użyciu, a~zatem lepsza. Więcej na ten temat później. Wracając do zasadniczego tematu -- praca polegała na rozwijaniu rozproszonego systemu przeznaczonego do tworzenia i~wykonywania zautomatyzowanych testów. Można przyjąć, że system ten miał architekturę klient-serwer. Serwer uruchamiał na sobie testowany kod sparametryzowany danymi przesyłanymi przez klienta i następnie zwracał mu wyniki. Oba te elementy działały na platformie .NET pod Windowsem (oczywiście na różnych maszynach) i~komunikowały się przy pomocy Windows Communication Foundation (WCF, czyli web service'y Microsoftu). Całe to rozwiązanie miało już swoje lata (zaczęte jeszcze w .NET 2), było ciężkie w~utrzymaniu i~mało modularne.

Postawiono przede mną zadanie dodania do systemu możliwości uruchamiania testów na platformie Android. Wielki nacisk położono na kompatybilność wsteczną. Ponieważ w aplikacji klienta nie można było robić drastycznych zmian (takich jak przepisanie na inny język), nowy serwer na Androida (który miał zostać napisany w domyślnej dla tej platformy Javie) musiał tłumaczyć dane wejściowe i wyjściowe pomiędzy językami -- Javą a~C\#.  Właśnie to umożliwiają różne systemy zdalnego wywoływania kodu w środowiskach heterogenicznych, takie jak web service'y (jedną z ich implementacji jest WCF). Niestety, Java na Androida -- a~ta różni się od standardowej -- nie ma żadnego odpowiednika serwera WCF. Trzeba go było stworzyć.

Mój system do RPC (Remote Procedure Call, z~ang.\ zdalne wywoływanie metody) nie musiał się przejmować dużą częścią bolączek istniejących przemysłowych rozwiązań, takich jak kolejkowanie wiadomości, równoległa obsługa wielu klientów, czy bezpieczeństwo komunikacji. To dlatego, że model użycia był stosunkowo prosty -- na raz łączyły się tylko dwa węzły (klient i serwer), a wszystkie dane (podróżujące w zaufanej wewnętrznej sieci) miały być łatwo podglądanie, aby wspierać debugowanie. Głównym problemem pozostało tłumaczenie danych. Udało mi się je zrealizować przez napisanie kodu w~Javie który serializował dane do XML w taki sam sposób jak .NET (przy użyciu klasy DataContractSerializer) oraz potrafił deserializować XMLe od niego otrzymane. Ponieważ nie mogłem znaleźć żadnych zasad opisujących XMLe tworzone przez DataContractSerializer, sam musiałem je wydedukować poprzez analizę wyjścia dla różnych możliwych drzew obiektów, np. tablic, list, obiektów zawierających listy list itp. Takie podejście nie dawało, niestety, pewności, że program będzie działał poprawnie (a więc tak samo, jak .NET) dla wszystkich możliwych danych. Ale dla wszystkich z~jakimi zostało sprawdzone oraz dla tych które podawali użytkownicy (programiści piszący testy bazujące na naszym frameworku) działało, więc projekt został uznany za sukces.

Sukces ten jednak nie był bardzo satysfakcjonujący. Po pierwsze przez wspomnianą niepewność poprawności działania, po drugie przez to, że kod był słabej jakości. Co prawda działał poprawnie, ale był mało czytelny i zagmatwany. Po części to wina pośpiechu przy jego tworzeniu, po części tego, że kilka razy już po jego wprowadzeniu do użytku odkrywano nowe przypadki serializacji, które nieraz zmieniały założeniu już istniejące. Oczywiste stało się, że rozwiązanie trzeba było przepisać aby mogło żyć dalej i~stać się dojrzałym produktem, na którym można polegać. A przede wszystkim musiałem się upewnić, że to co robię ma sens? Ponadto należało w~końcu porządnie się zastanowić nad naturą programu

Albo chociaż znaleźć już dobre istniejące rozwiązanie dla tego problemu.

Na obronę pierwszego systemu, który stworzyłem, trzeba powiedzieć, że POLIMORFIZM(rzadko spotykane w RPC)! Chcę to mieć w ostatecznym rozwiązaniu.

Też byłoby najlepiej, gdyby nowe klasy można było tworzyć bez problemu no i mieszać wszystko zgodnie z zasadami obiektowości (dodajemy rozszerzenie klasy to metody dla starej działają tak samo). I w dużym Linuxie i na Androidzie trzeba było to zrobić inaczej. I w Javie wszystko trzeba było generować, co i tak nie do końca współgrało z WCF problemy. I tak w ogóle, to praca zawodowa miało trochę wpływu, na to moje pisanie, bo trochę się nauczyłem (TDD, Spike'owanie).

Nie było tam za bardzo zarządzania połączeniami i innych cech dojrzałego systemu - tylko prosta map obietków i przesyłanie zserializowanych poleceń. Dlatego postanowiłem, że dobrze zrobić nowy system. Skoro i tak nie było to zgodne ze standardnem (własne łączenie, przesyłanie z serializowanych rzeczy), to nie jest dużym problemem wymienienie kawałka po stronie .NET (serializatora) i zrobienie tego tak, żeby było też ``wygodnie'' po stronie Javy. Czyli po prostu mieć kod po obu stronach, który wygląda (choć w innym języku) i zachowuje się tak samo. Poza tym brakuje takich rozwiązań, których można użyć we własnym projekcie bez używania jakiś standardowych i ciężkich rozwiązań. Poza tym, te rozwiązania i tak nie są zgodne i wspierają różne części standardu \emph{(Jakieś źródło)}.

Ta praca będzie w dużej części przeglądem i porównaniem obecnych rozwiązań. Tylko na tej drodzę można stwierdzić, że to co robię jest przydatne, a cała praca ma sens.

Docelowe rozwiązanie powinno być biblioteką na wiele języków. Skoro łączymy dwie różne technologie, z których jedna jest dość mobilna, czyli ograniczona, to może można zrobić coś dość uniwersalnego wspierającego wiele systemów. Powinno też być dojrzałe i od razu zawierać elementy zarządzania połączeniami, sesjami itp.,~chociaż skupienie leży na połączeniu 1 do 1, bo tak to bardzo często wygląda w prostym systemie, gdzie po prostu chcemy mieć most pomiędzy częściami aplikacji. Moje rozwiązanie trochę uogólniona i będzie mogła znaleźć (mam nadzieje) szerokie zastosowanie. Chciałem coś zrobić i było mi smutno, że na Androidzie nie mogłem sobie gladko wszystkiego łączyć, że trzeba było generować konkretne klasy, że nie mogło być dynamicznie

Aktualnie zakładam, że będę robił system oparty o JSON (lub jakąś jego pochodną) z oznaczaniem typów (wytłumaczenie w trakcie pracy). Jeszcze nic nie zaimplementowałem, ale zakładam, że referencyjna implementacja w Pythonie, poza tym Java (Androidowa) i C\#. Każda wersja językowa zawiera zarówno klienta jak i serwer. W trakcie pracy przeprowadzę jeszcze trochę badań i eksperymentów co dostarczy ostatecznego uzasadnienia takiego rozwiązania, lub sprawi, że wybiorę inne rozwiązanie. Że dopiero zobaczę jak działają te frameworki. Może wpadnę na nowe, bardziej adekwatne rozwiązanie. Wyjaśnić jak wytaczałem sobie drogę działania i jak metodyki dobierałem, jak zmieniało się to w trakcie pracy. Zmieniało się też zanim zacząłem pisać ten dokument.

We wstępie napisać, że głównie chodzi mi o to, żeby argumenty do metod były polimorficznei żeby nie trzeba było znać z góry typów, które mogą przejść (ogólnie jak przy normalnej obiektowości). W trakcie pracy sprawdzę, czy inne frameworki potrafią to robić bez jakiś strasznych tricków (out of the box, żeby programista się nie męczył). Jeśli potrafią, to jak wygodnie się z tego korzysta.

Jest trudniejsza niż inne prace, bo jest bardziej niezależna i dziedzina problemu jest szersza. Rzucony na otwartą wodę musiałem sobie radzić i tak może powstanie coś, czego jeszcze na świecie nie ma (albo nie jest tak przyjemne w użyciu). Co prawda pewnie nie będzie uniwersalne, ale będzie lepszym niż dostępne rozwiązaniem pewnej klasy problemów (jak już ktoś ma te kawałki).

\emph{(Twarde spacje gdzie trzeba, żeby nie było sierot)}

\emph{(Dodać spis pojęć)}

\emph{(Rozdziały albo mniejsze sekcje w osobnych plikach, które będą includowane.)}

\begin{em}
Do każdego punktu co i dlaczego znaleźć jakiś artykuł

Wyślij kiedyś szablon strony tytułowej.
Wywalić Jacka jako konsultanta. Załatwić sobie kogoś od web service’ów z KASKU jako konsultanta/recenzenta. Zmienić tytuł pracy na jakiś uniwersalny obiektowy cross-platform system. O Androidzie i .NETcie napisać w wymaganiach.
\end{em}

\section{Cele pracy}
Dokładnie określić po co ta praca. W czym ma się przydać, po co ją robić? Jakie ma wymagania?
Powiedzieć, że tematyka będzie wyjaśniona za jakiś czas.

CELE: pełne wsparcie programowania obiektowego, prostota i szybkość użycia, łączenie różnych technologii
Głównym celem pracy jest stworzenie rozwiązania (biblioteki), które pozwoli na zdalne wywoływanie kodu w systemie Android z platformy .NET przy pomocy języka C\#. Można powiedzieć, że jest to zarządzanie Androidem z Windowsa (bo .NET najprawdopodobniej chodzi właśnie na nim).

Druga rzecz, którą chcę uzyskać to możliwość łatwego tworzenia programów współpracujących między wyżej wymienionymi platformami. Kiedy wywołujemy zdalny kod często trzeba przekazać mu jakieś parametry, często też chcemy otrzymać wartości zwrotne. Pomijając sam fakt transportu danych z jednej platformy na drugą stajemy przed problemem niezgodności typów danych. Wiemy, że na obu końcach będą użyte dwa różne języki, więc struktury danych nie będą kompatybilne. Trzeba temu zaradzić.
Ogólnie ujęte rozwiązanie dla powyższych problemów to serwer usług internetowych (ang. web services) wraz z narzędziami. Dzięki mechanizmowi usług sieciowych można wykonać dowolny kod na serwerze nie zależnie od technologii wykorzystywanych po obu stronach. Nie istnieje jeszcze (przynajmniej nie udało się znaleźć) serwer web service’ów dla Androida. Istnieją za to biblioteki pozwalające na przetłumaczenie klas z C\# na Javę.

W reszcie rozdziału jest wytłumaczone dokładniej jak działają wspomniane tutaj mechanizmy oraz jak zostanie stworzony mój serwer.

Wiele środowisk chcemy wspierać, np. Windows Phone też

Porównanie istniejcych rozwiązań, udowodnienie, że to co robię ma niszę dla siebie jakąś.

\section{Używany język (opcjonalnie)}
Napisać o tym, że język w mojej pracy może nie być do końca formalny. Mogę wtedy przekazywać informacje tak samo dobrze albo nawet lepiej (bo mogę być bardziej obrazowy, a nie muszę być od razu nieprecyzyjny) a zarówno pisanie jak i czytanie pracy będzie przyjemniejsze. Nauka powinna być frajdą. Coś przytoczyć może z tego headfirsta albo ich źródeł? W anglojęzycznej literaturze, która jest w sumie światowym standardem naukowym (jakiś cytat znaleźć) często tworzą jakieś nieformalne konstrukcje (sandwiche, cargo cult programming). Cytat z Head firsta o tym, że jak jest rozmowa to się lepiej czyta i pamięta. A zakładam, że ktoś poza mną przynajmniej raz będzie to czytał i chociaż jego zadanie będzie przyjemniejsze. Moje na pewno. Niby praca dyplomowa ma być napisana jasno i konkretnie (\url{http://www.slideshare.net/jszypryt/prace-dyplomowe-i-ich-cele-rodzaje-i}), a takie bezosobowe ściemnianie jest oczywistym tego przeciwieństwem. Bo przecież napisanie, że jakiś program ``zrobiono'' albo, że ``powstał'' ukrywa prawdę, że to właśnie JA zrobiłem. Za często trzeba się zastanawiać jak coś trafnie sformułować, żeby nie brzmiało nazbyt potocznie. Zdecydowałem się odrzucić takie problemy. Uznaję, że jeśli tekst przekazuje informacje precyzyjnie i zrozumiale dla osoby posługującej się współczesnym językiem polskim to jest to tekst poprawny.

\section{Docelowe platformy}
Tu o tych, co będą wymaganie. O specyfice .NETa i Androida, co i jak można na tym pisać (jakie języki)

\subsection{Android}
Tu o Androidzie, o JVM o samym języku Java. Jego środowisko programistyczne.

Wizja systemu Android. Że to na telefony. Co w tej Javie jest, dlaczego tak jest, czego nie ma (właśnie tych bibliotek). Dalvik. Co jest w C (bionic)? Nowa maszyna (\url{http://www.dobreprogramy.pl/Google-testuje-nastepce-Dalvika-z-ARTem-Android-bedzie-dwukrotnie-szybszy,News,49129.html}) wirtualna na Androida.
Jak działa Java? Maszyna wirtualna, baza w C, teoretycznie ten sam kod powinien działać wszędzie, należy jednak dobrze zaimplementować podstawę wszystkich bibliotek (czyli maszynę). A czasem są np. rozbieżności (drobne) pomiędzy windowsem a Linuxem.

Jak Androidowa Java współpracuje z innymi środowiskami.

\subsection{.NET}
Tu o .NETcie i o C\# (bo tego będę używał).
Jak .NET współpracuje z innymi środowiskami

\subsection{Python}
W sumie chodzi na wszystkim. I na windowsie, linuxie i androidzie. Lubię też w nim pisać. Można go sportować.

Wzmianka, że podstawowa implementacja pythona, której będę używał (albo i nie) nie korzysta z wielu procesorów.

\section{Zdalne wywoływanie kodu}
Tu o RPC, o problemach, o tłumaczeniu danych, istniejących standardach itp.

Czym jest programowanie obiektowe napisać, co to polimorfizm i dlaczego ważny

\subsection{Tłumaczenie danych}
Jaka jest problematyka przetłumaczenia danych/obiektów z jednego języka, platformy na drugą?
Nawet na niskim poziomie mamy little/big endian. Potem dochodzi jeszcze niezgodność kodów bajtowych platform wirtualnych.
Nawet jak się zapisze w XML, JSONie czy czymś innym to możemy stosować inne formaty, czy coś. Bindingi.

problemy komunikacji w heterogenicznych środowiskach (inne formaty danych, inne dostępne klasy i zasady działania obiektów, np. Type erasure)

Zgodność zapisu bajtowego obiektów w .NETcie, Javie i Dalviku (może inna niż w normalnej Javie, może pomiędzy maszynami wirtualnymi też różna). Gdyby wszystko było zgodne to nie trzeba by się było tak męczyć z szukaniem standardu opisu danych. Też type erasure wchodzi w grę (zapis bajtowy dwóch list różnych typów sprawdzić)

\url{http://json-schema.org/}\\
\url{http://bsonspec.org/}\\
\url{http://json.codeplex.com/}\\

\emph{JAKAŚ KSIĄŻKA O TYM?}

\subsubsection{Serializacja}

\subsection{Transport danych}
Też bardzo szeroka dziedzina. Jak już się przetłumaczy, to zawsze trzeba jakoś przetransportować. Jak możemy przekazywać w ramach jednego kompa, jak pomiędzy kompami lokalnie, jak globalnie.
Celuję w globalnie, ale zwsze szerszą metodę można zastosować wężej (chociaż może nie być tak wydajna jak te węższe)

\emph{TEŻ PRZYDAŁBY SIĘ JAKIŚ ARTYKUŁ CHOCIAŻ}

\emph{TCP, PIPEy, SSL, HTTP, HTTPS, Webservicey, SOAP, REST, JSON}

\url{http://stackoverflow.com/questions/12450404/json-pojo-consumer-of-polymorphic-objects}

\subsection{RPC}
Ogólnie trochę o RPC. Że wiele technologii to RPC (Web service'y, CORBA), że to zawiera i tłumaczenie i transport.
Wywoływaniu kodu w innym procesie lub na innym kompie.

\url{http://www.infoq.com/articles/rest-soap-when-to-use-each}\\

\url{http://xmlrpc.scripting.com/default.html XML RPC}\\
\url{http://xmlrpc.scripting.com/spec.html}\\
\url{http://effbot.org/zone/xmlrpc-errata.htm}\\
Przejrzeć specyfikację, zobaczyć, z czym musieli sobie poradzić i wyczaić jak to wszystko mozna odwzorować w JSONie. Obczaić, jak sobie DataContractSerializer (też DataContractJsonSerializer) radzą. 

Service oriented architecture a remote procedure call? Jakie różnice? Czym będzie moje? A same web services?

\subsection{XML binding}
NA TYM BĘDZIE DZIAŁAŁO TŁUMACZENIE KLAS
W WSDL poza opisami operacji realizowanych przez usługę znajdują się też pliki XSD opisujące wszystkie struktury danych (klasy), które będą wymieniane. Dla tego posiadając WSDL usługi możemy wygenerować wszystkie klasy potrzebne do stworzenia klienta usługi.

Złożony problem pojawia się wtedy, kiedy servicy mają działać w obie strony wykorzystując te same klasy danych. W bardziej skomplikowanych systemach rozproszonych może się pojawiać taka sytuacja. Załóżmy istnienie dwóch aplikacji: A i B. Są one napisane w różnych językach. Każda z nich udostępnia usługę zwracającą obiekt danych X. A korzysta z usługi wystawianej przez B, a B korzysta z usługi wystawianej przez A. Mimo tego, że obiekt X w obu aplikacjach będzie zawierał te same dane, to jednak jego kod będzie inny. Dlatego nie można mówić o jednej klasie X, a o dwóch. Nazwijmy je XA i XB. TUTAJ DALEJ WYTŁUMACZENIE PRZYKŁADU AŻ W KOŃCU DOJDZIEMY DO TEGO, ŻE TRZEBA NAPISAĆ KLASĘ W JEDNYM JĘZYKU, POTEM ZROBIĆ JEJ BINDING DO XSD I Z XSD DO DRUGIEGO JĘZYKA.

Problem przesyłania typów polimorficznych (coś przeczytać, może). 

\subsection{Web service'y i SOAP}
W sumie to przykład tłumaczenia danych  i transpotru.

Jeden ze sposobów na zdalne wywoływanie kodu to usługi internetowe. Korzystając z otwartych standardów takich jak XML, SOAP, WSDL i UDDI umożliwiają integrację aplikacji poprzez Internet. XML jest używany do etykietowania danych, SOAP do ich pakowania i transferu (alternatywnie można używać też RESTa lub JSONa), WSDL opisuje interfejs usługi, a UDDI dostarcza spisu dostępnych usług (on nie leży w naszym obszarze zainteresowań). SOAP i WSDL są zapisywane przy pomocy XML. Web servicy używane są najczęściej do komunikacji aplikacji komercyjnych (np. serwery, portale) ze sobą lub z klientami. Pozwalają organizacjom na wymianę danych nie wymagając wiedzy o wewnętrznej strukturze informatycznej za firewallem.

W przeciwieństwie do tradycyjnych modeli przetwarzania typu klient – serwer, takich jak np. system stron internetowych, usługi internetowe nie mają graficznego interfejsu użytkownika. Służą one do dzielenia logiki biznesowej, danych i procesów poprzez sieć, przy pomocy jednolitego interfejsu programistycznego. To aplikacje się komunikują, nie użytkownicy. Programiści mogą, co prawda, dodać usługę internetową do aplikacji, która posiada GUI (np. aplikacja okienkowa lub strona internetowa) aby zaoferować zwykłym użytkownikom jej funkcjonalność.

Usługi internetowe pozwalają różnym aplikacjom wykonanych w różnych technologiach (np. całkowicie odmienne języki programowania) na porozumiewanie się ze sobą bez potrzeby czasochłonnego tworzenia kodu tłumaczącego. Nie ma też znaczenia to, czy obie aplikacje znajdują się na jednej maszynie, czy po drugiej stronie świata.
Usługi sieciowe na platformie .NET realizowane są w ramach WCF. Javie obecnym standardem jest JAX-WS.

co to webservicy i po co są?\\
do czego mogą się przydać na androidzie?\\
dlaczego ich nie ma? Chyba stwierdzili, że ogólne web servicey są za ciężkie i za bardzo obciążają (Windows phone też nie ma WCF)\\

\subsection{JSON, YAML, AXON}
\url{http://intellimath.bitbucket.org/blog/posts/axon_overcomes_json.html}\\
Jakieś porównanie AXONa i JSONa. Jeśli AXON jest stabilny i wspierany na Androidzie i .NETcie (bardzo ważne) to powinienem go użyć, bo przecież parę problemów rozwiązuje.

Oznaczanie typów.

\subsection{REST}
Cośtam o RESTcie \url{http://www.oracle.com/technetwork/articles/javase/index-137171.html}\\
REST and POX \url{http://msdn.microsoft.com/en-us/library/vstudio/aa395208(v=vs.90).aspx}\\

Restful web services vs ``big'' web services: \url{http://www2008.org/papers/pdf/p805-pautassoA.pdf}\\