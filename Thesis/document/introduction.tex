\chapter{Wprowadzenie}
\label{intro}

Niniejsza praca magisterska jest próbą rozwiązania problemu napotkanego w~mojej pracy zawodowej. W poprzednim zdaniu najprawdopodobniej rzuciła się Tobie, czytelniku, od razu w oczy nieformalna konstrukcja pierwszego zdania. Mogła nawet w~nie razić. Mimo, że może się ona wydawać nieadekwatna, to przenosi nie mniej informacji niż bezosobowe stwierdzenie ``w~pracy zawodowej autora'', a~jest dla mnie -- tegoż właśnie autora -- przyjemniejsza w~użyciu, a~zatem lepsza. Więcej o~tym później. Wracając do zasadniczego tematu -- praca polegała na rozwijaniu rozproszonego systemu przeznaczonego do tworzenia i~wykonywania zautomatyzowanych testów. Można przyjąć, że system ten miał architekturę klient-serwer. Serwer uruchamiał na sobie testowany kod sparametryzowany danymi przesyłanymi przez klienta i następnie zwracał mu wyniki. Oba te elementy działały na platformie .NET pod Windowsem (oczywiście na różnych maszynach) i~komunikowały się przy pomocy Windows Communication Foundation (WCF, czyli web service'y Microsoftu). Całe to rozwiązanie miało już swoje lata (zaczęte jeszcze w .NET 2), było ciężkie w~utrzymaniu i~mało modularne. Tylko wspomnę, że wszystkie technologie i~techniki wymieniane w~tym i~następnych akapitach będą szerzej przybliżone w~dalszej części pracy.

Postawiono przede mną zadanie dodania do systemu możliwości uruchamiania testów na platformie Android. Wielki nacisk położono na kompatybilność wsteczną. Ponieważ w aplikacji klienta nie można było robić drastycznych zmian (takich jak przepisanie na inny język), nowy serwer na Androida (który miał zostać napisany w domyślnej dla tej platformy Javie) musiał tłumaczyć dane wejściowe i wyjściowe pomiędzy językami -- Javą a~C\#.  Właśnie to umożliwiają różne systemy zdalnego wywoływania kodu w środowiskach heterogenicznych, takie jak web service'y (jedną z~ich implementacji jest WCF). Niestety, Java na Androida -- a~ta różni się od standardowej -- nie ma żadnego odpowiednika serwera WCF. Trzeba go było stworzyć.

Mój system do RPC (Remote Procedure Call, z~ang.\ zdalne wywoływanie metody) nie musiał się przejmować dużą częścią bolączek istniejących przemysłowych rozwiązań, takich jak kolejkowanie wiadomości, równoległa obsługa wielu klientów, czy bezpieczeństwo komunikacji. To dlatego, że model użycia był stosunkowo prosty -- na raz łączyły się tylko dwa węzły (klient i~serwer), a wszystkie dane (podróżujące w zaufanej wewnętrznej sieci) miały być łatwo podglądanie, aby wspierać debugowanie. Głównym problemem pozostało tłumaczenie danych. Udało mi się je zrealizować przez napisanie kodu w~Javie który serializował obiekty do XML w~taki sam sposób jak .NET (przy użyciu klasy DataContractSerializer) oraz potrafił deserializować XMLe od niego otrzymane. Ponieważ nie mogłem znaleźć żadnych zasad opisujących XMLe tworzone przez DataContractSerializer, sam musiałem je wydedukować poprzez analizę wyjścia dla różnych drzew obiektów, np. tablic, list, obiektów zawierających listy list itp. Takie podejście nie dawało, niestety, pewności, że program będzie działał poprawnie (a więc tak samo, jak .NET) dla wszystkich możliwych danych. Ale dla wszystkich z~jakimi został sprawdzony oraz dla tych które podawali użytkownicy (programiści piszący testy bazujące na naszym frameworku) działał, więc projekt został uznany za sukces.

Sukces ten jednak nie był bardzo satysfakcjonujący. Po pierwsze przez wspomnianą niepewność poprawności działania, po drugie przez to, że kod był słabej jakości. Co prawda działał poprawnie, ale był mało czytelny i zagmatwany. Po części to wina pośpiechu przy jego tworzeniu, po części tego, że kilka razy już po jego wprowadzeniu do użytku odkrywano nowe przypadki serializacji, które nieraz zmieniały założeniu już istniejące. Oczywiste stało się, że rozwiązanie trzeba było przepisać aby mogło żyć dalej i~stać się produktem, na którym można polegać. Co więcej tym razem trzeba było się dużo poważniej zastanowić nad miejscem mojej biblioteki w~ekosystemie systemów rozproszonych i nad uzasadnieniem jej stworzenia. Bo może jednak jest gdzieś na świecie coś, co spełniałoby nasz scenariusz użycia a~wcześniej zostało przeoczone. Albo przez ostatnie dwa lata, czyli od skończenia mojej pracy nad starym projektem, ktoś coś takiego stworzył.

Tak zostały wytyczone zgrubne cele niniejszej pracy magisterskiej: przeszukanie istniejącego oprogramowania w~celu wyłonienia kandydatów na gotowe rozwiązanie (bądź jego składniki), praktyczne porównanie możliwości istniejących bibliotek oraz w końcu, jeśli będzie taka potrzeba, stworzenie własnego produktu. Owocem mojej pracy powinno być coś, co przede wszystkim pozwoli zminimalizować nakład pracy programisty przy tworzeniu kanału komunikacyjnego między aplikacjami wykonanymi w~różnych technologiach, chociaż podstawowym celem jest łączenie Androida z~.NETem. To idzie w~parze z~wielkim atutem mojego programu -- dynamicznym (nie wymagającym specjalnych oznaczeń) polimorfizmem danych. Był już obecny nawet w~moim prototypie, a~nie jest cechą często spotykaną w~systemach RPC.

Aktualnie zakładam, że nowy system (owoc niniejszej pracy magisterskiej) będzie wykorzystywał mój format serializacji obiektów (danych) polegający na użyciu JSONa (lub jakiejś jego pochodnej) z~zapisywaniem dodatkowej informacji o~typie tychże obiektów dla wspomożenia polimorfizmu. Było już parę innych koncepcji (które będą przybliżone w~późniejszym rozdziale), a~dla jednej nawet powstał prosty prototyp, ale wszystkie zawierały jakąś poważną skazę. Ponieważ obecny pomysł zakłada, że zarówno biblioteka serwera (Android) jak i~klienta (.NET) będą potrafiły porozumiewać się w~obie strony tym samym językiem, nic nie stoi na przeszkodzie (poza czasem i~chęciami) aby powstały klienty i~serwery na inne platformy i~inne języki. Wnosi to chociażby tyle, że referencyjna implementacja obu części architektury może powstać w~Pythonie, który jest moim ulubionym językiem i~pozwala na szybkie przelewanie myśli na kod. W trakcie pracy przeprowadzę jeszcze sporo badań, co, mam nadzieję, dostarczy ostatecznego uzasadnienia aktualnej koncepcji systemu, ale może też zaowocować powstaniem nowej.

System który ostatecznie stworzę nie znajdzie, najprawdopodobniej, zastosowania w~przemysłowych projektach, ponieważ umyślnie będę pomijał niezbędne elementy dużych rozproszonych architektur -- bezpieczeństwo komunikacji, zrównoleglanie żądań itp. To, na czym głównie się skupiam, to pokazanie, że łączenie heterogenicznych aplikacji może być całkiem bezbolesne. W~trakcie pisania pracy będę brał pod uwagę jedynie współpracę dwóch programów na raz, ale małe sieci (do kilkunastu klientów na serwer) powinny również działać dobrze (co będę to sprawdzał). W przypadku, gdy mój projekt się powiedzie, to oczywiście będzie go można rozwijać dalej. Bycie otwartym i~publicznie dostępnym może tylko w~tym pomóc. Poza tym, jeśli znajdzie gdzieś rzeczywiste zastosowanie (co mnie by bardzo cieszyło, a~mu dałoby szansę na ``życie''), to najpewniej właśnie w~innych projektach z~domeny Open Source.

%Wydaje mi się, że niniejsza praca jest trudniejsza w~realizacji niż większość innych na naszym wydziale. Rzucony na otwartą wodę szerokiej dziedziny musiałem sobie radzić sam. Z~wytyczonym z~grubsza celem sam musiałem go dookreślić (aby w~ogóle powstał temat) i~wyszukać możliwe rozwiązania. Podczas gdy wiele prac polega na sprawdzeniu lub zrealizowaniu jednego pomysłu, ja musiałem najpierw stworzyć sam pomysł -- i~to nie jeden. Mimo, że mój ostateczny produkt nie powinien być bardzo skomplikowany (taką mam nadzieję), to droga, którą musiałem pokonać 
%wysiłek umysłowy potrzebny do odnalezienia się w~tym świecie i zaproponowaniu czegoś, czego jeszcze nie ma jest znaczny. Droga potrzebna do odnalezienia tego rozwiązania jest męcząca -- ją przedstawię. Cały czas się zastanawiam, czy ma to sens.

%Nie było tam za bardzo zarządzania połączeniami i innych cech dojrzałego systemu - tylko prosta map obietków i przesyłanie zserializowanych poleceń. Dlatego postanowiłem, że dobrze zrobić nowy system. Skoro i tak nie było to zgodne ze standardnem (własne łączenie, przesyłanie z serializowanych rzeczy), to nie jest dużym problemem wymienienie kawałka po stronie .NET (serializatora) i zrobienie tego tak, żeby było też ``wygodnie'' po stronie Javy. Czyli po prostu mieć kod po obu stronach, który wygląda (choć w innym języku) i zachowuje się tak samo. Poza tym brakuje takich rozwiązań, których można użyć we własnym projekcie bez używania jakiś standardowych i ciężkich rozwiązań. Poza tym, te rozwiązania i tak nie są zgodne i wspierają różne części standardu \emph{(Jakieś źródło)}.

\section{Cele pracy}
W tym miejscu zdefiniowane i uzasadnione zostaną cele niniejszej pracy. Ponadto wymienię zagadnienia, które będą pomijane aby nie przesłaniać najważniejszych (według mnie) kwestii.

%Każdy punkt powinien mieć dwie podsekcje - co? (wyjaśnia co dokładnie będzie zrobione) i dlaczego? (moje pobódki, co mi i innym to da). Jak? Po co? dla każdego celu zostanie odpowiedziane już w pracy.

\subsection{Przybliżenie tematyki}
Aby dało się zrozumieć pobudki, wywody oraz produkty tej pracy należy zaznajomić się z~tematyką zdalnego wywoływania kodu oraz charakterystyką docelowych platform. Zrobienie tego w~stopniu wystarczającym powinien umożliwić rozdział \ref{intro}.

\subsection{Porównanie istniejącego oprogramowania}
Przybliżone i~porównane zostaną co bardziej interesujące (dla mojego zastosowania) istniejące biblioteki oraz frameworki z~dziedziny RPC i~serializacji. Będzie to obszerna i~bardzo ważna część tej pracy.

Tylko przez takie badania można stwierdzić, że mój produkt znajdzie dla siebie jakąś niszę, a~zatem tworzenie go nie będzie pozbawione praktycznego sensu.

Technologie będą rozpatrywane w kategoriach:
\begin{itemize}
	\item obecności pożądanych przeze mnie cech (wymienianych w \ref{lib_requirements}),
	\item spełniania obietnic, co do swoich możliwości,
	\item zdolności współpracy z~innymi technologiami.
\end{itemize}

Po tej analizie stwierdzę na których rozwiązaniach mogę się wzorować lub wykorzystać jako elementy swojego.

\subsection{Stworzenie wieloplatformowej biblioteki(TODO)}
\label{lib_requirements}
Oprogramowanie które stworzę będzie miało postać kilku (dwóch lub więcej) bibliotek na różne systemy. Każda z~nich będzie miała analogiczny interfejs i~taką samą funkcjonalność. Wyliczam cechy, których kombinacji jeszcze nie spotkałem i~którymi to ma się odznaczać mój program.

\begin{description}
\itemtitle{Dynamiczny polimorfizm obiektów danych}
Dane będą obiektami. Będą polimorficzne. Można wywoływać metody. Krótko wyjaśnić polimorfizm.
No musi być niezłe. Żadnych wzajemnych zależności. Pełne wsparcie programowania obiektowego. Brak wymagania oznaczeń tworzących wzajemne zależności (jak KnownType w .NETcie). Jakieś tam pojedyncze, proste mogą być (transient itp.), ale żeby robiło się je raz i żeby dalej klasa mogła być dowolnie rozszerzana a pierwotny kod nieruszany. Opisać o co chodzi z tym polimorfizmem, że w WCF trzeba wypisywać KnownType, co jest robieniem wzajemnych zależności, co jest straszną praktyką programowania (źródło). Polimorfizm daje rozszerzalność danych przez dziedziczenie.

\itemtitle{Prostota}
Można szybko używać. prostota, łatwość i szybkość użycia, łączenie różnych technologii. Przejrzyste API. Sama szuka klas, umila życie. W~ogóle moje będzie piękne, obiektowe i~uniewżni tyle trosk. Fakt, będzie się to wiązało z~jakimś narzutem performance'owym na szukanie klas nie wskazanych jawnie, a~i~trzeba będzie ustalić jakiś mechanizm szukania. Ale performace to często obecnie kwestia drugorządna (źródło o jakiś wolnych pythonach, w których ludzie piszą, bo im fajnie itp.). Chciałem coś zrobić i było mi smutno, że na Androidzie nie mogłem sobie gladko wszystkiego łączyć, że trzeba było generować konkretne klasy, że nie mogło być dynamicznie

\itemtitle{Wywoływanie kodu na Androidzie z C\#}
Należy się skupić na połączenia Androida z .NETem i to jest celem minimalnym. Ale zrobienie biblioteki ogólnej może nie być dużo bardziej skomplikowane, dlatego warto spróbować. Można powiedzieć, że jest to zarządzanie Androidem z Windowsa (bo .NET najprawdopodobniej chodzi właśnie na nim).

\itemtitle{Uniwersalne wywoływanie kodu}
Jak już Android i C\#, które są różne, to można więcej dodać. Najprawdopodobniej bez więszkego wysiłku będzie to można uogólnić tworząc biblioteki, które dają możliwości zarówno klienta jak i serwera, a także dostosować je do innych platform. Sam python chodzi na wielu (tu źródła). Docelowe rozwiązanie powinno być biblioteką na wiele języków. Skoro łączymy dwie różne technologie, z których jedna jest dość mobilna, czyli ograniczona, to może można zrobić coś dość uniwersalnego wspierającego wiele systemów. 
\end{description}

Rzeczy, które są ważne przy łączeniu, ale nie będę się na nich skupiał, bo istnieją już ich dobre implementacje. Ponieważ nie sposób choć trochę o nich nie myśleć przy projektowaniu takiego systemu, to jeśli będzie to sprawiało minimalny problem, to będę dążył do jak najwyższej ich wartości, albo zostawiał miejsce na ich zapewnienie w przyszłości.
\begin{description}
\itemtitle{Bezpieczeństwo}
Zakładam, że można dodać jako warstwę, np. wymienić TCP na SSL (jakiś link). A nie będę się bezpośrednio wiązał z jedną warstwą transportową, tak że spoko.
\itemtitle{Wydajność}
Powinno też być dojrzałe i od razu zawierać elementy zarządzania połączeniami, sesjami itp., chociaż skupienie leży na połączeniu 1 do 1, bo tak to bardzo często wygląda w prostym systemie, gdzie po prostu chcemy mieć most pomiędzy częściami aplikacji.
\end{description}

\section{Używany język (TODO)}
Napisać o tym, że język w mojej pracy może nie być do końca formalny. Mogę wtedy przekazywać informacje tak samo dobrze albo nawet lepiej (bo mogę być bardziej obrazowy, a nie muszę być od razu nieprecyzyjny) a zarówno pisanie jak i czytanie pracy będzie przyjemniejsze. Nauka powinna być frajdą. Coś przytoczyć może z tego headfirsta albo ich źródeł? W anglojęzycznej literaturze, która jest w sumie światowym standardem naukowym (jakiś cytat znaleźć) często tworzą jakieś nieformalne konstrukcje (sandwiche, cargo cult programming). Cytat z Head firsta o tym, że jak jest rozmowa to się lepiej czyta i pamięta. A zakładam, że ktoś poza mną przynajmniej raz będzie to czytał i chociaż jego zadanie będzie przyjemniejsze. Moje na pewno. Niby praca dyplomowa ma być napisana jasno i konkretnie (\url{http://www.slideshare.net/jszypryt/prace-dyplomowe-i-ich-cele-rodzaje-i}), a takie bezosobowe ściemnianie jest oczywistym tego przeciwieństwem. Bo przecież napisanie, że jakiś program ``zrobiono'' albo, że ``powstał'' ukrywa prawdę, że to właśnie JA zrobiłem. Za często trzeba się zastanawiać jak coś trafnie sformułować, żeby nie brzmiało nazbyt potocznie. Zdecydowałem się odrzucić takie problemy. Uznaję, że jeśli tekst przekazuje informacje precyzyjnie i zrozumiale dla osoby posługującej się współczesnym językiem polskim to jest to tekst poprawny.

\emph{Mam jakies rzeczy w downloadsach.} \\
\url{http://galaxy.agh.edu.pl/~wkowalsk/dydaktyka/skrypt.pdf}\\
\url{http://chomikuj.pl/miechu17/Ksi*c4*85*c5*bcki/Uwagi+o+pisaniu+i+redagowaniu+prac+dyplomowych+na+studiach+technicznych+-+E.+Opoka,3372705642.pdf}\\
\url{http://dyplom.best4u.pl/zasady-pisania-prac-dyplomowych}\\
\url{http://zwa.univ.szczecin.pl/wp-content/uploads/2013/04/zasady-pisania-prac-dyplomowych_2012_2013.pdf}\\
\url{http://www.slideshare.net/jszypryt/prace-dyplomowe-i-ich-cele-rodzaje-i}\\
\url{http://www.ithg.wsg.byd.pl/userfiles/files/II%20Uwagi%20dotycz%C4%85ce%20pisania%20prac%20seminaryjnych(1).pdf}\\
\url{http://dydaktyka.polsl.pl/kwmimkm/jak_pisac.pdf}\\
\url{http://www.maraton.home.pl/por_aut.htm}\\

Książki O'Reilly i Head First na przykłady.

\section{Docelowe platformy}
Tu o tych, co będą wymaganie. O specyfice .NETa i Androida, co i jak można na tym pisać (jakie języki)

\subsection{Android}
Tu o Androidzie, o JVM o samym języku Java. Jego środowisko programistyczne.

Głównie pisze się w Javie, ale można też aplikacje natywne a i skryptowe. Poza tym jest to linux, więc z rootem można normalnie w C pisać. A i są jakieś Mono itp.

Wizja systemu Android. Że to na telefony. Co w tej Javie jest, dlaczego tak jest, czego nie ma (właśnie tych bibliotek). Dalvik. Co jest w C (bionic)? Nowa maszyna (\url{http://www.dobreprogramy.pl/Google-testuje-nastepce-Dalvika-z-ARTem-Android-bedzie-dwukrotnie-szybszy,News,49129.html}) wirtualna na Androida.
Jak działa Java? Maszyna wirtualna, baza w C, teoretycznie ten sam kod powinien działać wszędzie, należy jednak dobrze zaimplementować podstawę wszystkich bibliotek (czyli maszynę). A czasem są np. rozbieżności (drobne) pomiędzy windowsem a Linuxem.

Jak Androidowa Java współpracuje z innymi środowiskami.

\subsection{.NET}
Tu o .NETcie i o C\# (bo tego będę używał).
Jak .NET współpracuje z innymi środowiskami

\subsection{Python}
Nie platforma a język, ale w sumie chodzi na wszystkim. I na windowsie, linuxie i androidzie. Lubię też w nim pisać. Można go sportować.

Wzmianka, że podstawowa implementacja pythona, której będę używał (albo i nie) nie korzysta z wielu procesorów.

\subsection{Inne}
Cholera wie, może nawet Windows Phone by dało radę. Ogólnie wymienić to, na czym to moje mogło by chodzić. Jakieś Linuxy, Windowsy, Apple. Też osadzone rzeczy.

\section{Zdalne wywoływanie kodu}
Tu o RPC, o problemach, o tłumaczeniu danych, istniejących standardach itp.

Czym jest programowanie obiektowe napisać, co to polimorfizm i dlaczego ważny

\subsection{Tłumaczenie danych}
Jaka jest problematyka przetłumaczenia danych/obiektów z jednego języka, platformy na drugą?
Nawet na niskim poziomie mamy little/big endian. Potem dochodzi jeszcze niezgodność kodów bajtowych platform wirtualnych.
Nawet jak się zapisze w XML, JSONie czy czymś innym to możemy stosować inne formaty, czy coś. Bindingi.

problemy komunikacji w heterogenicznych środowiskach (inne formaty danych, inne dostępne klasy i zasady działania obiektów, np. Type erasure)

Zgodność zapisu bajtowego obiektów w .NETcie, Javie i Dalviku (może inna niż w normalnej Javie, może pomiędzy maszynami wirtualnymi też różna). Gdyby wszystko było zgodne to nie trzeba by się było tak męczyć z szukaniem standardu opisu danych. Też type erasure wchodzi w grę (zapis bajtowy dwóch list różnych typów sprawdzić)

\url{http://json-schema.org/}\\
\url{http://bsonspec.org/}\\
\url{http://json.codeplex.com/}\\

\emph{JAKAŚ KSIĄŻKA O TYM?}

\subsubsection{Serializacja}

\subsection{Transport danych}
Też bardzo szeroka dziedzina. Jak już się przetłumaczy, to zawsze trzeba jakoś przetransportować. Jak możemy przekazywać w ramach jednego kompa, jak pomiędzy kompami lokalnie, jak globalnie.
Celuję w globalnie, ale zwsze szerszą metodę można zastosować wężej (chociaż może nie być tak wydajna jak te węższe)

\emph{TEŻ PRZYDAŁBY SIĘ JAKIŚ ARTYKUŁ CHOCIAŻ}

\emph{TCP, PIPEy, SSL, HTTP, HTTPS, Webservicey, SOAP, REST, JSON}

\url{http://stackoverflow.com/questions/12450404/json-pojo-consumer-of-polymorphic-objects}

\subsection{RPC}
Ogólnie trochę o RPC. Że wiele technologii to RPC (Web service'y, CORBA), że to zawiera i tłumaczenie i transport.
Wywoływaniu kodu w innym procesie lub na innym kompie.

\url{http://www.infoq.com/articles/rest-soap-when-to-use-each}\\

\url{http://xmlrpc.scripting.com/default.html XML RPC}\\
\url{http://xmlrpc.scripting.com/spec.html}\\
\url{http://effbot.org/zone/xmlrpc-errata.htm}\\
Przejrzeć specyfikację, zobaczyć, z czym musieli sobie poradzić i wyczaić jak to wszystko mozna odwzorować w JSONie. Obczaić, jak sobie DataContractSerializer (też DataContractJsonSerializer) radzą. 

Service oriented architecture a remote procedure call? Jakie różnice? Czym będzie moje? A same web services?

\subsection{XML binding}
NA TYM BĘDZIE DZIAŁAŁO TŁUMACZENIE KLAS
W WSDL poza opisami operacji realizowanych przez usługę znajdują się też pliki XSD opisujące wszystkie struktury danych (klasy), które będą wymieniane. Dla tego posiadając WSDL usługi możemy wygenerować wszystkie klasy potrzebne do stworzenia klienta usługi.

Złożony problem pojawia się wtedy, kiedy servicy mają działać w obie strony wykorzystując te same klasy danych. W bardziej skomplikowanych systemach rozproszonych może się pojawiać taka sytuacja. Załóżmy istnienie dwóch aplikacji: A i B. Są one napisane w różnych językach. Każda z nich udostępnia usługę zwracającą obiekt danych X. A korzysta z usługi wystawianej przez B, a B korzysta z usługi wystawianej przez A. Mimo tego, że obiekt X w obu aplikacjach będzie zawierał te same dane, to jednak jego kod będzie inny. Dlatego nie można mówić o jednej klasie X, a o dwóch. Nazwijmy je XA i XB. TUTAJ DALEJ WYTŁUMACZENIE PRZYKŁADU AŻ W KOŃCU DOJDZIEMY DO TEGO, ŻE TRZEBA NAPISAĆ KLASĘ W JEDNYM JĘZYKU, POTEM ZROBIĆ JEJ BINDING DO XSD I Z XSD DO DRUGIEGO JĘZYKA.

Problem przesyłania typów polimorficznych (coś przeczytać, może). 

\subsection{Web service'y i SOAP}
W sumie to przykład tłumaczenia danych  i transpotru.

Jeden ze sposobów na zdalne wywoływanie kodu to usługi internetowe. Korzystając z otwartych standardów takich jak XML, SOAP, WSDL i UDDI umożliwiają integrację aplikacji poprzez Internet. XML jest używany do etykietowania danych, SOAP do ich pakowania i transferu (alternatywnie można używać też RESTa lub JSONa), WSDL opisuje interfejs usługi, a UDDI dostarcza spisu dostępnych usług (on nie leży w naszym obszarze zainteresowań). SOAP i WSDL są zapisywane przy pomocy XML. Web servicy używane są najczęściej do komunikacji aplikacji komercyjnych (np. serwery, portale) ze sobą lub z klientami. Pozwalają organizacjom na wymianę danych nie wymagając wiedzy o wewnętrznej strukturze informatycznej za firewallem.

W przeciwieństwie do tradycyjnych modeli przetwarzania typu klient – serwer, takich jak np. system stron internetowych, usługi internetowe nie mają graficznego interfejsu użytkownika. Służą one do dzielenia logiki biznesowej, danych i procesów poprzez sieć, przy pomocy jednolitego interfejsu programistycznego. To aplikacje się komunikują, nie użytkownicy. Programiści mogą, co prawda, dodać usługę internetową do aplikacji, która posiada GUI (np. aplikacja okienkowa lub strona internetowa) aby zaoferować zwykłym użytkownikom jej funkcjonalność.

Usługi internetowe pozwalają różnym aplikacjom wykonanych w różnych technologiach (np. całkowicie odmienne języki programowania) na porozumiewanie się ze sobą bez potrzeby czasochłonnego tworzenia kodu tłumaczącego. Nie ma też znaczenia to, czy obie aplikacje znajdują się na jednej maszynie, czy po drugiej stronie świata.
Usługi sieciowe na platformie .NET realizowane są w ramach WCF. Javie obecnym standardem jest JAX-WS.

co to webservicy i po co są?\\
do czego mogą się przydać na androidzie?\\
dlaczego ich nie ma? Chyba stwierdzili, że ogólne web servicey są za ciężkie i za bardzo obciążają (Windows phone też nie ma WCF)\\

Druga rzecz, którą chcę uzyskać to możliwość łatwego tworzenia programów współpracujących między wyżej wymienionymi platformami. Kiedy wywołujemy zdalny kod często trzeba przekazać mu jakieś parametry, często też chcemy otrzymać wartości zwrotne. Pomijając sam fakt transportu danych z jednej platformy na drugą stajemy przed problemem niezgodności typów danych. Wiemy, że na obu końcach będą użyte dwa różne języki, więc struktury danych nie będą kompatybilne. Trzeba temu zaradzić.
Ogólnie ujęte rozwiązanie dla powyższych problemów to serwer usług internetowych (ang. web services) wraz z narzędziami. Dzięki mechanizmowi usług sieciowych można wykonać dowolny kod na serwerze nie zależnie od technologii wykorzystywanych po obu stronach. Nie istnieje jeszcze (przynajmniej nie udało się znaleźć) serwer web service’ów dla Androida. Istnieją za to biblioteki pozwalające na przetłumaczenie klas z C\# na Javę.

\subsection{JSON, YAML, AXON}
\url{http://intellimath.bitbucket.org/blog/posts/axon_overcomes_json.html}\\
Jakieś porównanie AXONa i JSONa. Jeśli AXON jest stabilny i wspierany na Androidzie i .NETcie (bardzo ważne) to powinienem go użyć, bo przecież parę problemów rozwiązuje.

Oznaczanie typów.

\subsection{REST}
Cośtam o RESTcie \url{http://www.oracle.com/technetwork/articles/javase/index-137171.html}\\
REST and POX \url{http://msdn.microsoft.com/en-us/library/vstudio/aa395208(v=vs.90).aspx}\\

Restful web services vs ``big'' web services: \url{http://www2008.org/papers/pdf/p805-pautassoA.pdf}\\