\chapter{Podsumowanie (TODO)}
%Czy udało się zrealizować cele? Jeśli nie, to dlaczego? Co jeszcze można dodać? Czy to, co zrobiłem ma jakąś szansę na szersze zastosowanie?
Ważne, że pokazałem, że zasada działania jest słuszna. Konkretne narzędzia, których użyłem do zrobienia poszczególnych kawałków nie są ważne.

%O polimorfizmie typów zdalnych
Polimorfizm przekazywanych typów jest raczej bardziej sensowny, gdy wszystko zostaje w obrębie jednego języka, jeśli uruchamiamy na przekazanych parametrach metody. Inne zastosowania takiego systemu mogą być zastąpione, przez lepszy \emph{,,design''} funkcjonalności, który nie podejmuje decyzji na bazie typu. Ale może czasem się nie da. Ewentualnie klasy danych mogą mieć te metody, ale muszą być zaimplementowane po obu stronach. Ewentualnie tylko po jednej może być implementacja. Ale trzeba wtedy uważać i być świadomym różnic w zachowaniu typów. Kiedy zawierają one tylko dane nie ma takich problemów.

Ogólnie projekt jest za duży, żeby badać wszystkie aspekty serializacji. Maksymalnie zgodna serializacja mogłaby być osobnym tematem pracy magisterskiej ze względu na swój stopień skomplikowania.
Dodać to do działu wniosków.

Serializacja zawsze będzie problemem. Chyba, że albo będziemy projektowali klasy danych pod nią, albo cały język zostanie pod jej kątem zaprojektowany (jak Thrift).

Ograniczona współpraca JAvy i C\# jest możliwa, ale nigdy nie będzie pełnej swobody.

Nie było tłumaczenia klas ani systemu ich ładowania - to byłoby fajne w kompletnym sytemie, ale to nie kompletny system. I tak jest dobrze. Fajnie by było też mieć jakis sprytniejszy system na słownik - lepiej nazwaną od niego klasę a najlepiej ładowanie z pliku konfiguracyjnego.

Tym sposobem udało się uzyskać w~pełni sprawny serwer JSON-RPC mogący obługiwać metody polimorficzne, który dodatkowo posiada niespotykaną dotąd możliwość działania na Androidzie.
Ta możliwość może się okazać przydatna dla programistów chcących dać możliwośc zdalnego zarządzania systemem.

Opublikuję na blogu klienta i podlinkuje w znalezionych wątkach.

\section{Co się udało}
Ogólny cel pracy został spełniony -- jest wywoływanie kodu na Androidzie. A ze zdefiniowanych początkowych celów:
\begin{description}
\itemtitle{Przybliżenie tematyki}
Według mnie, jak najbardziej z powodzeniem. Przedstawiłem część świata RPC, serializacji i wymiany danych.

\itemtitle{Porównanie istniejącego oprogramowania}
Udane. Z jednej strony pokazałem niektóre z aktualnie najpopularniejszych rozwiązań w branży. Z drugiej -- technologie powiązane z RPC, które mają coś wspólnego z Androidem. Zbadałem polimorfizm webserviców. To i RPC związane z Androidem to nie bardzo popularne tematy.

\itemtitle{Stworzenie wieloplatformowej biblioteki}
Nie udało się, ale pokazałem, w jaki sposób można to zrealizować. Zadanie okazało się zbyt szerokie i ambitne. Ale moje założenia okazały się słuszne i można uzyskać sprawne oprogramowanie idąc drogą, którą szedłem. Co do poszczególnych jej aspektów
\begin{itemize}
  \item Wywoływanie kodu na Androidzie z~poziomu C\# -- udane
	\item Polimorfizm zdalnych metod -- pokazałem jak zrealizować i stworzyłem prototyp
	\item Swoboda rozszerzania kodu -- jak wyżej
	\item Prostota użycia -- pokazałem, że można ją zapewnić
	\item Wsparcie wielu środowisk -- nie zająłem się tym, ale serwer może działać wszędzie, gdzie jest Java.
\end{itemize}

\end{description}

I co to naprawdę potrafi? Tak obrazowo?



\section{Stworzona aplikacja}
Potrafi to i to.



\section{Co poza tym się udało}
\begin{itemize}
	\item Dodałem wieloinstancyjność do JSON-RPC.
	\item Schemat dynamicznego mapowania typów
\end{itemize}


\subsection{Tłumaczenie typów}
Tego się nie udało. Sharpen nie chciał działać, nic innego, co działało tak, jak chciałem nie znalazłem. Może warto by było jednak się przyjrzeć generacji typów na zasadzie generacji XML Schema z Javy, a następnie z niej klas C\#?



\section{Dalsza praca}
%Jakie tematy można dalej rozwinąć? Jakie zadania może podjąć ktoś inny w ramach magisterki lub inżynierki.
\begin{itemize}
	\item Przydałoby się wprowadzanie do standardów RPC takich jak JSON-RPC i XML-RPC jednolitego oznaczania typów. SOAP to ma, ale jest za ciężki i~ostatecznie niejednolity (pokazać na przykładzie WCF i~JAX-WS).
	\item Rozszerzenie Apache Thrift o możliwość generacji kodu pod Androida (może być tematem pracy magisterskiej lub inżynierskiej)
	\item Pełna implementacja komponentów, takich jak mapper typów i serializator pod .NET zgodny z Jacksonem. Mogłoby to być zrealizowane jako fork lub, co wymagałoby dużo więcej wysiłku, rozszerzenie konfigurowalności JSON.NET aby mógł serializować jak Jackson.
	\item Dodanie warstwy bezpieczeństwa.
	\item Same tajniki serializacji nadają się na pracę, bo to aktualny problem na ktory rzucają się np. Google Protocol Buffers, Apache Avro, Apache Thrift.
\end{itemize}


%Może jakieś wnioski, co można by zrobić, żeby powstało coś pięknego. Np. jakiś mapper z~istniejącego kodu Javowego do Thrifta?

%Ogólnie ciężko zrobić takie tłumaczenie języków, lepiej użyć rozwiązania przeznaczonego do bycia uniwersalnym, takiego jak Thrift.
%Ale doraźne rozwiązanie można uzyskać.
%Z mapowaniem typów słabo. Albo trzeba by coś zrobić, albo stosować od razu technologie typu Apache Thrift. Albo powoli przechodzić na nie, jeśli zakłada się rozbieżne środowiska.

%Jako dalsza praca lub temat czyjejś magisterki można by dodać do Thrifta możliwość kompilacji pod Androida.
\section{Wnioski}
Da się zrobić dynamiczny framework do RPC. Ale jeśli od razu jest założenie wspierania różnych platform i dynamiczność nie jest wymaganiem, to lepiej użyć technologii takiej jak Apache Thrift, która pewnie jeszcze się rozwinie.