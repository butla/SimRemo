\chapter{Projekt systemu (TODO)}
Tutaj będzie cały formalny projekt systemu, który wykonam.

Przy okazji napiszę też jakich licencji i technik (Test Driven, Spike) użyję.

Właściwie formalny projekt może się wiązać w wykonaniem prototypu, czyli Spike'a. 

Jak się decydowałem na licencję, narzędzia, repozytorium?

Na podstawie tego, co się dowiedziałem z porównania technologii wybiorę jakieś obiecujące ścieżki i zrobię SPIKEi. Potem wybiorę najlepsze rozwiązanie ze względu na moje oryginalne cele (opisane w~rozdziale~\ref{lib-requirements})
Jak w ogóle dojść do tego  co i jak zrobić, żeby dało nam to, co mamy w celach? Jak się odnaleźć w tym wszystkim?

Może przedstawić wizję, jak to powinno działać? Że wybieram sobie metodę, mogę przekazać polimorficzne parametry, wszystko działa. Takie przejście przez system.


\section{Wymagane składniki rozwiązania}
Musi być serializacja (po obu stronach taka sama), przesył, oznaczanie typów, logika kierowania żądań, wiedza o typach po obu stronach (albo dynamiczne typy lub przesyłanie ze schemą), i~czymś zarządzającym wieloinstancyjnością (bo chyba ją chcę, id w~JSON-RPC za to odpowiada).
Zrobić z~tego taki schemat przepływu (albo akcji, czy jak to się tam nazywało) przedstawiający wszystkie te główne etapy po kolei na dwóch maszynach, z transportem przez sieć.

Napisać, co jest potrzebne dla remotingu: jakaś tożsamość, adres obiektu, oznaczenia metod, argumentów. Ogólnie to jest dość proste.

Dobrze, żeby prototypy zawierały te wszystkie elementy, ale chociaż je mockowały.

Dobrze korzystać z~istniejących standardów. Wprowadzenie nowego standardu nie jest dobrą rzeczą, chyba, że ma się ogromną rzeszę zwolenników lub naprawdę poważne przesłanki (powody). Kto wie, może takie mam. Ale na ogół lepiej kombinować istniejące rozwiązania tak, żeby zewnętrzne komponenty miały szansę na współpracę z nimi.



\section{Prototypy (SPIKE)}
Co to SPIKE? Spike w~Extreme Programming, bodajże, ma za zadanie właśnie sprawdzić czy coś się da zrobić oraz jakie elementy będzie musiało zawierać rozwiązanie.
Spike nie musi być gotowym, działającym w pełni produktem. Ale pokazuje, czy sama zasada działania jest słuszna.

Ogólnie może zrobię ich kilka.

Tylko sprawdzając coś w~ten sposób mogę się przekonać, jaka droga jest dobra. Można myśleć, że przecież z~opisów bibliotek i~technologii można wywnioskować, do czego się nadają, ale w~praktyce tak nie jest. Jak się pisze konkretne rozwiązanie to czasem się okazuje, że akurat to nie działa.

Pomysły do SPIKEów będę wybierał na bazie doświadczenia (i~przesłanek opisanych poniżej w~\ref{approach-selection}).
Będę starał się wykorzystać jakieś badane wcześniej technologie. Bo lepiej używać gotowych, dojrzałych komponentów tam, gdzie można. Po co wymyślać koło od nowa?
Spike'i będę tworzył w~kolejności od tego, który według mnie ma największe prawdopodobieństwo na bycie prototypem ostatecznego rozwiązania.
Może się nawet udać za pierwszym razem, ale na wszelki wypadek powinienem zrobić kilka. Bo a~nóż się okaże, że mój drugi albo trzeci wybór będzie się zachowywał lepiej.

Założenia każdego prototypu (Spike'a) krótko na początku scharakteryzuję.

Jak oprę się o~Json-Rpc to będę miał system identyfikacji obiektów i~errory gratis.

Może kilka spikeów na kilka kawałków rozwiązania?

\subsection{Selekcja podejść}
\label{approach-selection}
Jakie podejścia, techniki odrzucam, na jakich się skupię, dlaczego?

\subsubsection{Dlaczego nie chcę pisać serializacji}
To dużo roboty i~zostało zrobione wiele razy. Jak już to bym wziął istniejący projekt, zrobił fork i~dodał wpisywanie i~odczytywanie informacji o~typach. Może nawet potem bym swoje zmiany dodał do oryginalnego projektu?

\subsubsection{Dlaczego nie Schemy i referencje we wiadomościach}
Chyba nie zależy mi na referencjach, jak linki do schem w SOAPie. System ma być prosty, wiadomości spójne i pełne. Odniesienia powodują dużo skomplikowanie, które jest zbędne - całe dane powinny być zawarte w wiadomości. A no i ja się nie bawię w schemy, nie przesyłam opisu danych (te są w klientcie i serwerze), przesyłam tylko surowe dane.

\subsubsection{Dlaczego nie REST}
Nie zależy mi konkretnie na łączności przez internet, a~to jest podstawowym założeniem RESTa.
Chcę wspierać wiele warst transportowych, nie tylko HTTP. Poza tym parsowanie adresów jest bardziej problematyczne niż proste pobieranie nazw metod.

Będę robił raczej RPC z~JSONem, nie będę udawał RESTa.
WADL nie jest w~ogólności zbyt potrzebny, bo REST może bez niego żyć.

\subsubsection{Dlaczego nie SOAP}
Nie uważam, że skomplikowanie SOAPa jest odpowiednie do RPC\@. Wystarczy zobaczyć, jak ciężko jest skomunikowac sie z serwisem w WCF przy pomocy kSOAP - ktos wlozyl w to duzo roboty, a i tak w minimalnie bardziej zaawansowanych (tablice?) przypadkach ciezko sprawic, zeby dzialalo. Tylko duze implementacje na duze platformy daja rade.

W generację WSDLa nie chcę się babrać - skomplikowane.

Namespace'y są ważną rzeczą w SOAPie. Ja twierdzę, że nie są potrzebne w tak rozbudowanej formie. Może być jedno standardowe nazewnictwo z kropkami. Zakładam taki jakby jeden globalny namespace na oba runtime'y (klient i serwer). Fakt, że nawet jedna strona może mieć kilka przestrzeni nazw (parę class loaderów albo assembly cache'y) ale nie chcę tego robić z uwagi n utrudnienia w integracji (tu można napisać jakby to mogło wyglądać, ale nie trzeba, mogę po prostu to olać).

\section{SPIKE nr.\ 1}



\section{Inne SPIKE'i}

\textbf{Serializacja JSONa (raczej samej serializacji nie chcę robić):}
Przejrzeć specyfikację, zobaczyć, z czym musieli sobie poradzić i wyczaić jak to wszystko mozna odwzorować w JSONie. Obczaić, jak sobie DataContractSerializer (też DataContractJsonSerializer) radzą.

\textbf{portowanie rozwiązań w C na Androida?}
Axis w~ C? Może częściowe używanie go spod javy. W sumie można sportować też jakieś inne rzeczy. Np.\ pythonowe web service'y (pyro, twisted). Może podpięcie pod gSOAP? Jakieś tłumaczenie JibXem sportowanych rzeczy?

Sprawdzić Python Remote Objects (Pyro) na pythonie 2, 3 (też na warstwie skryptowej Androida). Porównać z Twistedem, napisać o próbach portowania wymaganych bibliotek w C na Androida. \url{http://pythonhosted.org/Pyro4/intro.html#performance}

sl4a, py4a, kompilacja na ubuntu z użyciem NDK i Cythona
distutils.core zamienić na setuptools w setup.py

\textbf{Zcentralizowane pseudo web servicy (albo nawet i nie)}
Też potrzebny serializator / deserializator + bindingi. To był ten pomysł, że to komp pinga serwer (Androida), żeby ten sobie pobrał rozkaz i to Android woła web service na kompie. Trzeba by było używać Ksoap albo innego ścierwa. Zobaczyć, czy to w ogóle miałoby sens. Czy tymi Ksoapami da się coś sensownie zrobić.

\textbf{Własny serwer REST}
Tu dyskusja o implementacji serwera RESTowego na Androidzie \url{https://groups.google.com/forum/?fromgroups=#!topic/android-developers/vgkXg1P8iBg}





\section{Wybór rozwiazania}
\subsection{Wybrana ścieżka (prototyp)}
Który SPIKE (a~ztem którą ścieżkę) wybieram do dalszego rozwinięcia?
Dlaczego?

\subsection{Licencja}
Trzeba decydować o tym szybko (link dlaczego?).

Wybrałem MIT license (sam przeczytałem licencje, a porównanie tutaj http://choosealicense.com/licenses/). Jest przeciwnikiem skomplikowanych przepisów, na które Apache (główny konkurent) zakrawa, a na patentach mi nie zależy (wątpię, żebym jakieś tu miał, poza tym w UE nie można patentować kodu, chyba). MIT jest proste, zapewnia wzmiankowanie mojego nazwiska i umożliwia używanie mojego kodu także w komercyjnych rozwiązaniach.

Używa jej Ruby On Rails i pare innych dużych, znanych projektów.

\subsection{Repozytorium}
Musiałem to wybrać przed rozpoczęciem pisania tej pracy, bo chciałem ją tam przechowywać (backup). Sposób przechowywania źródeł to też ważna rzecz (link).

Nawet w przypadku samego dokumenty pomaga mi śledzić zmiany i rozwój oraz zapewnia kopię zapasową (a więc bezpieczeństwo).

Założyłem repozytorium na GitHubie, którego znam. Jest popularny i wygodny w użyciu. Kod ma być publiczny, więc nie mam problemu. 



\section{Specyfikacja wymagań systemowych}
Jakie dokładnie stawiam sobie cele po dokładnym przyjrzeniu się istniejącym rozwiązaniom?

Czy cele wyznaczone na początku pracy są niezmienione? Na ich podstawie stworzyć konkretnie wymagania na system.

Wymienić te wszystkie typy wymagań i wylistować.

% WYMAGANIA POMIJANE:
% reliable sessions (w sumie też by mi się przydał jakiś mechanizm, który umożliwi komunikację w niestabilnym środowisku Internetu)
% \url{http://blogs.msdn.com/b/shycohen/archive/2006/02/20/535717.aspx} \\



\section{Przypadki użycia}
Jakie są? Do czego można użyć tego systemu? Jak to jest z tym dynamicznym tworzeniem web serviceów z hierarchii klas?



\section{Struktura projektu}
Diagramy warstwowe, komponentowe, klas.

%Budowa powinna pozwolić na łatwe podłączenie warstwy bezpieczeństwa (bezpiecznego kanału)
%
%Call:
%- id obiektu (0 dla tworzenia nowego, wtedy argumentem jest tym)
%- id metody
%- parametry
%
%Response:
%- czy sie udalo
%- obiekt zwrotny, opis błędu przy wywołaniu zdalnej metody lub stacktrace z exceptiona, który wystąpił w metodzie
%
%Id metody:
%składa się z nazwy i aliasów jej parametrów.
%
%Alias:
%typy prymitywne - int, string, itp.
%datacontract - sraka:\#ptaka.daka
%lista - List
%tablica - [int, [[int, [sraka:\#ptaka.daka, itp.
%
%Tłumaczenie aliasów:
%C\# tłumaczy klasy na aliasy, jak przetłumaczy dla jednej metody to dodaje to do słownika, żeby potem robić to od razu.
%Java tłumaczy aliasy na nazwy klas (potem loaderem). Wiąże w słowniku id metody z obiektem metody. Może być metoda przyjmująca jakiś konkretny List, np. ArrayList, ale nie może mieć overloada przyjmującego inny List.
%Kiedy czyścić te słowniki?
%
%Loader:
%Loaduje aliasy DataContractów, klasy javowe, klasy serwisów(?). Czyta sobie jary, szuka adnotacji
%
%Typy danych i serwisy w javie są oznaczone namespaceami, odpowiadających im rzeczy z C\# (DataContracty i interfejsy)
%
%Oddzielić abstrakcje od sposobu transportu. Wyróżnic transport streamowany (serializator dostaje strumień i na niego wali output, możemy tłumaczyć i wysyłać na raz) i nie (trzeba stworzyć całą wiadomość, wtedy wysłać).
%
%Zrobić timeouty na łączenie do serwisu i na operacje. Poczytać więcej o TCP, zobaczyć, czy dobrze można nim sprawdzać, czy trzeba używać PINGa.
%
%Serializujemy wszystkie publiczne pola/ propertiesy albo metody z get / set (to w Javie). Używać jakiś dostępnych już atrybutów do ręcznej konfiguracji wyboru serializowanych elementów.

\section{Schemat działania projektu}
Schematy działania, to z liniami życia itp.

\section{Plan testów}
Jakie testy akceptacyjne? Jak sprawdzę (lub sprawdziłem), że działa? Na jakiej konfiguracji sprzętowej będę musiał to robić?

Tworzenie grafu w~typów w~xmlu? Są obiekty, które mogą mieć dzieci (tablice, listy). Próbuję wygenerować C\# dla porównania. Zapisuję grafy, które nie działają (w trakcie automatycznych testów). Zrobić wizualizator grafów.

Będę robił Test Driven Development. Daje zazwyczaj dobre programy i~skutkuje w~końcu szybszym wykonaniem projektu, bo nie ma przerw w~prcy związanych z jakimiś dziwnymi bugami.

Logowanie też trzeba dać.

