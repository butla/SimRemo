\chapter{Projekt systemu i elementy implementacji}
W~tym rozdziale zaprojektuję oprogramowanie realizujące cele opisane w~punkcie~\ref{lib-requirements}.
Zaproponuję sposób realizacji, możliwości i~ograniczenia poszczególnych jego elementów. Dla części komponentów stworzę prototypy.

\section{Specyfikacja wymagań systemowych (SWS)}
Z~celów tej pracy zawartych w~punkcie~\ref{lib-requirements} stworzyłem standardową listę konkretnych wymagań dla zespołu inżynierów, czyli mnie samego.
Organizując niniejszą sekcję wzorowałem się na specyfikacji wymagań systemowych opisanej w~prezentacji ,,Inżynieria Wymagań'' Jarosława Kuchty, z~przedmiotu ,,Dokumentacja i~Jakość Oprogramowania''\cite{kuchta}.


\subsection{Wstęp i~opis informacyjny}
Jako rozbudowana sekcja wstępu SWS oraz ,,szczegółowy opis problemów do rozwiązania'' służyły poprzednie rozdziały niniejszej pracy.


\subsubsection{Diagram przepływu najwyższego poziomu}
Diagram~\ref{fig:project-overview} przedstawia ogólne działanie systemu w~trakcie wywoływania zdalnej metody. Jest to główna funkcja mojego projektu. Funkcja drugorzędna -- tłumaczenie danych, również została ujęta.


Widoczny na schemacie klient jest jednym z~wielu, które mogą być stworzone przez kod korzystający z~mojej biblioteki.
Obiekt każdego klienta spełnia jakiś zadany interfejs. Robi to przez opakowywanie parametrów, zaadresowanie ich, wysłanie do obiektu faktycznie wykonującego kod i~odebranie wyniku.
Interfejs klienta i obiektu zdalnego są zgodne, chodź napisane w~różnych językach na różne platformy. Aby zminimalizować nakład pracy programisty, najlepiej byłoby, gdyby interfejs po stronie klienta (.NET) był generowany z~wersji serwerowej (Java, Android).
Tak samo jak w~przypadku interfejsów wygląda sprawa klas przekazywanych do metod jako parametry -- także muszą być zgodne, najlepiej automatycznie tłumaczone.
Typy przetłumaczone na schemacie oznaczone są apostrofem.
Kod kliencki nie musi zawierać tłumaczenia implementacji zdalnych interfejsów.
Współdzielone definicje klas danych i~interfejsów są niezbędne, aby uzyskać polimorfizm metod zdalnych.

Serwer jest tworzony przez kod kliencki i~nasłuchuje na żądania na zadanym interfejsie sieciowym. Może to być dowolna technologia pozwalająca na dwustronne wysyłanie wiadomości, np.\ TCP, HTTP, SSL/TLS, czy też strumienie w~pamięci (rozwiązanie lokalne).
Na schemacie serwer posiada tylko jeden obiekt zdalny klasy \texttt{Implementacja A}, ale faktycznie może posiadać ich wiele.

\begin{figure}
	\centering
		\includegraphics[scale=0.8]{img/schematy/schemat-dzialania-magisterki.pdf}
	\caption{Ogólny schemat projektu.}
	\label{fig:project-overview}
\end{figure}


\subsubsection{Reprezentacja zawartości informacyjnej}
Nie można właściwie mówić o~zawartości informacyjnej systemu, ponieważ takiej nie będzie.
Przez mój system dane będą jedynie przepływać.


\subsubsection{Opis interfejsów systemowych}
\begin{itemize}
	\item Jako, że to, co tworzę będzie kolekcją bibliotek Javy i~C\# będą one mogły być ładowane, a~ich klasy wykorzystywane przez zewnętrzne aplikacje.
	\item Niezależne narzędzie do generacji kodu będzie opatrzone w~interfejs linii poleceń.
\end{itemize}


\subsection{Wymagania funkcjonalne}
% WYMAGANIA POMIJANE:
% reliable sessions (w sumie też by mi się przydał jakiś mechanizm, który umożliwi komunikację w niestabilnym środowisku Internetu)
% \url{http://blogs.msdn.com/b/shycohen/archive/2006/02/20/535717.aspx} \\

\subsubsection{Ogólne}

\begin{description}
\itemtitle{Serializacja danych z zachowaniem informacji o typach}
Zserializowane reprezentacje obiektów muszą zawierać informacje o~typach wtedy, kiedy nie wynika ona jednoznacznie z~kontekstu.
Np.\ przy zwracaniu ze zdalnej metody obiektu klasy dziedziczącej po tym, zdeklarowanym w~interfejsie tejże metody.
To wymaganie dotyczy zarówno strony klienta jak i~serwera.
Deserializacja powinna być komplementarna i~ze stworzonych reprezentacji odtwarzać obiekty o~odpowiednich typach i~z~poprawnymi danymi.
Taka metoda serializacji i~deserializacji jest warunkiem działania polimorficznych metod.

\itemtitle{Tłumaczenie kodu}
Zrealizowane jako niezależne narzędzie.
Tłumaczenie kodu zmniejszyłoby nakład pracy programisty, który bez tego musiałby sam stworzyć odpowiadające klasy danych w~obu językach.
Klasy i~pola nie znajdujące odpowiednika są pomijane w~trakcie tłumaczenia.
Tłumaczenie powinno się odbywać z~Javy do C\#, ponieważ w~Javie będzie więcej kodu (kod implementacji zdalnych metod).
%Jeśli w danej klasie są inne klasy z zewnętrznej biblioteki, to trzeba też przetłumaczyć te. Trzeba dostarczyć kod wszystkich.
%Jeśli jedno ogniwo jest nieprzetłumaczalne to można pominąć pole z ostrzeżeniem.
\end{description}

\subsubsection{Serwer}

\begin{description}

\itemtitle{Komunikacja z~klientem}
Serwer powinien nasłuchiwać na żądania od klientów na zadanym dwustronnym kanale komunikacyjnym.
Konkretny typ kanału (TCP, SSL, HTTP, itp.) nie jest ważny.
Może przyjmować wywołania metod i~przekierowywać je do obiektów zdalnych (względem klienta).
Przekazuje do klientów zwracane wartości.

\itemtitle{Wystawianie metod publicznych zadanych obiektów ,,na zewnątrz''}
Kod serwera ma przyjmować dowolny obiekt i~umożliwiać zdalnym klientom wywoływanie jego publicznych metod.
Parametry tych metod muszą być przetłumaczalne na kod klienta.

% Można się też zastanowić nad singletonami.
\itemtitle{Tworzenie zdalnych obiektów na życzenie klienta}
Po otrzymaniu specjalnego żądania kod serwera powinien stworzyć obiekt implementujący zadany interfejs i~zwrócić jego identyfikator. Klient będzie mógł wywoływać zdalnie metody na stworzonym obiekcie.

\itemtitle{Niszczenie zdalnych obiektów na życzenie klienta}
Specjalne żądanie zawierające identyfikator obiektu powinno powodować jego zwolnienie i~uniemożliwienie z~nim dalszej komunikacji.

\itemtitle{Polimorfizm parametrów metod zdalnych}
Metody zdalne muszą obsługiwać parametry wszystkich typów zgodnych ze spodziewanym. Dla przykładu, metoda przyjmuje parametr typu A, więc powinna przyjąć też parametry wszystkich typów dziedziczących po A.

\itemtitle{Przeciążanie metod zdalnych}
Metody zdalne mogą być przeciążane, tj.\ dwie metody mogą mieć tę samą nazwę, ale inny zestaw parametrów.

\itemtitle{Komunikacja z systemem Android}
Obiekty zdalne muszą mieć możliwość wywoływania metod z~API Androida.

\end{description}

\subsubsection{Klient}

\begin{description}

\itemtitle{Tworzenie obiektów klienckich}
Biblioteka po stronie .NET musi być w~stanie dynamicznie stworzyć obiekt klienta dla obiektu zdalnego.
Każdy klient spełnia jakiś zadany interfejs.

\itemtitle{Nawiązywanie sesji z~serwerem}
Obiekt klienta nawiązuje kontakt z~serwerem poprzez dowolny dwustronny kanał komunikacyjny (na którym serwer nasłuchuje).
Następnie żąda od serwera stworzenia dla siebie zdalnego obiektu.
Wszystkie metody z~interfejsu zdalnego wywoływane na kliencie są przekazywane do jednego obiektu zdalnego.
Zwolnienie obiektu klienta powoduje zwolnienie obiektu zdalnego.

\itemtitle{Konsumowanie polimorficznych metod zdalnych}
Klient wykonuje metody implementowanego przez siebie interfejsu przez delegację (i~wysłanie) ich do obiektu zdalnego.
Wysłanie poprzedzane jest serializacją, podczas której muszą zostać zachowane informacje o~typach parametrów oraz ich ewentualnych obiektach składowych.

\end{description}


\subsection{Wymagania niefunkcjonalne}

\begin{description}

\itemtitle{Serwer na Androidzie}
Kod serwera musi działać na platformie Android.

\itemtitle{Klient w~.NET pod Windows}
Kod klienta musi działać na platformie .NET\@.

\itemtitle{Wydajność serwera}
Nie musi być duża, jako, że nie jest priorytetem projektu. Wystarczy jednoczesna obsługa pięciu (5) klientów.

\itemtitle{Rozszerzalność metod zdalnych bez ingerencji w oryginalny kod}
Funkcjonalność metod zdalnych powinna być rozszerzalna bez ingerencji w~ich kod dzięki mechanizmom programowania obiektowego.
Przykładem jest możliwość przyjmowania przez metodę zdalną obiektu klasy dziedziczącej po spodziewanym typie parametru, bez potrzeby jakiejkolwiek ingerencji w~kod metody, aby mogła rozumieć nową klasę.
Jednak definicja nowej klasy musi być dostępna zarówno dla klienta, jak i~serwera.

\itemtitle{Łatwość użytkowania}
Budowanie i~korzystanie z~bibliotek, które powstaną w~trakcie realizacji tego projektu, powinno być proste i~intuicyjne.

\end{description}



\section{Używana konfiguracja sprzętowa i~narzędzia}
\label{system-configuration}
Przed przystąpieniem do omawiania komponentów rozwiązania warto wspomnieć o~tym, na jakiej konfiguracji sprzętowej oraz przy pomocy jakich narzędzi były wytwarzane kod i~tekst niniejszej pracy. Na tej samej konfiguracji wykonywane były testy \emph{frameworków} w~rozdziale~\ref{similar-technologies}.

\begin{description}
\itemtitle{System operacyjny}
Windows 7 Professional x64. Cały kod i~tekst pracy powstał na tej maszynie. Na niej był też osadzony emulator Androida.

\itemtitle{Emulator Androida}
Ściągnięty razem z~IDE Eclipse zmodyfikowanym do pracy z~Androidem\footnote{Do ściągnięcia ze strony \url{http://developer.android.com/sdk/index.html}}.
Jest to standardowy emulator od Google\footnote{Alternatywnym emulatorem jest Genymotion (\url{http://www.genymotion.com/}), polecany na stronach Xamarina.}.
Emulowany był Android 4.4.2 (poziom API Androida w~tej wersji to 19). Reszta konfiguracji emulowanego urządzenia: typ obrazu~-- \emph{ARM EABI v7a}, urządzenie~-- Nexus S, RAM~-- 512MB, \emph{VM Heap}~-- 32MB, wewnętrzna pamięć~-- 200MB, karta SD~-- 50MB, zaznaczona opcja użycia GPU hosta.
%Używam ARMowego, bo więcej telefonów jest właśnie na nim. Zdażają się też drobne rozbieżności działania niektórych niskopoziomowych aplikacji względem obrazu na architekturę x86 (\emph{Intel x86 Atom}).

\itemtitle{Eclipse 4.2.1 z~wtyczką ADT}
Przy jego użyciu stworzona jest przykładowa aplikacja serwerowa, a~także inne aplikacje powstające w~trakcie testów \emph{frameworków} (rozdział~\ref{similar-technologies}). ADT -- \emph{Android Development Tools}, to wtyczka umożliwiająca tworzenie kodu na Androida.

\itemtitle{NetBeans 7.4}
Kod Javy niewymagający Androida do działania powstawał w~nim.

\itemtitle{Visual Studio 2013 Ultimate}
Pod nim powstawał cały kod C\#.

\itemtitle{Tortoise GIT}
GIT jest systemem kontroli wersji w~którym trzymany jest kod oraz tekst tej pracy. Wykorzystywany przeze mnie klient to TortoiseGit\footnote{\url{https://code.google.com/p/tortoisegit/}}. Repozytorium znajduje się pod adresem \url{https://github.com/butla/SimRemo}.

\itemtitle{\LaTeX}
Tekst pracy pisany jest przy pomocy technologii \LaTeX. Jako edytor wykorzystywany jest program TeXnicCenter\footnote{\url{http://www.texniccenter.org/}}.
\end{description}

%Do testów wymagane jest przekierowanie portu TCP hosta do portu TCP emulatora. Do tego należy użyć komendy:
%\begin{lstlisting}[language=bash]
%adb forward tcp:1666 tcp:1666
%\end{lstlisting}
%Adb to komenda z narzędzi instalowanych z Eclipsem.



\section{Częściowa implementacja}
Tutaj przedstawię zaimplementowaną część zaplanowanego projektu. Całość okazała się zbyt obszerna na jedną pracę dyplomową. W~dalszej części rozdziału dokładniej przedstawię poszczególne elementy systemu (zarówno te zaimplementowane jak i~nie) oraz wyzwania z~nimi związane. Uzasadnię też metody ich implementacji.

\subsection{Spełnienie wymagań systemowych}
Spełnienie zdefiniowanych wymagań systemowych przez stworzoną implementację zostało przedstawione w~tabeli~\ref{tab:requirements-fulfilment}.

\begin{table}[htbp]
	\centering
		\begin{tabular}{ | c | c | c | c | }
			\hline
				\textbf{Nazwa wymagania} & \textbf{Typ wymagania} & \textbf{Obszar} & \textbf{Wykonanie}\\
				\hline \hline
				Serializacja danych z zachowaniem informacji o typach & Funkcjonalne & Ogólne & +\textasciitilde\\
				\hline
				Tłumaczenie kodu & Funkcjonalne & Ogólne & +\\
				\hline
				
				Komunikacja z~klientem & Funkcjonalne & Serwer & +\\
				\hline
				Wystawianie metod publicznych zadanych obiektów ,,na zewnątrz'' & Funkcjonalne & Serwer & + \\
				\hline
				Tworzenie zdalnych obiektów na życzenie klienta & Funkcjonalne & Serwer & -- \\
				\hline
				Niszczenie zdalnych obiektów na życzenie klienta & Funkcjonalne & Serwer & -- \\
				\hline
				Polimorfizm parametrów metod zdalnych & Funkcjonalne & Serwer & + \\
				\hline
				Przeciążanie metod zdalnych & Funkcjonalne & Serwer & + \\
				\hline
				Komunikacja z systemem Android & Funkcjonalne & Serwer & + \\
				\hline
				
				Tworzenie obiektów klienckich & Funkcjonalne & Klient & +\textasciitilde \\
				\hline
				Nawiązywanie sesji z serwerem & Funkcjonalne & Klient & -- \\
				\hline
				Konsumowanie polimorficznych metod zdalnych & Funkcjonalne & Klient & + \\
				\hline
				
				Łatwość użytkowania & Niefunkcjonalne & Ogólne & +\textasciitilde \\
				\hline
				Serwer na Androidzie & Niefunkcjonalne & Serwer & + \\
				\hline
				Rozszerzalność metod zdalnych bez ingerencji w oryginalny kod & Niefunkcjonalne & Serwer & + \\
				\hline
				Wydajność serwera & Niefunkcjonalne & Serwer & + \\
				\hline
				Klient w .NET pod Windows & Niefunkcjonalne & Klient & + \\
				\hline
		\end{tabular}
	\caption[Spełnienie wymagań systemowych.]{Spełnienie wymagań systemowych. ,,+'' oznacza, że wymaganie jest spełnione; ,,+\textasciitilde'', że zostało spełnione ale wymaga komentarza; ,,--'' że nie zostało spełnione.}
	\label{tab:requirements-fulfilment}
\end{table}

Komentarz do niespełnionych wymagań:
\begin{description}
\itemtitle{Tworzenie zdalnych obiektów na życzenie klienta}
Mechanizm w~ogóle nie zaimplementowany. Zdalne obiekty (serwisy) działają jako singletony; każdy obiekt musi być stworzony przez serwer i~powiązany z~unikatowym adresem. Wszystkie żądania wysłane na jeden adres są obsługiwane przez jedną instancję serwisu.

\itemtitle{Niszczenie zdalnych obiektów na życzenie klienta}
Ponieważ nie zostało zaimplementowane tworzenie obiektów na życzenie nie ma sensu implementować usuwania.

\itemtitle{Nawiązywanie sesji z serwerem}
Sesje miały być nawiązywane na zasadzie przyznawania każdemu klientowi osobnej instancji serwisu. Ponieważ klient nie może stworzyć obiektu zdalnego na serwerze to sesje nie mogą być zaimplementowane.
\end{description}

Są jeszcze wymagania zaimplementowane, które jednak wymagają komentarza:
\begin{description}
\itemtitle{Serializacja danych z zachowaniem informacji o typach}
Nie ma wsparcia dla oznaczania typów kolekcji: tablic, list, słowników itp.
\itemtitle{Tworzenie obiektów klienckich}
Kiedy zdalna metoda rzuci wyjątek to pewien wyjątek jest rzucany przez metodę obiektu klienckiego. Nie jest to jednak przetłumaczony obiekt wyjątku rzuconego po stronie serwera, a~wyjątek typu \texttt{JsonRpcException} zawierający tekstowy zapis tego oryginalnego.s

\itemtitle{Łatwość użytkowania}
Ustawianie słownika typów mogłoby się odbywać za pośrednictwem pliku konfiguracyjnego. Aktualnie odbywa się w~kodzie, przy pomocy wywołania statycznej metody, która może być trudna do znalezienia, jeśli się nie wie gdzie szukać.
\end{description}


\subsection{Zasady działania}
Możliwości zaimplementowanego systemu to:
\begin{itemize}
	\item serwowanie publicznych metod wybranych obiektów zdalnie, z~Androida;
	\item dynamiczne tworzenie obiektów klienckich z~poziomu .NET; obiekty implementują zadany (zdalny) interfejs;
	\item polimorfizm parametrów metod zdalnych, ale tylko jeśli są pojedynczymi obiektami, a~nie kolekcjami;
	\item przeładowywanie metod zdalnych.
\end{itemize}

W~ogólności system pozwala na wystawienie publicznych metod zwykłego javowego obiektu ,,na zewnątrz'' systemu Androida.
Taki wystawiany obiekt zwany jest od teraz obiektem zdalnym.
Program na Androidzie wystawiający obiekty zdalne działa jako serwer, konkretnie serwer JSON-RPC -- standardu zdalnego wywoływania metod opartego o~JSON, opisanego w~punkcie~\ref{json-rpc}.

System zawiera też klienta JSON-RPC pod .NET. Przy jego pomocy można dynamicznie, wywołaniem jednej metody, stworzyć obiekt spełniający zadany interfejs będący klientem obiektu zdalnego.
Dla przykładu: kod na Androida zawiera interfejs \texttt{TestService} i~klasę \texttt{TestServiceImpl} go implementującą, obie stworzone przez hipotetycznego użytkownika mojego systemu, a~nie będące jego częścią.
Po stronie .NET musi znajdować się interfejs lustrzany dla \texttt{TestService} z~Javy (Androida), czyli posiadający tak samo nazwane metody z~analogicznymi parametrami.
Na bazie tego interfejsu tworzony jest obiekt kliencki dla obiektu zdalnego. Można na nim wykonywać metody interfejsu \texttt{TestService} tak jak na zwykłym lokalnym obiekcie -- zwracane wartości będą normalnymi obiektami.

Struktura tego, co zostało zaimplementowane przedstawiona jest na schemacie~\ref{fig:implementation-overview}.
Dokładniejsza struktura przygotowanej biblioteki .NET przedstawiona jest na diagramie~\ref{fig:dot-net-classes}.
Przygotowana przeze mnie część Androidowa to jedna klasa -- JsonRpcBasicServer -- dodana do jsonrpc4j\footnote{jsonrpc4j opisane w~punkcie~\ref{jsonrpc4j}.}. Więcej o~tym w~punkcie~\ref{android-rpc}.
Natomiast schemat działania zaimplementowanego systemu można zobaczyć na diagramie sekwencji~\ref{fig:sequence-diagram}.
Ostatni diagram zawiera cztery sekwencje: A, B, C i D.
\begin{figure}
	\centering
		\includegraphics[width=\textwidth]{img/schematy/schemat-implementacji.pdf}
	\caption{Struktura częściowej implementacji projektu.}
	\label{fig:implementation-overview}
\end{figure}

\begin{figure}
	\centering
		\includegraphics[width=\textwidth]{img/schematy/schemat-klas-net.pdf}
	\caption{Klasy klienta JSON-RPC pod .NET.}
	\label{fig:dot-net-classes}
\end{figure}

\begin{figure}
	\centering
		\includegraphics[angle=90,origin=c,scale=0.8]{img/schematy/diagram-sekwencji.pdf}
	\caption[Diagram sekwencji systemu.]{Diagram sekwencji systemu. Są 4 niezależne scenariusze: A, B, C i D. D musi wystąpić po 3 poprzednich.}
	\label{fig:sequence-diagram}
\end{figure}

Sekwencja A to stworzenie obiektu zdalnego. Wyjaśnienie jej kroków:
\begin{itemize}
	\item Kod serwerowy tworzy instancję wybranej klasy, na diagramie jest to \texttt{TestServiceImpl}.
	\item Kod serwerowy wystawia publiczne metody stworzonej instancji \texttt{TestServiceImpl} ,,na zewnątrz'' przy użyciu API jsonrpc4j.
	\item jsonrpc4j tworzy obiekt opakowujący instancję \texttt{TestServiceImpl}; ten obiekt będzie odpowiedzialny za~wołanie metod instancji \texttt{TestServiceImpl} w~odpowiedzi na otrzymywanie wiadomości od klientów JSON-RPC.
\end{itemize}

Sekwencja B -- stworzenie obiektu klienckiego. Faktycznie niezależna od sekwencji A, ponieważ obiekt zdalny musi istnieć dopiero przy pierwszym wywołaniu metody, nie przy stworzeniu obiektu klienckiego. Kroki:
\begin{itemize}
	\item Kod kliencki tworzy instancję obiektu klienckiego (proxy) dla obiektu zdalnego.
	\item Statyczna metoda \texttt{JsonRpcClientProxy} tworzy instancję swojej klasy. Instancja tworzona jest na bazie zadanego interfejsu (np. \texttt{TestService}) i~jest wiązany z~adresem konkretnego obiektu zdalnego.
\end{itemize}

Sekwencja C -- wypełnienie słownika typów. Potrzebne jeśli użytkownik zamierza korzystać z~polimorfizmu parametrów metod zdalnych. Polega na uruchomieniu jednej metody statycznej zmodyfikowanego przeze mnie JSON.NET\footnote{Biblioteka serializacyjna pod .NET; format danych to JSON.}. Wypełniony słownik będzie wykorzystywany do mapowania typów pomiędzy Javą a~.NET przy serializacji i~deserializacji.

Sekwencja D -- wywołanie polimorficznej metody zdalnej, czyli zasadnicza funkcjonalność systemu:
\begin{itemize}
	\item Kod kliencki wywołuję metodę .NETowej wersji interfejsu \texttt{TestService} na instancji \texttt{JsonRpcClientProxy}.
	\item \texttt{JsonRpcClientProxy} przygotowuje wiadomość dla serwera JSON-RPC i~zawiera w~niej przekazane argumenty metody zdalnej.
	\item Wiadomość jest przekazana do serializacji do zmodyfikowanego JSON.NET.
	\item Jeśli zachodzi taka potrzeba, JSON.NET pyta \texttt{JavaTypeDictionary} o~nazwy typów w~Javie, które odpowiadają typom parametrów przekazanych do \texttt{JsonRpcClientProxy}.
	\item \texttt{JsonRpcClientProxy} wysyła zserializawoną wiadomość do serwera JSON-RPC opakowującego instancję obiektu zdalnego.
	\item Po odebraniu wiadomości zakodowanej w~JSON, opakowanie obiektu zdalnego przekazuje ją do deserializacji do Jacksona.
	\item Opakowanie obiektu zdalnego przekazuje zdeserializowane parametry do odpowiedniej metody obiektu zdalnego. On wykonuje te metodę lokalnie i~zwraca otrzymaną wartość do obiektu opakowującego.
	\item Obiekt opakowujący przygotowuje zwrotną wiadomość JSON-RPC umieszczając w~niej obiekt zwrócony z~metody zdalnej. Następnie wiadomość jest serializowana przy użyciu Jacksona.
	\item Zserializowana wiadomość jest zwrócona do \texttt{JsonRpcClientProxy}.
	\item \texttt{JsonRpcClientProxy} przekazuje wiadomość do wewnętrznego obiektu \texttt{ResultDeserializer}. \texttt{ResultDeserializer} rozpoznaje, czy zwrócona wartość to wynik metody czy wyjątek.
	\item \texttt{ResultDeserializer} deserializuje zwróconą wartość wyciągniętą z~wiadomości przy użyciu JSON.NET.
	\item JSON.NET prosi \texttt{JavaTypeDictionary} o~przetłumaczenie nazw typów Javy na odpowiadające nazwy w~.NET.
	\item \texttt{JsonRpcClientProxy} przekazuje do kodu klienckiego przetłumaczony obiekt otrzymany z~metody zdalnej.
\end{itemize}



%Co to? Jakie wymagania spełnia? Co by wchodziło w tego skład lub ogólny sposob realizacji? Realizacja prototypu. Ograniczenia?
\section{Wspólny format informacji o typach}

\subsection{Wprowadzenie(TODO)}
Obie części systemu -- klient (.NET) i~serwer (Android) -- muszą mieć wspólny system oznaczania typów aby wymieniane obiekty mogły być polimorficzne. 
Wspólny format oznaczeń nie jest potrzebny, kiedy nie zależy nam na polimorfizmie, czyli w~większości przypadków wykorzystania zdalnego wywoływania metod (kodu).

Zanim przejdę do przykładów wprowadźmy trochę pseudokodu bazowanego na Javie. Będzie to interfejs obiektu zdalnego, klasa go implementująca oraz klasa danych używana wykorzystywana w~interfejsie; wszystkie znajdujące się w~jednej przestrzeni nazw (\emph{package}). Kod ten znajduje się we fragmencie~\ref{kod:example-remote-classes}.

\begin{lstlisting}[float, frame=single, caption={Przykładowy kod metody zdalnej.}, label=kod:example-remote-classes]
package org.example.test;

public class DataA
{
    public int number;
    public string text;
}

public interface TestService
{        
    DataA modifyData(DataA data);
        
    void nothing();
}

public class TestServiceImpl
{
    DataA modifyData(DataA data)
    {
        data.number += 1;
        data.text += " something added";
        return data;
    }
    
    void nothing()
    {
        System.out.println("Just doing nothing...");
    }
}
\end{lstlisting}

Załóżmy, że będziemy wywołać metody przy pomocy JSON-RPC. Klasyczne JSON-RPC nie koduje w~żaden sposób informacji o typach. Można by z~.NET przekazać zakodowaną wiadomość, wyglądającą mniej więcej tak:
\begin{lstlisting}[frame=single]
{
    "obiekt": "TestServiceImpl1",
    "metoda": "modifyData",
    "parametry": [
        {
            "number": 13,
            "text": "przykladowy tekst"
        }
    ]
}
\end{lstlisting}
i Java potrafiłaby ją rozkodować. To dlatego, że w~wybranym obiekcie (o~identyfikatorze \texttt{TestServiceImpl1}) istnieje metoda o~nazwie \texttt{modifyData}. Co więcej, przyjmowany przez nią parametr ma dwa obiekty składowe: \texttt{number} i \texttt{text} -- tak samo jak obiekt \texttt{DataA}; dlatego parametr z~JSONa może być zinterpretowany jako \texttt{DataA}\footnote{Zgodnie z~zasadą \emph{Duck Typing}}.

(TODO) \\
Gdybyśmy posługiwali się SOAPem to by nie było tak prosto, bo musiały by być bindingi do XMLa. Właściwie SOAP we wszystkim musi mieć oznaczony typ. Dlatego, dla prostoty, przez którą nic wartościowego dla tego systemu nie tracimy zdecydowałem się na JSON-RPC. Innym kandydatem był XML-RPC, ale JSON jest lżejszy niż XML.

Póki co, kodowanie informacji o~typach nie jest do niczego potrzebne. Wprowadźmy teraz nową klasę, która dziedzieczy po \texttt{DataA}:
\begin{lstlisting}[frame=single]
package org.example.test;

public class DataB extends DataA
{
    public double floatNumber;
}
\end{lstlisting}
Zakładamy też, że po stronie .NET znajduje się odpowiednik zarówno \texttt{DataA}, jak i~dziedziczącej po nim \texttt{DataB}. Także relacja dziedziczenia jest zachowana pomiędzy odpowiednikami. Nazwijmy te odpowiedniki \texttt{DataA'} i~\texttt{DataB'}.

Powiedzmy, że teraz klient chce wywołać metodę \texttt{modifyData} przekazując jako parametr \texttt{DataB'}, a~nie \texttt{DataA'} (które było interpretowane przez serwer jako \texttt{DataA}), jak poprzednim razem.
W~programowaniu obiektowym nie jest to nic dziwnego -- polimorfizm powinien zapewniać to, że obiekt dziedziczący może być zinterpretowany jako bazowy.
Wynikająca z~takiego wywołania wiadomość może wyglądać następująco:
\begin{lstlisting}[frame=single]
{
    "obiekt": "TestServiceImpl1",
    "metoda": "modifyData",
    "parametry": [
        {
            "number": 13,
            "text": "przykladowy tekst",
						"floatNumber": 5.25
        }
    ]
}
\end{lstlisting}

Wiadomość ta różni się od poprzedniej tylko polem \texttt{floatNumber}. W~tej sytuacji serwer może się zachować dwojako, w~zależności od konfiguracji.
Może stwierdzić, że nie ma metody \texttt{modifyData} przyjmującej jeden parametr, który posiada trzy pola: \texttt{number}, \texttt{text} i~\texttt{floatNumber}. W~tej sytuacji nie zostanie wywołana żadna metoda zdalna, a~serwer powinien zwrócić klientowi wyjątek.
Drugim wyjściem jest pominięcie nierozpoznanego przez serwer \texttt{floatNumber} i~zinterpretowanie reszty pól jako obiektu \texttt{DataA}.
Metoda wykona się poprawnie, ale może być to działanie niepożądane przez programistę. Przekazując metodzie instancję \texttt{DataB'} mógł chcieć, żeby obiekt zdalny użył faktycznie jej\footnote{Nie jest, oczywiście, możliwe użycie tej samej instancji obiektu, którą przekazał klient. Chodzi o~dokładną kopię.}. Gdyby działanie metody zależało od typu jej parametru, np. kiedy dokonywana jest inspekcja parametru przy użyciu refleksji, to metoda nie zadziałałaby tak, jak oczekiwał tego programista.

Oczywiste jest, że polimorfizm byłby przydatny, gdyby na przyjmowanym parametrze była wywoływana jakaś metoda. Jest to standardowy sposób rozszerzania działania kodu bez jego przepisywania w~programowaniu obiektowym.
ALE Klasy danych mogą także mieć metody, ale raczej unika się takich rozwiązań. Ponieważ sami musimy napisać odpowiadające sobie klasy trzeba by było też je dopisać. Ale możnaby też jakieś zupełnie inne. Na pewno metody napisane w~jednym kodzie nie będą mogły być wywołane po drugiej stronie.  
DAJ PRZYKŁAD, KIEDY JEST TO POTRZEBNE A NIE CHCEMY KORZYSTAĆ Z METOD.


Aby sytuacja była jasna typy muszą być oznaczane. Do tego, oznaczanie typów musi być jednolite. Musi być słownik itp. Wtedy wiadomość wyglądałaby tak, bo klient by sobie przetłumaczył typy (zakładamy, że robi to klient). Serwer by sobie odebrał i byłoby git.

Wnioskowanie o przeładowywaniu metod też działa.

Można wywołać zarówno nothing, jak i metodę przeładowującą nothing, np. metodę nothing(String text)




\subsection{Jak można to zrobić(TODO)}
Zdecydowałem sie użyć JSON-RPC, bo mam jsonrpc4j które mogę dopasować do Androida i są dobre, otwarte serializatory do JSON -- Jackson, z którego korzysta jsonrpc4j i JSON.NET dla .NET

\subsection{Jak zrobiłem (TODO)}


Jakie biblioteki użyłem do tego? Że testowałem z Nunitem.

\subsubsection{Porównanie sposobów serializacji w JSON.NET i Jackson}
Jackson serializuje tak a JSON.NET tak (wypunktować):
BLABLABLABLA
Żeby były zgodne trzeba zrobić to i to (wypunktować)

TABLICA
\begin{lstlisting}[float, frame=single, caption={Jackson daje.}, label=kod:jackson-serilization]
[
  "[Ljava.lang.Object;",
  [
    28,
    "jakis tekst",
    {
      "@class":"uniserialjava.DaneA",
      "numberA":13,
      "stringA":"domyslny"
    },
    {
      "@class":"uniserialjava.DaneB",
      "numberA":13,
      "stringA":"domyslny",
      "numberB":5.25
    }
  ]
]
\end{lstlisting}

\begin{lstlisting}[float, frame=single, caption={JSON.NET daje.}, label=kod:json-net-serilization]
{
  "$type": "System.Object[], mscorlib",
  "$values": [
    28,
    "jakis tekst",
    {
      "$type": "UniSerialDotNet.DaneA, UniSerialDotNet",
      "liczbaA": 13,
      "tekstA": "domyslny"
    },
    {
      "$type": "UniSerialDotNet.DaneB, UniSerialDotNet",
      "liczbaB": 5.25,
      "liczbaA": 13,
      "tekstA": "domyslny"
    }
  ]
}
\end{lstlisting}


LISTA
\begin{lstlisting}[float, frame=single, caption={Jackson daje. Lista}, label=kod:jackson-list-serilization]
[
  "java.util.ArrayList",
  [
    28,
    "jakis tekst",
    {
      "@class":"uniserialjava.DaneA",
      "numberA":13,
      "stringA":"domyslny"
    },
    {
      "@class":"uniserialjava.DaneB",
      "numberA":13,
      "stringA":"domyslny",
      "numberB":5.25
    }
  ]
]
\end{lstlisting}

\begin{lstlisting}[float, frame=single, caption={JSON.NET daje. Lista}, label=kod:json-net-list-serilization]
{
  "$type": "System.Collections.Generic.List`1[[System.Object, mscorlib]], mscorlib",
  "$values": [
    28,
    "jakis tekst",
    {
      "$type": "UniSerialDotNet.DaneA, UniSerialDotNet",
      "liczbaA": 13,
      "tekstA": "domyslny"
    },
    {
      "$type": "UniSerialDotNet.DaneB, UniSerialDotNet",
      "liczbaB": 5.25,
      "liczbaA": 13,
      "tekstA": "domyslny"
    }
  ]
}
\end{lstlisting}

SŁOWNIK
\begin{lstlisting}[float, frame=single, caption={Jackson daje. Słownik}, label=kod:jackson-dict-serilization]
{
  "@class":"java.util.HashMap",
  "1":"pierwszy",
  "2":"drugi",
  "3":"trzeci"
}
\end{lstlisting}

%tak wygląda, dla <string, string>, a nie <int, string>
%{"@class":"java.util.HashMap","3":"trzeci","2":"drugi","1":"pierwszy"}

\begin{lstlisting}[float, frame=single, caption={JSON.NET daje. Słownik}, label=kod:json-net-dict-serilization]
{
  "$type": "System.Collections.Generic.Dictionary`2[[System.Int32, mscorlib],[System.String, mscorlib]], mscorlib",
  "1": "pierwszy",
  "2": "drugi",
  "3": "trzeci"
}
\end{lstlisting}

TO, CO MOGŁOBY DAĆ PEŁNY TEST
Ładnie ilustruje różne możliwe przypadki:
\begin{itemize}
	\item Podstawowa serializacja dowolnego obiektu (Call).
	\item Serializacja generycznej tablicy (parameters)
	\item Serializacja tablicy, konkretnego typu (someInts)
	\item Serializacja listy, konkretnego typu (someStrings). Informacja musi być dodana, żeby odróżnić od tablic.
	\item Serializacja tablicy, bez kontekstu konkretnego typu (na koniec parameters)
\end{itemize}

\begin{lstlisting}[float, frame=single, caption={Jackson daje. Faktyczny test wywołania.}, label=kod:jackson-call-serilization]
{
  "@class":"uniserialjava.Call",
  "someStrings": [ "java.util.ArrayList", ["a", "b", "c"] ],
  "someInts": [1,2,3],
  "parameters": [
    "[Ljava.lang.Object;",
    [
      28,
      "jakis tekst",
      {
        "@class":"uniserialjava.DaneB",
        "numberA":13,
        "stringA":"domyslny",
        "numberB":5.25
      },
      ["[I",[1,2,3] ]]
    ]
  ]
}
\end{lstlisting}

TO, CZEGO BĘDĘ FAKTYCZNIE UŻYWAŁ
%{"id":"4653019993893876656","jsonrpc":"2.0","method":"testDataA","params":[{"@class":"jsonrpc4jtestse.TestDataB","numberA":13,"stringA":"domyslny","numberB":5.25}]}
Dopiero pojedyncze paramsy są jakoś bardziej interpretowane przez Jacksona. Dlatego mogę spokojnie pokazać jeden polimorficzny parametr działający przy przechodzeniu przez granicę platform. I tyle wystarczy do prezentacji. Widać, że jest to możliwe, bo mamy wystarczającą ilość przekazywanych informacji. Co prawda ucinamy informację o bibliotecę, ale możemy sobie wyobrazić system mapowania, który by się bez tego obył.

Przydało się, to, że tak samo traktują stringi - nie muszą ich specjalnie opisywać. Tak samo z resztą typów prostych - intem, doublem. Ogólnie można przekazywać ogólnie object. Wszystkie są przedstawiane jednoznacznie.

\subsubsection{Co zrobiłem}
JsonSerializerInternalWriter - we WriteTypeProperty dodane przeszukiwane po Javowym słowniku. Jak jest wpis dla danego typu, to jest używany on a nie normalna nazwa typu w .NET. Dzięki temu Java może zrozumieć.

JsonTypeReflector - TypePropertyName zmienione \$type na @class (bo tak robi Jackson). Przez to działa przekazywanie parametru. JSON.NET ma zhardcodowane to. I tak włąśnie znajduje specjalne parametry, że mają \$ na początku. A jest ich kilka, ale nie przydają się przy przekazywaniu zdalnie. Tak że ta zmiana trochę psuje, bo zmodyfikowany JSON.NET nie może działać z normalnym.

JsonSerializerInternalReader - w ReadMetadataProperties przerobiony \$ na @ żeby czytało @class, w ResolveTypeName dodane sprawdzanie w Javowym słowniku.

JavaTypeDictionary - to dodałem. Można go nakarmić slownikiem (Dictionary) wtedy robi z niego słownik w drugą stronę, dla szybszego przeszukiwania.


\subsection{Ograniczenia/Problemy}
\subsubsection{Problemy serializacji}
Type erasure w Javie jest dużym utrudnieniem dla zachowania pełni informacji o typach.
Jeśli nie można przekazywać genericów, to nie można pewnie przekazywać dowolnych klas. W praktyce sprowadziło by się to pewnie pod pisanie klas ze świadomością ograniczeń systemu. Ale wtedy, to już chyba lepiej skorzystać z czegoś takiego jak thrift.
Jedno, co można zrobić to zobaczyć co się będzie działo jak wszystkie genericsy będziemy robili na object i rzutowali, kiedy będzie trzeba.

Ogólnie projekt jest za duży, żeby badać wszystkie aspekty serializacji. Maksymalnie zgodna serializacja mogłaby być osobnym tematem pracy magisterskiej ze względu na swój stopień skomplikowania.
Dodać to do działu wniosków.

Serializacja zawsze będzie problemem. Chyba, że albo będziemy projektowali klasy danych pod nią, albo cały język zostanie pod jej kątem zaprojektowany (jak Thrift).

Ograniczona współpraca JAvy i C\# jest możliwa, ale nigdy nie będzie pełnej swobody.

Jakieś źródło o tym, jak powinny wyglądać klasy parametrów web serviceów.
Serializatory takie jak JSON.NET próbują być bardziej uniwersalne, wspierając nie tylko przypadki parametrow metod. Np. wtedym kiedy serializują referencję do żywego obiektu, którego nie dałoby się przesłać.
Ale można przyjąć, że dane, które będą wysyłane będą podlegać jakimś ograniczeniom, np. jak w WCF. Klasy danych są projektowane specjalnie pod to, żeby być wysyłane. Lub wysyła się proste juz instniejące klasy, które i tak funkcjonowały bardziej jako dane bez metod.
Z takimi założeniami możemy uzyskać pełną zgodność. No, jedynie zgodności
%Jackson sam nie może przeczytać tablicy prostej, np. ["bla","alb"] jak nie wie z góry co to ma być, a spodziewa się oznaczania typów. Hm... nie jest to prawdą, kiedy taka tablica jest opakowana w coś innego, obiekt albo tablicę obiektów.

\subsubsection{Wymuszenie jednolitej serializacji}
JSON.NET ma 14401 linii kodu (mierzone przy użyciu wtyczki Code Metrics Viewer), Jackson ma 63497 (liczone core, databind i annotations, tylko linie z kodem, używałem narzędzia CLOC). I tak są dobrze napisane i umożliwiają swobodne dostosowywanie wielu części. Niestety ogólne mechanizmy serializacji/deserializacji z informacjami o typach są specyficznie rozwiązane w obu frameworkach i dość mocno uwiązane z resztą biblioteki. Przez to ciężko zmienne.
Poza tym widać, że grafy mogą być bardzo skomplikowane i pełne ich przełożenie z zapisu jednego serializatora na zapis drugiego jeśli nie są niemożliwe, to są trudne. Do tego dochodzą jeszcze różne cechy języka.
Ogólnie możnaby wprowadzić tłumaczenie, ale raczej nie byłoby ono pewne i nie działało zawsze.
Wszystkich przypadków wspierać nie dam rady.

W JSON.NET ważne są klasy JsonSerializerInternalReader i JsonSerializerInternalWriter

Wiąże się albo z wielkim nakładem pracy i duplikacją kodu, albo okaleczeniem istniejącej funkcjonalności. Niektóre rzeczy (\$type) zhardcodowane i spodziewa się \$ na początku specjalnych atrybutów specjalnych.

\subsubsection{Ogarnięcie wyjątków}
Czytanie typów wyjątków też robiłoby problemy, bo wyglądają tak:
%{
  %"jsonrpc": "2.0",
	%"id": 1, "error": {
	  %"code": 0,
		%"message": "Wiadomosc w exceptionie jakas",
		%"data": {
		  %"exceptionTypeName": "java.io.IOException",
			%"message": "Wiadomosc w exceptionie jakas"
		%}
	%}
%}
Czyli jeszcze trzeba by się było sporo zagłębiać w JSON-RPC lub jego implementację.


\subsection{Mapowanie typów}
Potrzebny jest system mapujący nazwy typów w jednym środowisku, na nazwy z drugiego. Mógłby działać na zasadzie słowników. Żeby zmniejszyć nakład pracy mogły by one być generowane automatycznie zgodnie z jakąś zasadą.
Pewnie potrzebny by był też system ładowania klas.
Może jakiś schemacik tego ładowania i jakby mapowanie działało przy serializacji, deserializacji.

Coś jeszcze byłoby potrzebne, żeby to wszystko działało?

Potrzebny byłby system ładowania bibliotek i klas z nich. Ale i tak nie dostarczam gotowego systemu, tylko taki prototyp, wiec chyba mogę to pominąć. Tłumaczenia klas też nie będzie. Albo tłumaczenie mogę pominąć, ładowanie zrobić konfigurowane, tj. tak jak słownik typów byłby spis bibliotek (np. z ich pełnymi ścieżkami). Te biblioteki byłyby ładowane do Assembly w .NET i do aktualnego class loadera w javie. Można by to prosto obtestować.



\section{Zdalne wywoływanie metod na Androidzie(TODO)}
\label{android-rpc}
%Trzeba ustawić zgodne polimorficzne serializatory zarówno dla klienta jak i~serwera i~wywołać jakąś z~metod, którymi testowałem polimorfizm w~rozdziale~\ref{similar-technologies}.
Zastosuję jsonrpc4j (jeśli Jackson w~pierwszym prototypie się spisał) na Androidzie i~JSON-RPC.NET po stronie .NET\@.
Opieranie się o~standard Json-Rpc daje ,,gratis'' identyfikatory połączeń i~wysyłanie błędów.

Jeśli by się nie skupiać na polimorfizmie to, bez opisu typów, samo RPC działać dobrze. Niestety pozbawia to nas w pełni obiektowego modelu programowania zdalnego, rozszerzalności kodu bez jego zmiany i używania klas z dowolnych bibliotek. Może warto wtedy wrócić do Thrifta?

Json-RPC daje adresację i w ogóle. Metody można z kropkami nazywać (jakieś info o tym było w commicie jsonrpc4j), więc można by się odnosić do w sposób serwis.metoda (od tego chyba ten multiserwis jest).

Jak już mamy to, to można wykorzystywać API Androida i nim zarządzać.

Obiekt jest powiązany z~dowolnym portem TCP swojego hosta.
Na port powiązany z~obiektem zdalnym mogą przychodzić wywołania JSON-RPC

Inne klienty: ogólnie można serwować dowolne JSON-RPC. Problemy mogą być tylko wtedy, kiedy chce się uzyskać polimorfizm, bo trzeba mieć tak samo skonfigurowany serializator. Użycie czegokolwiek co korzysta z JAcksona da pełna zgodność, nawet większą niż u mojego klienta, bo będzie też możliwość polimorficznego przesyłania kolekcji. Jeśli nie potrzebuje oznaczania typów, to może używać dowolnego klienta JSON-RPC tak długo, jak ma odpowiednią interpretację. Bo nie musi być bezpośredniego mapowania typów, ale wiadomości JSON muszą móc być interpretowane dobrze (może takie rzeczy w punkcie o tłumaczeniu typów?).

\subsection{Jak to robię?}
Biorę jsonrpc4j, próbuję wyciąć z klas importy, które uniemożliwiają uruchomienie na Androidzie. Możliwe, że i tak ich nie potrzebuję. Przez to będę też musiał wyciąć trochę kodu, ale ponownie -- pewnie i tak go nie potrzebowałem.
W każdym razie chcę powycinać rzeczy z dwóch klas, które wykorzystywałem, czyli JsonRpcServer i StreamServer. Potem je zbudować i wykonać przepakowanie (repackage) jara w taki sposób, żeby zabrać tylko klasy potrzebne do działania tym dwóm, na których mi zależy. Następnie, powstałego Jara spróbuję użyć zamiast jsonrpc4j w moim testowym projekcie pod Windows. Jeśli to się powiedzie, to spróbuję użyć przepakowanego Jara w projekcie Androidowym.

Biorę sobie Jacksony zbudowane pod Javę 7.

.NET jest strasznie zacofany jeśli chodzi o kod kliencki JSON-RPC. W jsonrpc4j można dynamicznie tworzyć klienty do zadanych interfejsów serwisów na dowolnym strumieniu komunikacyjnym, tutaj właściwie nie ma nawet gotowego rozwiązania na jakiegokolwiek klienta. Nawet brak czegoś topornego w użyciu, gdzie podawałoby się nazwę metody jako string, typy i wartości parametrów i oczekiwany typ zwrotny.
Sam muszę coś zrobić.

To też może trafić do ludzi jako patch.
Co ciekawego zrobiłem w kodzie?

Metody nie muszą mieć żadnych parametrów.

Wystarcza to:
%TestServiceImpl service = new TestServiceImpl();
%JsonRpcBasicServer serverBase = new JsonRpcBasicServer(
    %ServerThread.createMapper(),
    %service,
    %TestService.class);
		
%bindAddress = InetAddress.getByName("0.0.0.0");
%StreamServer server = new StreamServer(serverBase, maxThreads, port, 0, bindAddress);
%server.start();


\section{Klient JSON-RPC pod .NET(TODO)}
Dziwne, ale nie ma żadnej dobrej implementacji. JSON-RPC.NET i Jayrock wskazują jakieś propozycje, ale nie ma żadnego dobrego rozwiązania na miarę tego z jsonrpc4j, gdzie wskazuje się interfejs i adres, i dostaje się obiekt klienta realizujący ten interfejs.
Coś takiego robię. Można by to oddać światu open source, co prawda trzeba by było dodać obsługę wszystkich możliwych błędów komunikacyjnych, a to bywa żmudne.

- klient JSON-RPC nie obsługuje wyjątków tak dobrze, jakby mógł (zwracać je normalnie jako obiekty) i nie jest zabezpieczony przed problemami sieciowymi (nie robi retry itp.)

Będzie zgłoszony jako propozycja implementacji, bo żadnej godnej (rozkminiającej interfejsy) nie ma.



\section{Tworzenie zdalnych obiektów na żądanie klienta(TODO)}
Klient musi mieć specjalną metodę, którą będzie wywoływał stworzenie zdalnego obiektu, któremu dalej będzie wysyłał wywołania.
Można to zrealizować przy pomocy mechanizmu rozszerzeń (\emph{Extensions}) standardu JSON-RPC 2.0.
Normalnie tego nie ma, bo raczej mamy dane żyjące serwisy i z nimi gadamy. Też normalnie nie operuje się na typie serwisu. Tu będzie trzeba właśnie podać typ serwisu, jaki chcemy. No w sumie WCF i JAX-WS to jakoś tam robią. Ale one mają jakby serwis i tak wolnostojący i dopiero w nim robią instancje. U mnie będzie jeden główny serwer i pod nim instancje wszystkiego.
%https://jsonrpcx.org/Main/HomePage
%http://grokbase.com/t/gg/json-rpc/138ce80p54/what-are-rpc-extensions
%consolidation service w JSON-RPC?



\section{Wersja z Thriftem}
To mogłoby robić prawie wszystko. Działałoby jako niezależny system i nie korzystało z poprzednich komponentów. Nie realizowałoby jednak wszystkich założeń.