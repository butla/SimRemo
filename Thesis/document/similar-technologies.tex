%podsekcje nie trafią do spisu treści
\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}

\chapter{Pokrewne technologie (TODO)}
W~tym rozdziale przeanalizuję technologie, które według mnie są powiązane z~projektem tworzonym w~niniejszej pracy.
Wśród nich będę szukał takich, które mogę wkomponować w~moje rozwiązanie.

\section{Metoda analizy technologii}
Będą one poddane testom, które sprawdzą obecność pożądanych przeze mnie cech (opisanych w~punkcie~\ref{lib-requirements}).
Niektóre własności, takie jak np.\ łatwość instalacji będą poddane bardziej subiektywnej ocenie.
Nie wszystkie testowane kryteria będą dotyczyć wszystkich technologii, ponieważ te należą do różnych dziedzin.
Testy przedstawione są w~tabeli~\ref{tab:frameworks-criteria}.

\begin{table}[htbp]
	\centering
		\begin{tabular}{ | c | c | p{8cm} |}
			\hline
				\textbf{Nazwa} & \textbf{Dziedzina} & \textbf{Opis}\\
				\hline \hline
				Klasyfikacja & Ogólna & Czym dana technologia jest, co potrafi (z mojej dziedziny zainteresowania)? Czy tłumaczy kod, czy serializuje, czy może być klientem RPC, czy może być serwerem RPC? Poza tym, do których dziedzin z~tej tabeli się zalicza? Czy jej kod jest otwarty?\\
				\hline
				Docelowa platforma & Ogólna & Czy technologia działa na platformie docelowej (Android, .NET)? Której?\\
				\hline
				Łatwość instalacji & Ogólna & Na ile intuicyjne i mało czasochłonne jest zinstalowane danego narzędzia/biblioteki? Na ile łatwo można go użyć, żeby zweryfikować, że działa?  Wyznacznik użyteczności.\\
				\hline
				Łatwość użycia & Ogólna & Dotyczy bardziej sensownego wykorzystania technologii. U mnie to będzie przedstawiać jak trudno było wykonać testy polimorfizmu. Wyznacznik użyteczności.\\
				\hline
				Współpraca & Ogólna & Czy technologia dopuszcza zgodność po obu stronach przy moim użyciu? Czyli na Androidzie i C\#. Łączy się jakoś standardowo, czy własne łączniki po obu stronach implementować? Czy wystarczy skonfigurować istniejące?\\
				\hline
				Standardowość & Ogólna & Uogólnienie kryterium ,,Współpraca''. Czy technologia, przy moim użyciu jest zgodna z~jakimś szeroko przyjętym standardem?\\
				\hline
				\emph{Code reuse} & Ogólna & Czy można do danej technologii podpiąć, albo wykorzystać z~nią jakieś istniejące biblioteki napisane na tę samą platformę? Np. dla technologii Javowych -- Jary.\\
				\hline
				Modularność & RPC & Czy można do serwera i~klienta dodać moduł, np. z~nowymi klasami danych dziedziczącymi istniejące i~używać ich ze starymi metodami?\\
				\hline
				Integracja z~Androidem & RPC & Dotyczy serwerów RPC na Androida. Czy można na zewnątrz wystawić możliwość komunikacji z systemem operacyjnym? Np.\ uruchamianie innych aplikacji?\\
				\hline
				Polimorfizm metod & RPC & Czy zdalne metody mogą być przeładowywane?\\
				\hline
				Polimorfizm danych & Serializacja, RPC & Sprowadza się do zachowania informacji o~typach w~serializowanych danych. Sprawdzane przez serializację i~deserializację jednego obiektu (TestDataB widocznego jako TestDataA) a~następnie sprawdzenie, czy jest taki sam.\\
				\hline
		\end{tabular}
	\caption[Kryteria oceny technologii.]{Kryteria oceny technologii.}
	\label{tab:frameworks-criteria}
\end{table}

Większość testów wykonywana będzie na systemie Windows 7 Professional x64.
Te, które będą tego wymagać będą uruchamiane na emulowanym (w~Windowsie) Androidzie 4.4.2, który szerzej jest opisany w~punkcie~\ref{android-emulator}.


\subsection{Dane do testów polimorfizmu}
W~testach polimorfizmu będą brały dwie klasy danych. Obie są zapisane w~Javie, we fragmencie~\ref{code:testData}, chociaż ich odpowiedniki będą tworzone też w~innych językach. Posiadają one domyślne wartości pól, które będą przydatne w~trakcie weryfikacji wyników testów. Wszystkie dalsze pseudokody będą zbliżone do Javy.

\begin{lstlisting}[float, frame=single, caption={Testowe klasy danych; jedna dziedzicząca drugą.}, label=code:testData]
public class DaneA
{
	public int liczbaA = 13;
	public string tekstA = "cokolwiek";
}

public class DaneB extends DaneA
{
	public double liczbaB = 5.25;
}
\end{lstlisting}


\subsection{Testowanie serializacji}
W~przypadku samej serializacji będzie tylko jeden test, operujący na jednym obiekcie danych -- generycznej tablicy zawierającej obiekty różnego typu.
Sposób jej tworzenia został opisany we fragmencie kodu \ref{code:testArray}.
Test sprawdza, czy informacja o~typach obiektu przeżywa serializację.
Jest to niezbędne aby uzyskać polimorfizm parametrów zdalnych metod.
Właściwe kroki testu:
\begin{enumerate}
	\item Serializacja obiektu (w sumie powinno się go serializować w jakimś kontekście).
	\item Stworzenie nowego obiektu przez deserializację zapisu pierwszego obiektu.
	\item Porównanie nowego i~odtworzonego obiektu. Oba powinny być identyczne pod względem typu i~zawartości.
\end{enumerate}

\begin{lstlisting}[frame=single, caption={Tablica obiektów różnych typów służąca do sprawdzenia, czy informacja o~typie zostaje zachowana.}, label=code:testArray]
Object[] testowaTablica =
		new Object[]{28, "tekst", new DaneA(), new DaneB()};
\end{lstlisting}

\subsection{Testowanie polimorfizmu metod zdalnych}
Testy polimorfizmu metod zdalnych będą weryfikować trzy rzeczy.
\begin{enumerate}
	\item Czy metoda potrafi poprawnie zidentyfikować argument typu dziędziczącego typ spodziewany?
	\item Czy można przeciążać zdalne metody?
	\item Czy dane wchodzące i~wychodzące z~metody są poprawnie serializowane i~deserializowane?
\end{enumerate}

Odpowiedzialne za tę weryfikacje będą testy polegające na stworzeniu zdalnych metod przy pomocy sprawdzanego narzędzia i~próby ich wywołania.
Nawet jeśli metoda się wykona, to mogła nie zwrócić odpowiedniego wyniku, dlatego go też trzeba będzie weryfikować.
Tym testom będą podlegać tylko biblioteki, którą pozwalają tworzyć lub konsumować zdalne metody.
Kody klasy zawierającej testowe zdalne metody (zwanej też serwisem) oraz jej interfejsu znajdują się we fragmencie~\ref{code:testService}

\begin{lstlisting}[float, frame=single, caption={Przykładowa zdalna metoda testowana pod kątem polimorfizmu}, label=code:testService]
public interface ITestowySerwis
{
    String testPodstawowy();
    String testPodstawowy(String argument);    
    DaneA testPolimorfizmuA(DaneA testowyObiekt);    
    Object[] testPolimorfizmuB(Object[] testowaTablica);
}

public class TestowySerwis implements ITestowySerwis
{
    String testPodstawowy()
    {
        return "Dziala!";
    }
        
    String testPodstawowy(String argument)
    {
        return "Dostalem " + argument;
    }
    
    DaneA testPolimorfizmuA(DaneA testowyObiekt)
    {
        testowyObiekt.liczbaA += 1;
        testowyObiekt.tekstA += " cos dodano!";
        return testowyObiekt;
    }
    
    Object[] testPolimorfizmuB(Object[] testowaTablica)
    {
        int dlugoscTablicy = testowaTablica.length;
        Object[] nowaTablica = new Object[dlugoscTablicy+1];
        for(int i = 0; i < dlugoscTablicy; i++)
        {
            nowaTablic[i] = testowaTablica[i];
        }
        nowaTablica[dlugoscTablicy] = 3.14;
    }
}
\end{lstlisting}

%Dla każdego wypisać wady i zalety względem moich celów. Jakieś podsumowanie do czego może być

%Najpierw przedstawiam każdy framework ``cytując'' jego słowa (README). A~więc przedstawiam jego obietnice. Potem testy sucho powiedzieć co zrobiłem i~jak wyszło. Potem użyteczność -- jakie miałem problemy przy instalacji, na ile jest ona łatwa, jak ciężko było zrobić coś więcej. Na ile łatwo się odnaleźć przy instalacji? (ważne dla programisty). Rozszerzalność -- jak ciężko jest dodawać nowe podklasy do parametrów metod?



\section{Jackson}
\label{jackson}
Jackson to zestaw narzędzi do przetwarzania danych stworzony dla Javy (i~platformy JVM).
Wspiera wiele kodowań: JSON, Avro, CBOR, CSV, Smile, XML i~YAML.
Najbardziej znany jego komponent to biblioteka do parsowania i~generacji danych w~formacie JSON.
Można jej używać jako narzędzia do serializacji i~deserializacji obiektów.
Spośród całego zastawu przyglądał się będę tylko jej.
Więcej informacji na temat Jacksona można znaleźć na jego oficjalnej stronie w~serwisie Github: \url{https://github.com/FasterXML/jackson}.

\subsection{Ocena}

\begin{description}
\itemtitle{Klasyfikacja}
Serializator JSON pod Javę. Otwarty kod.

\itemtitle{Docelowa platforma}
Działa na Androidzie. Skierowane pod maszynę wirtualną Javy (JVM).

\itemtitle{Łatwość instalacji}
Łatwa, ale nie banalna.
Wymaga odnalezienia się pośród kilku przestarzałych stron, zawierających sprzeczne informacje.
Na właściwej stronie głównej, potrzebne biblioteki mogłyby być wyraźniej wskazane.
To, że wszystko narzędzie jest do pobrania z~Githuba może być odebrane dwojako; z~jednej strony trzeba się z~nim przez chwilę zaznajomić, z~drugiej, jest to popularna platforma standaryzująca dystrybucję wielu bibliotek i~dla niektórych może być bardziej intuicyjna niż osobna, unikatowa strona domowa projektu.

\itemtitle{Łatwość użycia}
Sensowne i łatwe, ale może nie oczywiste. Niektóre bardziej zaawansowane cechy, np. zmiana stylu oznaczania typów słabo udokumentowana.

%Może zamiast standardowość i współpraca zrobić pole zgodność?
\itemtitle{Standardowość}
JSON jest znanym standardem, a~Jackson się do niego stosuje.
Co prawda, JSON nie przewiduje zawierania informacji o~typach.
Jackson musi robić to na własną rękę, dodając informację o~typach do zapisywanych grafów. Oczywiście, musi być w~stanie także je odczytać.
Jednak styl oznaczania typów jest konfigurowalny, dlatego teoretycznie można go dopasować do innego stylu oznaczeń, np.\ tego stosowanego przez klasę \texttt{DataContractJsonSerializer} z~.NET\@.
To pozwalałoby na używanie różnych silników serializacyjnych po obu stronach kanału komunikacyjnego, jednocześnie zachowując informację o~typach.

\itemtitle{Współpraca}
To samo, co w~,,Standardowości''.

\itemtitle{Code reuse}
Jest -- można serializować i~deserializować klasy wzięte z~zewnętrznych bibliotek.

%Może jakaś sekcja ze spostrzeżeniami albo każda z tych ocen jako osobne subsubsection?
\itemtitle{Polimorfizm danych}
Jest. Realizowany przy pomocy wpisywania dodatkowych danych o~typach wtedy, gdy nie wynika on jasno z~kontekstu\footnote{Faktycznie to jedno z~możliwych ustawień. Generalnie można konfigurować kiedy ma być dodawana informacja o~typach.}.
Sposób wpisywania tej informacji może być konfigurowany.
Jednym sposobem jest dodanie do obiektu specjalnego pola; jak we fragmencie kodu~\ref{code:typeInfoField}, gdzie obiekt typu DaneB był w~kontekście sugerującym DaneA i~musiało to być oznaczone.
Innym sposobem jest owinięcie obiektu w~tablicę i~dodanie nazwy typu jako jej pierwszy element, jak w~kodzie~\ref{code:typeInfoArray}.
Zastrzeżeniem jest serializacja tablic -- w~tym przypadku można to zrobić tylko przez owijanie w~kolejną tablicę.

Trzeba zaznaczyć, że dodawanie informacji o~typach nie jest zachowaniem domyślnym. Aby to osiągnąć należy odpowiednio skonfigurować klasę odpowiedzialną za serializację i~deserializację (\texttt{ObjectMapper}) lub dodać adnotację \texttt{JsonTypeInfo} do konkretnego typu danych (przykład na fragmencie~\ref{code:typeInfoAnnotation}). Wszystkie klasy dziedziczącej po klasie z~\texttt{JsonTypeInfo} będą, w~przypadku serializacji, opisywane w~analogiczny sposób.

\begin{lstlisting}[float, frame=single, caption={Oznaczanie typu przez dodatkowe pole.}, label=code:typeInfoField]
{
    "@class":"test.DaneB",
    "liczbaA":13,
    "tekstA":"domyslny",
    "liczbaB":5.25
}
\end{lstlisting}

\begin{lstlisting}[float, frame=single, caption={Oznaczanie typu przez owinięcie w~tablicę i~dodanie do niej elementu.}, label=code:typeInfoArray]
{
    [
        "test.DaneB",
        {
            "liczbaA":13,
            "tekstA":"domyslny",
            "liczbaB":5.25
        }
    ]
}
\end{lstlisting}

\begin{lstlisting}[float, frame=single, caption={Parametryzacja przekazywania informacji o~typie w~definicji klasy.}, label=code:typeInfoAnnotation]
@JsonTypeInfo(
    use=JsonTypeInfo.Id.CLASS,
    include=JsonTypeInfo.As.PROPERTY,
    property="@class")
public class DaneA
{
    ...
\end{lstlisting}
\end{description}

\subsection{Podsumowanie}
Jackson to solidna i~konfigurowalna biblioteka serializacyjna dla Javy, dodatkowo działająca na Androidzie.
Dlatego ma dużą szansę na wykorzystanie w~Androidowej części mojego projektu.



\section{JSON-RPC for Java (jsonrpc4j)}
Biblioteko umożliwiająca łatwą implementacji standardu JSON-RPC 2.0 w~języku Java.
jsonrpc4j używa biblioteki Jackson do konwersji pomiędzy obiektami Javy a~dokumentami JSONa oraz do innych czynności związanych z~JSON-RPC.
Umożliwia wywoływanie zdalnych metod nie tylko przez HTTP, ale też przez sockety TCP.
Informacje na jego temat oraz jego kod źródłowy dostępne są na jego oficjalnej stronie w~serwisie Github: \url{https://github.com/briandilley/jsonrpc4j}

\subsection{Ocena}
\begin{description}
\itemtitle{Klasyfikacja}
Klient i~serwer RPC. Otwarty kod. Serializacja dostarczana przez zewnętrzną bibliotekę -- Jackson.

\itemtitle{Docelowa platforma}
Java SE. Teoretycznie na Androidzie powinien działać zarówno klient jak i~serwer.

JsonRpcServer -- jest zależny od rzeczy z~javax od serwletów, a~tego na Androidzie nie ma. Wywala się w~trakcie ładowania klasy. Android Lint od razu przestrzega, że to nie jest.

Wczepiłem do projektu Androidowego zrobionego Eclipsem z~ADT.

\itemtitle{Łatwość instalacji}
Średnia.
Bibliotekę trzeba ściągnąć w~formie kodu (używając Gita lub ściągając paczkę), a~następnie zbudować korzystając z~narzędzia Maven.
Nie wszyscy mają na swoich systemach Mavena, a~jego instalacja także wymaga kilku czynności (co prawda nieskomplikowanych).

Napisanego pierwszego programu nie uda się najprawdopodobniej uruchomić za pierwszym razem, z~powodu braku niektórych klas.
Należy czytać błędy, dedukować jakich bibliotek brakuje po pełnych nazwach klas, a~następnie ściągać i~dodawać te biblioteki do programu.
Biblioteki, których brakuje to trzon Jacksona (\texttt{jackson-core}, \texttt{jackson-databind}, \texttt{jackson-annotations}) oraz \texttt{javax.servlet-api}.

\itemtitle{Łatwość użycia}
Użycie jest łatwe. Kod jest logicznie ustrukturalizowany i~elastyczny.
Dobrze rozdzielone są warstwy tłumacząca dane i~komunikacyjna.
Na głównej stronie projektu można znaleźć przykłady, dzięki którym można szybko rozpocząć pracę.

Przeprowadziłem testy wzorując się na najprostszym przykładzie niekorzystającym z~frameworku Spring, wykorzystując klasę \texttt{StreamServer}.
W~moim zastosowaniu zarówno klient jak i~serwer działały lokalnie na jednej maszynie. Dodatkowo, serwer musiał być niezależną aplikacją niekorzystającą z~kontenera Javy EE\footnote{Przykładem takiego kontenera mogą być Glassfish lub serwer Apache.}.
Takiego przypadku nie było w~przykładach, ale dzięki sensownej strukturze biblioteki szybko rozwiązałem mój problem odpowiednio konfigurując klasy.0

Nie da się, niestety, tak skonfigurować ,,serwera strumieniowego''(\texttt{StreamServer}), żeby działał w~jednym procesie na strumieniach w~pamięci. Trzeba użyć socketów. Nie jest to duży problem, ale wymaga większej finezji przy przechwytywaniu wiadomości w~celu analizy. Chociaż warto znowu pochwalić budowę biblioteki za to, że takie przechwytywanie jest w~ogóle możliwe.

%Można jeszcze zaznaczyć, że wersja Jacksona, którą ściąga Maven w~trakcie budowania tego projektu, ma błąd w~domyślnym typowaniu korzystając z metody valueToTree (można używać innej, która działa). Trzeba ściągnąć nowszą.

\itemtitle{Zgodność}
Jest zgodność ze standardem JSON-RPC 2.0. Ale standard ten nie mówi nic o~danych zawierających dodatkowe informacje o typach.
Dlatego zgodność z~drugą stroną możliwa jest tylko w~przypadku analogicznie skonfigurowanej warstwy serializacyjnej (więcej informacji w~punkcie~\ref{jackson}).

\itemtitle{\emph{Code reuse}}
Jest -- można używać klas z~zewnętrznych bibliotek jako danych w~metodach zdalnych, można też wystawiać je jako serwisy (obiekty wystawiające na zewnątrz zdalne metody).

\itemtitle{Modularność (taka rozszerzalność)}
Jest -- można dodać nowe klasy dziedziczące po argumentach zdalnej metody i~ta metoda może je obsługiwać. Nie wymaga to żadnych zmian w~kodzie samej metody. Nowe klasy muszą się znaleźć na kliencie i~na serwerze.

\itemtitle{Integracja z Androidem}
Nie ma, ponieważ serwer nie działa na Androidzie. Gdyby jednak działał, to jako aplikacja Javowa nie miałby żadnych przeszkód w~komunikowaniu się z~systemem.

\itemtitle{Polimorfizm metod}
Jest.

\itemtitle{Polimorfizm danych}
Jest. Zależny od Jacksona, można odnieść się do jego opisu w~punkcie~\ref{jackson}.
\end{description}

\subsection{Podsumowanie}
Ta biblioteka to poważny kandydat na wykorzystanie w~moim projekcie.
Jest kompletna, zrozumiała i~łatwa w~użyciu.
Może też współpracować z~klientem JSON-RPC w~.NET, którego serializator będzie tak samo skonfigurowany, jak Jackson po stronie Androida.
Niestety, mimo obietnicy twórcy, nie można na Androidzie stworzyć serwera\footnote{Zgłosiłem ten problem na oficjalnej stronie.}, ale zdaje się, że można by to naprawić przez wycięcie fragmentów kodu, które i~tak nie są potrzebne w~moim scenariuszu użycia.

%Ok, prosty test z przekazaniem dziedziczącego argumentu wywala się z~uwagi na nierozpoznanie dodatkowego pola parametru. Nie wie, że to inny typ.
%%{"id":"3199114083297069103","jsonrpc":"2.0","method":"testDataA","params":[{"numberA":13,"stringA":"domyslny","numberB":5.25}]}
%%Unrecognized field "numberB" (class jsonrpc4jtestse.TestDataA), not marked as ignorable (2 known properties: , "numberA", "stringA"])

%Readme nic o~tym nie mówi, dokumentacji nie ma. Ale w~błędzie jackson, więc trzeba się udać do Jacksona.
%Najwyraźniej potrzeba dodatkowych informacji, żeby serializacja mogła się udać. Z~pomocą przychodzi funkcja oznaczania typów obiektów we wiadomości\cite{jackson-polymorphic}.
%Nawet mimo tego są jakieś problemy... Robi się to irytujące.
%Używa valueToTree zamiast po prostu write i~przez to nie chce przejść z~oznaczaniem typów.

%A po dodaniu do klasy głównej danych znacznika nakazującego oznaczenie typów wszystko działa.
%%{"id":"4653019993893876656","jsonrpc":"2.0","method":"testDataA","params":[{"@class":"jsonrpc4jtestse.TestDataB","numberA":13,"stringA":"domyslny","numberB":5.25}]}
%%{"jsonrpc":"2.0","id":"4653019993893876656","result":{"@class":"jsonrpc4jtestse.TestDataB","numberA":14,"stringA":"domyslny dodałem coś!","numberB":5.25}}
%Wraca obiekt o poprawnym typie. Bez ustawiania czegokolwiek w~Mapperach.
%Dodanie jednego znacznika do głównej klasy w~hierarchii nie jest straszne, ale sprawdźmy jeszcze domyślne typowanie z~najnowszą wersją Jacksona (bo do jsonrpc4j zrobiła się jakaś 2.0.2).
%Z wersją 2.4.2, działa teraz bez oznaczeń na klasie. Ale za to trzeba i~serwer, i~klienta stworzyć z~ObjectMapperem, w~którym włączy się enableDefaultTyping(). W moim przypadku było to
%%mapper.enableDefaultTyping(
                %%ObjectMapper.DefaultTyping.NON_FINAL,
                %%JsonTypeInfo.As.PROPERTY);
%Które dodaje informację o~klasie jako dodatkowe pole obiektu (\emph{property}), przy wszystkich obiektach, które nie są oznaczone jako final (takie, po których się nie da dziedziczyć).
%%{"id":"-6659082740394205036","jsonrpc":"2.0","method":"testDataA","params":[{"@class":"jsonrpc4jtestse.TestDataB","numberA":13,"stringA":"domyslny","numberB":5.25}]}
%Wygląda tak samo, jak przy oznaczaniu w~klasie.



\section{Xamarin}
\subsection{Opis (DONE)}
Xamarin jest środowiskiem do tworzenia aplikacji mobilnych na platformy Android, iOS i~Windows\cite{xamarin-overview}.
Pozwala na stworzenie jednego kodu w~C\#z~którego może powstać aplikacja na dowolny z~wcześniej wymienionych systemów. Tylko nieznaczna część aplikacji musi być świadoma, a~zatem zależna od systemu operacyjnego.
Twórcy twierdzą, że C\# jest najlepszym językiem do tworzenia aplikacji mobilnych, posiadając cechy takie jak lekkość składni, silne typowanie, operacje asynchroniczne, czy wyrażenia lambda\footnote{Dostępne dopiero w~Javie 8\cite{java-8-features}, podczas gdy Android ma co najwyżej 7\cite{android-java-7}} .

Xamarin daje programistom dostęp zarówno do biblioteki .NET, jak i~API charakterystycznych dla danej platformy. Skupię się tutaj na Androidzie, bo ze wszystkich wspieranych platform tylko on mnie interesuje.
Wykonywanie kodu po stronie Androida odbywa się dzięki silnikowi Mono\footnote{O~którym była już mowa w~rozdziale \ref{android}}\cite{xamarin-android-arch}.
Podobnie jak przy użyciu Mono\cite{mono-compatibility}, nie można korzystać z~pełni możliwości .NET\cite{xamarin-dot-net}.

Na korzyść Xamarina może przemawiać to, że znalazł użytek wśród znanych organizacji, takich jak Bosch, Github czy Dow Jones\cite{xamarin-overview}.
Ponadto, jego twórcy współpracują z~Microsoftem.

%\url{http://docs.xamarin.com/guides/cross-platform/application_fundamentals/web_services/}\\

\subsection{Instalacja i~hello world}
Ściąga się łatwo z~głównej strony. Jedyne, co zwalnia ten proces to podawanie swoich danych.
Bardzo chwalę sprytny instalator, który tłumaczy dokładnie jakie elementy są potrzebne. Mam Javę i~Android SDK, ale mówi, czego w~Android SDK mi brakuje i~że Java 6 konkretnie jest potrzebna. Bardzo ładnie.

Teraz trochę mieli. Ale czas nie jest ważny, ważny jest wysiłek programisty.

Widać, że inwestują w~komunikację z~programistą. Prowadzą za rękę i~pomagają.

Możliwości na innych OSach nie będą mnie interesować. Zrobię tylko n Androidzie. Wszystko jest bardzo intuicyjne dla kogoś, kto korzystał z~IDE takich jak Visual Studio, Netbeans itp.
Tworzę projekt Androidowy.
Ponieważ miałem już stworzone AVD\footnote{O~emulatorze piszę w~punkcie~\ref{android-emulator}} widzę je już do wyboru do odpalenia.
Może trzeba mieć doświadczenie z~emulatorem minimalne. Żeby wiedzieć, że jest osobna aplikacja zarządzająca nim.
Po prostu odpalam Run na świeżo uruchomionym projkecie.

Musi się zainstalować jeszcze Mono, żeby aplikacja mogła działać. Dzieje się to automatycznie.
Oj... odpalenie nie powiodło się, bo rzekomo mój Android nie jest w~wersji wystarczającej dla aplikacji.
Automatycznie brało najnowszą, oznaczoną jako 4.4, ale niby była za nowa. Jak przestawiłem ręcznie na 4.4 to zaczęło działać. Pewnie brało 4.4W, a~więc nowszą, ale źle sygnalizowało. Już jest minus, bo jeślibym nic nie wiedział o~Androidach, to mógłbym się speszyć.

Ale poza tym działa.

\subsection{Testy}
Ponieważ nie ma serwerów WCF (jak napisano... gdzieśtam), użyję innego podejścia do zdalnego wywołania.
Teraz mam .NET na Androidzie, czyli komunikacja z~.NETem na PC powinna być bardzo łatwa. Może nawet mogę zserializować binarnie jakąś domyślną serializatorką .NETa i~przepchnąć przez socket? To by było moje RPC całe. No potrzeba jeszcze jakiś ID obiektu i~metody, ale to jest banalne do uzyskania, jeśli po obu stronach mamy, np. takie same biblioteki .NET.

Ponieważ .NET po stronie Androida może wysyłać wołania do systemu i~wołać biblioteki Javowe (przy użyciu jakiś bindingów, LINK) to mogłoby się to liczyć jako wywoływanie kodu w~Javie, a~więc cel mojej magisterki.
Trzeba to sprawdzić.

Żeby tylko dostępne typy serializacji mogły przenieść informacje o~niepewnych typach\ldots
Chociaż może domyślna, jakaś wewnętrzna (nie chcemy tego wysyłać na inną platformę, wszystko zostaje wewnątrz .NET) zachowuje wszystkie informacje o~obiekcie?

Zobaczymy. Ogólnie trzeba zserializować takie same rzeczy, jak w~przypadku innych testów (takie rzeczy, jak argumenty testowych metod zdalnych), przesłać, zdeserializować i~zobaczyć, czy informacja o typie się zachowała.
Problem taki, że teraz muszę przesłać z~mojego Windowsa na emulator, żeby sprawdzić, czy można mieć te same biblioteki .NET (zawierające jakieś klasy, których chcemy przesyłać) na PC i~na Androidzie z~Mono. Właściwie, to nie muszę. Wystarczy stworzyć raz bibliotekę, podczepić ją pod dwa projekty i sprawdzić, czy tak samo serializuje i deserializuje.

TESTY:
\begin{itemize}
	\item Czy mogę otworzyć inną aplikację w~Androidzie?
	\item Czy mogę odpalić jakieś metody z~Jara?
	\item Można zachować informacja o~typie przy serializacji (obiekt i~tablica)?
	\item Mogę mieć wykorzystać te same biblioteki .NET i~na PC i~na Androidzie?
	\item Przesłać w~jedną i~w drugą polimorficzne rzeczy (tylko sprawdzać dla remotingów jakiś, normalnie przesłanie jest banalne).
\end{itemize}

\subsubsection{Serializacja} 
Zobaczę najpierw serializację lokalnie wewnątrz Mono. Skupię się na serializatorach wbudowanych w~.NET. Można by używać innych, ale nie ma potrzeby. Trzeba się będzie pomęczyć z~DataContractSerializerem tak samo, jak w~WCF. Można też JsonContractSerializer sprawdzić, czy jak mu tam.

Standardowo używa się DataContract, ale nie trzeba.
DataContractSerializerowi trzeba dać informacje o~wszystkich typach, jakich ma się spodziewać. Albo zrobić oznaczenia. Oznaczenia blokują rozwijanie kodu. Podawanie wszystkich klas też trzeba jakoś rozwiązać, np. przez analizę bibliotek i~ładowanie wszystkich możliwych klas (DataContractów).

%Jest TestDataA, bo to jest mój podstawowy serializowany typ
%﻿<TestDataA xmlns:i="http://www.w3.org/2001/XMLSchema-instance" i:type="TestDataB" xmlns="http://schemas.datacontract.org/2004/07/XamarinRemotingTest"><numberA>13</numberA><numberB>5.25</numberB><stringA>domyslny</stringA></TestDataA>

Można użyć też DataContractJsonSerializera do serializacji do JSONa.
Niestety Json potrzebuje dodatkowego ustawienia, żeby zapamiętać typ. A~to ustawienie niesie za sobą potrzebę większej konfiguracji, ogólnie da się wykminić, ale nie musiałoby tak być. Niektóre rzeczy, które, jak by się mogło wydawać, powinny działać nie działają (i~to exception nic nie mówi).
%There was an error during serialization for object of type XamarinRemotingTest.TestDataB
% Ten error przy takim ustawieniu
%var jsonSettings = new DataContractJsonSerializerSettings ();
			%jsonSettings.RootName = "root";
			%jsonSettings.KnownTypes = knownTypes;
			%jsonSettings.EmitTypeInformation = EmitTypeInformation.AsNeeded;
			%DataContractJsonSerializer jsonSerializer = new DataContractJsonSerializer(typeof(TestDataA), jsonSettings);

Hm... Dla normalnego .NETa 4.5 wszystko działa i daje zapis taki
%{"__type":"TestDataB:#XamarinRemotingTest","numberA":13,"stringA":"domyslny","numberB":5.25}
Może to problem samego .NETa? Xamarin ogólnie stoi na poziomie 3.5, a~biblioteki serializacyjne ma zgodne z~silverlightem\cite{xamarin-dot-net}.
Nie będę sobie tym więcej głowy zawracał i~skupię się na XMLu, w~takim razie. Jeśliby Xamarin był bardzo obiecujący to wrócę do JSONa.

Jeszcze tablice.
Zserializowało niby ładnie, ale zdeserializowało już całkiem błędnie. Niby przeszło, ale zwróciło jakiś uszkodzony TestDataA zamist tablicy.
%<TestDataA xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.datacontract.org/2004/07/XamarinRemotingTest">
	%<anyType xmlns:d2p1="http://www.w3.org/2001/XMLSchema" i:type="d2p1:int" xmlns="http://schemas.microsoft.com/2003/10/Serialization/Arrays">28</anyType>
	%<anyType xmlns:d2p1="http://www.w3.org/2001/XMLSchema" i:type="d2p1:string" xmlns="http://schemas.microsoft.com/2003/10/Serialization/Arrays">jakis tekst</anyType>
	%<anyType xmlns:d2p1="http://schemas.datacontract.org/2004/07/XamarinRemotingTest" i:type="d2p1:TestDataA" xmlns="http://schemas.microsoft.com/2003/10/Serialization/Arrays">
		%<d2p1:numberA>13</d2p1:numberA>
		%<d2p1:stringA>domyslny</d2p1:stringA>
	%</anyType>
	%<anyType xmlns:d2p1="http://schemas.datacontract.org/2004/07/XamarinRemotingTest" i:type="d2p1:TestDataB" xmlns="http://schemas.microsoft.com/2003/10/Serialization/Arrays">
		%<d2p1:numberA>13</d2p1:numberA>
		%<d2p1:numberB>5.25</d2p1:numberB>
		%<d2p1:stringA>domyslny</d2p1:stringA>
	%</anyType>
%</TestDataA>

W normalnym przypadku dla .NET wygląda to tak:
%<TestDataA i:type="a:ArrayOfanyType" xmlns="http://schemas.datacontract.org/2004/07/CSharpTest" xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns:a="http://schemas.microsoft.com/2003/10/Serialization/Arrays">
	%<a:anyType i:type="b:int" xmlns:b="http://www.w3.org/2001/XMLSchema">28</a:anyType>
	%<a:anyType i:type="b:string" xmlns:b="http://www.w3.org/2001/XMLSchema">jakis tekst</a:anyType>
	%<a:anyType i:type="TestDataA">
		%<numberA>13</numberA>
		%<stringA>domyslny</stringA>
	%</a:anyType>
	%<a:anyType i:type="TestDataB">
		%<numberA>13</numberA>
		%<stringA>domyslny</stringA>
		%<numberB>5.25</numberB>
	%</a:anyType>
%</TestDataA>
Niby te same informacje, ale inaczej (lżej) oznaczone. I nie dodaje to pierwsze informacji o typie do głównego obiektu.

Normalny .NET wywala błąd, także są jakieś rozbieżności w~nich najwyraźniej. Ale może można skonfigurować, żeby było dobrze.
Do serializatora normalnego .NETa wystarczyło dodać typ tablicy obiektów (bo to faktycznie jest przesyłane).
Na Xamarinie nie pomogło to, ani dodanie jeszcze inta i~Stringa.

Czyli polimorfizm jest częściowy.
Jeśli przejdzie test odpalania tych samych bibliotek na dwóch środowiskach, to zawsze będzie można używać jednej biblioteki serializacyjnej po obu stronach.

A~jeszcze serializacja binarna.
Każdy obiekt z hierarchii klas serializowanego oraz każdy obiekt w~grafie musi posiadać atrybut Serializable (\url{http://msdn.microsoft.com/pl-pl/library/system.serializableattribute(v=vs.110).aspx}), jak nie będzie błąd serializacji. Już to trochę ogranicza pole manewru. Np.\ jeśli chcielibyśmy przesyłać klasę, którą zrobiliśmy z~dziedziczenia jakiejś zewnętrznej, do której kodu nie mamy dostępu.

Poza tym, serializacja binarna zachowuje pełnię informacji. A~zserializowna tablica zajmuje 254 bajty. Zserializowana tekstowo ma 623 znaki. Jeśli jest to UTF-8, to może to być większe niż 623 bajty bo może zawierać większe znaki.
Niestety, binarne zapisy z .NETa 4.5 i~3.5 (który powinien być najbliższy) są niezgodne.

\subsubsection{Użycie zewnętrznej biblioteki .NET (dzielenie się klasami)} 
Xamarin.Android is not ABI compatible with existing assemblies compiled for a different profile. You must recompile your source code to generate assemblies targeting the Xamarin.Android profile (just as you need to recompile source code to target Silverlight and .NET 3.5 separately).\cite{xamarin-dot-net}

W~sumie przy okazji testów kompilowałem ten sam kod. Widać, że są różnice w~działaniu niektórych rzeczy, ale biblioteki bez skomplikowanych (źle działających) zależności powinny te same źródła (np.\ klasy danych) działać tak samo.

\subsubsection{Czy mogę otworzyć inną aplikację w~Androidzie}
Można znaleźć na to oficjalny przykład (krótki prosty kod wyglądający tak samo, jak na normalnym androidzie).

W sumie chodzi o wyslanie intentu, to takie androidowe wiadomosci (źródło, z książki o androidzie).
Dzięki nim aplikacje komunikują się z~systemem i~ze sobą nawzajem.
Wysyłając intent można też uruchomić inną aplikację.
Skoro odpalenie aplikacji działa, to działają intenty i~można zarządzać całym systemem (jeśli aplikacja ma odpowiednie prawa) (może w tej książce jest o tym).

\subsubsection{Czy mogę odpalić jakieś metody z~Jara}
%http://developer.xamarin.com/guides/android/advanced_topics/java_integration_overview/binding_a_java_library_(.jar)/
Do tej pory nas nie okłamali i wątpię, żeby nie działało coś tak dokładnie opisywanego, więc sprawdzał nie będę. Przedstawili sprawozdanie z prawdziwego użycia.

\subsection{Jakieś spostrzeżenia?}
Ma ciekawe techniki generowania wrapperów (bindingów) na Javę do użycia z~C\#. Może warto będzie przyjrzeć się im niezleżnie.

Podstawowa serializacja .NETa jest ograniczona i nie można zachowywać pełni danych o typach. Serializacja binarna nie jest zgodna z normalnym .NETem. Pewnie trzeba by było użyć jakiejś zewnętrznej biblioteki po obu stronach, żeby mogło to działać.

Można zarządzać Androidem i wywoływać kod Javowy z jarów, ale system pewnie nie byłby polimorficznym RPC, a czymś bardziej nieporęcznym. Trzeba by serializować rzeczy w jednym .NETcie, przekazywać do Mono i tam do Javy przez wrappery. Mało eleganckie, ale może mogłoby ładnie działać.



\section{Sharpen}
\subsection{Opis}
Wtyczka do IDE Eclipse tłumacząca kod w~Javie do C\#.
Polecana przez Xamarina (\url{http://developer.xamarin.com/guides/android/advanced_topics/java_integration_overview/}).

Nie jest dynamicznie rozwijany. Mimo wszystko jest polecany.

Generowałbym raczej kod z~Javy do C\#, bo w~Javie będzie większość logiki zdalnych metod.

\subsection{Instalacja i hello world}
Istnieje kilka wersji w~różnych miejscach, co wprowadza w~zakłopotanie. (\url{https://github.com/slluis/sharpen}, \url{https://github.com/xamarin/XobotOS/tree/master/sharpen} i~\url{http://community.versant.com/documentation/reference/db4o-7.12/java/reference/html/Content/sharpen/how_to_setup_sharpen.html})

Ale znalazłem poradę tu \url{http://pauldb.tumblr.com/post/14916717048/a-guide-to-sharpen-a-great-tool-for-converting-java} i~ściągnąłem gotowego Jara, bez problemów z~niezrozumiałym sposobem budowania.
Ale to, że nie ma od razu jasno powiedziane jak to zainstalować to źle.

W każdym razie dodałem po prostu wtyczkę do eclipse.

Stworzyłem przykładowy projekt z~klasą, którą będę chciał przetłumaczyć. Tylko jedną na razie, żeby zobaczyć, że działa.
Do projektu configi. Widać, że nie jest to całkiem proste, ale przynajmniej jest konfigurowalne.
Zmapowałem namespace do docelowego.

Jeszcze trochę zmagania się z~problemami przy buildzie\ldots{} No jednak nie chce mi zacząć działać. Skoro tyle problemów z~prostą rzeczą, to chyba nie jest to dosć dojrzały projekt i~trzeba znaleźć coś lepszego.

Walczę dalej, teraz korzystając z pomocy tego \url{http://stackoverflow.com/questions/10539105/using-sharpen-and-eclipse-error-application-sharpen-core-application-could}

Nie, to koniec. Jest to już za stare i~nie wspierane. Strony z~dokumentacją zostały zdjęte. Ludzie od Xamarina używają jakiejś swojej, dopasowanej wersji.

Aaaalbo jeszcze sprawdzę to \url{https://github.com/xamarin/XobotOS/tree/master/sharpen}, wersję Sharpena o której pisali w blogu xamarina (\url{http://blog.xamarin.com/android-in-c-sharp/})
No nic, nie działa. Ten projekt też ma dwa lata, może to za dużo dla wtyczki do Eclipsa. Koniec.

\subsection{Testy}
\begin{itemize}
	\item Przetłumaczenie klasy zawierającej podstawowe typy, listy, tablicy, mapy, jakąś inną klasę, domyślne wartości.
	\item Przetłumaczenie prostej metody (chociaż na tym mi nie zależy, bo to transport danych; mogą być niby accesory zmieniające coś przy czytaniu, ale cóż -- zbyt wydziwiane to jest)
\end{itemize}

\subsection{Jakieś spostrzeżenia?}
Wydaje się przestarzały lekko. Nie jest jakimś automatem, ale można go raz skonfigurować i już nie mieć problemów.

Nie jest bardzo trudny, nie jest też bardzo prosty.

Zdaje się, że ja tego będę używał dużo bardziej trywialnie, niż można. Bo tylko chcę obiekty danych dla zdalnych metod tłumaczyć.

Nie wspierane, za stare. Najwyraźniej dwa lata to za dużo dla Eclipsowej wtyczki. Nikt nie sprawuje nad tym Sharpenem kontroli. Taki bezpański projekt.

Ale coś takiego pewnie by się przydało w~moim ostatecznym rozwiązaniu. Może nie jako nierozerwalny element, ale jako coś, co przygotuje spójne klasy po obu stronach.


\section{JsonRpc}
\subsection{Opis}
Przez autora przedstawiony jako łatwy i~lekki klient/serwer RPC oparty o~JSON (``Easy and lightweight Json-Rpc Client/Server'')\cite{json-rpc}.
Oparcie o~JSONa oznacza, że wiadomości, zawierające zserializowane obiekty, przesyłane między klientem a~serwerem zapisane są JSONem. Biblioteka powinnna działać dla Androida, Google App Engine i~aplikacji Javascript.

Jest napisany w~Javie.
API klienta i~serwera jest zaprojektowane tak, aby programista nie musiał być świadomy szczegółów protokołu komunikacyjnego.
Aby stworzyć zdalną metodę wystarczy zarejestrować klasę zawierającą tę metodę po stronie serwera, a~następnie po stronie klienta dynamicznie\footnote{Dosłownie ``w locie'', z~ang. \emph{``on the fly''}} stworzyć do niej proxy.

Serializacja do JSONa (i~deserializacja z~niego) najprawdopodobniej nie jest zaimplementowana w~samym JsonRpc, a~przez bibliotekę Gson, która wchodzi w~skład JsonRpc. Gson\footnote{\url{https://code.google.com/p/google-gson/}} jest serializatorem napisanym w~Javie przez Google.
 
\subsection{Instalacja i~hello world}
Hostowane jest to na Githubie.

Niby jest jakiś zbudowany release, ale jest to starsza wersja. Release okazuje się naprawdę być tylko spakowanymi źródłami. Dziwne i~wprowadzające w błąd.
Więc muszę ściągnąć najnowsze źródła, żeby mieć najnowsze funkcjonalności.
Wymaga to klienta Gita, ale nie jest to duży problem. 

Nie ma za bardzo instrukcji jak to zbudować. Są jakieś skrypy, ale są tylko pod Linuxa. Są w~readme jakieś fragmenty Mavena, sugerujące chyba co zrobić, w~zależności od tego, jaki build chce się uzyskać (wkleić je, pokazać, jak wygląda folder, może jakimś wydrukiem z command line). Ale nic nie jest jasne.
Jest też Mavenowy POM. Nie jestem doświadczony z Mavenem, ale spróbuję go zbudować. Ogólnie już duży minus -- muszę kombinować, żeby w ogóle to zbudować.

Najpierw zainstalowałem Mavena -- też nie automatyczny proces dla Windowsa, ale przebiega bez problemów. Build prostym poleceniem \texttt{mvn~clean~install}. Wydaje się, że działa.
Powstało wiele jarów.
Znowu nie ma jasnych informacji, ale wydaje się, że jest jeden (\texttt{jsonrpc-1.1.jar}), który zawiera całość biblioteki, czyli klienta i~serwer. Tego będę używał dalej. Są też wersje dedykowane dla serwera (\texttt{jsonrpc-1.1-server.jar}) i~dedykowane dla klienta (\texttt{jsonrpc-1.1-client.jar}). Część klas się zazębia.
Będę używał tego pełnego dla prostoty.

Ze zbudowaną biblioteką spróbujmy zbudować aplikację na Androida.

Coś nie widać do końca jak to hostowanie powinno wyglądać. Odpalę sobie taki przykładowy kod z~readme (ale nie będę używał Calculatora, a~jakiś swój interfejs i~implementację):
\begin{lstlisting}[frame=single, caption={Przykładowy sposób wystawiania serwera bez użycia serwletów}, label=code:bla]
private JsonRpcExecutor bind() {
   JsonRpcExecutor executor = new JsonRpcExecutor();

   Calculator calcImpl = new SimpleCalculatorImpl();
   executor.addHandler("calc", calcImpl, Calculator.class); 

   // add more services here

   return executor;
}
\end{lstlisting}

O... jednak nie ma żadnej implementacji serwera podstawowej. Olewam to.



\section{android-xml-rpc}
W jednym wątku na Google Groups \cite{android-rpc-thread} mówili, że niby zrobili serwer. I faktycznie na to wygląda.
Też na android-json-rpc(\url{https://code.google.com/p/android-json-rpc/}).



\section{WCF}
Potężny framework Web Serviceów od Microsoftu. Może posłużyć za wzór jak wszystko może działać. Może dość dynamicznie tworzyć hierarchie obiektów, które mogą funkcjonować jako usługi.

Można robić JSONa: \url{http://msdn.microsoft.com/en-us/library/system.runtime.serialization.json.datacontractjsonserializer.aspx}\\

Generowanie z JAX-WS przy pomocy wsdl toola nie do końca działało.

Opisać o co chodzi z tym polimorfizmem, że w WCF trzeba wypisywać KnownType, co jest robieniem wzajemnych zależności, co jest straszną praktyką programowania (źródło).

Napisać jak łatwo można zrobić to, co chcę mieć.



\section{JAX-WS}
Standardowy framework Javy do Web Serviceów. Podobne możliwości co WCF\@. Ja też niby chcę web service'y w Javie, ale na Androidzie, któremu JAX-WS został wycięty.
%Niestandardowe podejście z użyciem JSONa zamiast XMLa\url{http://jax-ws-commons.java.net/json/}\\

W JVM jest mały serwerek, który może hostować, można to też robić z jakiegoś Glassfisha albo innego serwera Javy EE\@. Podobnie ma WCF.

Co by trzeba było po kolei zrobić w normalnej javie żeby połączyć z~WCF? (tłumaczenia do xsd, ujednolicanie namespaców, mamy do czynienia z jakimiś ArrayOfString, dziedziczenie chyba słabo działa przy generacji, nie da się używać DataContractSerializera żeby nie serializować części klas ogólnie syf, ale wszystko udokumentować). 

Napisać jak łatwo można zrobić to, co chcę mieć.



\section{gSOAP}
Pozwala tworzyć i konsumować Web Servicey z poziomu niezależnej biblioteki C++. Może będzie działać na Androidzie?
\url{http://trac.e-technik.uni-rostock.de/projects/ws4d-gsoap/wiki/AndroidNDK}\\



\section{Thrift}
\url{http://thrift.apache.org/static/files/thrift-20070401.pdf}\\

Thrift is a software library and set of code-generation tools developed
at Facebook to expedite development and implementation of
efficient and scalable backend services. Its primary goal is to enable
efficient and reliable communication across programming languages
by abstracting the portions of each language that tend to
require the most customization into a common library that is implemented
in each language. Specifically, Thrift allows developers to
define datatypes and service interfaces in a single language-neutral
file and generate all the necessary code to build RPC clients and
servers.

%Też się z tym zgadzam i chciałbym, żeby tak w moim było
The same application code should be able to run against TCP stream sockets, raw data in memory, or files on disk.

Rozdzielony transport od serializacji, ale wsparte strumieniowanie.

Niestety nie można podłączać innych bibliotek.

Łatwe rozszerzanie istniejącego kodu też nie jest za bardzo możliwe, po dodaniu jakiś typów trzeba wszystko przegenerować (a w innych przypadkach trzeba dostarczyć nowe klasy na drugą stronę -- zawsze trzeba coś dodać).
Czy jest jakiś polimorfizm?

Daje możliwość zrobienia jednego kodu na dwie platformy.

Pozwala na asynchroniczność -- coś, czego nie przewidywałem dla mojej biblioteki, ale też może być przydatne.

Służy do robienia i klienta i serwera. Nie można np.\ zrobić serwera, do którego inni będą mogli wołać jakimś standardowym kanałem. Muszą mieć konkretny, wygenerowany kod klienta (no ewentualnie mogą zrobić swój kod korzystając z API Thrift). Moje może tak wyjść.

Ale może można zrobić serwer na Androidzie?

Jest polimorfizm?

\subsection{Testy}
\subsection{Wrażenia}
\subsubsection{Instalacja / Hello world}
\subsubsection{Przeprowadzanie testów}
\subsection{Podsumowanie}



\section{JSON-RPC.NET}
\url{https://github.com/Astn/JSON-RPC.NET} \\
Wygląda na ciekawą sprawę. JSON.NET, którego ta biblioteka używa ma chodzić nawet na Mono na Androidzie. Ten Json.NET ma JsonSchemę.

Tylko nie wiem, czy ma klienta.



\section{gSOAP}
Web Service'y i REST w C/C++. Pytanie, czy można posadzić serwer na Androidzie i połączyć z Javą.
Pewnie by się dało przez JNI, ale tłumaczenie danych pełne byłoby bolesne. I wołanie rzeczy w Androidzie.



\section{Jackson}
Konfigurowalna i dopracowana biblioteki do serializacji do JSONa. To może się przydać przy komponowaniu wywołań RPC.

Polimorfizm w Jacksonie:
\url{http://wiki.fasterxml.com/JacksonPolymorphicDeserialization}\\
\url{http://www.cowtowncoder.com/blog/archives/2010/03/entry_372.html}\\
\url{http://stackoverflow.com/questions/14454028/polymorphic-serialization-of-collections-with-custom-serializer-in-jackson}\\

Informacja o typach w Jacksonie:
\url{http://stackoverflow.com/questions/12350571/how-can-i-change-global-type-information-format-in-jackson}\\
%sprawdzić jak się wymienia ze wszystkim opisanym adnotacjami (dodać jeszcze rozszerzenie defaulttyperesolvera), wtedy sprawdzić mixed iny; lista objectów, na którą wpakuję stringi i inty

Jackson i .NET:
\url{http://stackoverflow.com/questions/8368873/deserialize-json-string-generated-from-net-using-jackson}\\

Ogólne:
\url{http://stackoverflow.com/questions/10329706/json-deserialization-into-another-class-hierarchy-using-jackson}\\
\url{http://wiki.fasterxml.com/JacksonHowToIgnoreUnknown}\\



\section{GSON}
Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.

Provide simple toJson() and fromJson() methods to convert Java objects to JSON and vice-versa
Allow pre-existing unmodifiable objects to be converted to and from JSON
Extensive support of Java Generics
Allow custom representations for objects
Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)



\section{Jakiś framework REST}



\section{Pyro}
Pythonowe, niby obiektowe. Ale dla pythona będzie łatwo uzyskać polimorfizm, bo nie ma ostrego typowania. Także może sobie luźno traktować XMLa lub JSONa.

\section{Spring}
Javowy framework web serviceów.

\url{http://forum.springsource.org/showthread.php?129058-Spring-Remoting-for-Android}\\


\section{I-jetty}
Serwer webowy dla Androida. Niby port Jetty. Może ma jakiś kontener Web-serviceów?

\section{Wrappery pythonowe}
Może zamiast równoważnych implementacji na pythona, C\# i javę zrobić tylko pythona i wrappery w jythonie i iron pythonie?


\section{Inne}
Chociaż wymienić pozostałe rozwiązania, które mogą być warte uwagi, choć raczej nie nadają się dla rozwiązania problemu tej pracy magisterskiej.

\subsection{Google Protocol Buffers}
\url{https://developers.google.com/protocol-buffers/docs/overview}
Podobne do Apache Thrift, ale źródła zamknięte. Od Googla. Służy do wyabstrachowania wiadomości (danych w nich zawartych) przesyłanych między częściami twojej aplikacji.
Nie ma tu mowy o serwisach jak w Thrifcie, tylko wiadomości, czyli właściwie dane.
Też jest generowanie do kilku języków i~jeden odmienny język wspólny, z którego robi się tę generację. Przez to podobne wady, jak Thrift.

Forma tekstowa przypomina JSONa.

\subsection{ZeroMQ}
\url{http://zguide.zeromq.org/page:all}
\url{http://stackoverflow.com/questions/8062212/difference-between-apache-thrift-and-zeromq}\\
ØMQ (also known as ZeroMQ, 0MQ, or zmq) looks like an embeddable networking library but acts like a concurrency framework. It gives you sockets that carry atomic messages across various transports like in-process, inter-process, TCP, and multicast. You can connect sockets N-to-N with patterns like fan-out, pub-sub, task distribution, and request-reply. It's fast enough to be the fabric for clustered products. Its asynchronous I/O model gives you scalable multicore applications, built as asynchronous message-processing tasks. It has a score of language APIs and runs on most operating systems. ØMQ is from iMatix and is LGPLv3 open source.

\subsection{Apache Avro}

\subsection{Restlet}
\url{http://restlet.org/learn/tutorial/2.1/#/docs_2.0/13-restlet/275-restlet/266-restlet.html}\\
Używa Jacksona, nieciekawy. Ale coś restowego by się przydało.

\subsection{Jakieś pythonowe}
WSME: \url{http://wsme.readthedocs.org/en/latest/}\\
Python EVE (Rest framework)\\

\subsection{Java to C\# itp.}
\url{http://sourceforge.net/projects/ikvm/}
\url{http://jni4net.com/} -- most, nie translator kodu, aktywnie utrzymywany \\
\url{http://sourceforge.net/projects/j2cstranslator/}\\
Przejście do schemy a~potem na inny kod może być alternatywą dla tych rzeczy.

\subsection{Jeśli chciałbym się bawić w schemy}
To może poszukać jakiś frameworków pozwalających oznakować klasy do serializacji (binding) do xmla albo jsona (a może nawet WSDL).
W końcu jak mamy schemę po obu stronach, to można przetłumaczyć z Javy do XMLa a dalej do C\# i z powrotem.

JiBX!!! Tworzenie klas ze schemy i robienie wsdl z javy\\
Wsdl2Java: tworzenie klas z wsdl, głównie chodzi o klasy danych\\

Generacja javovego kodu z bindingu:\\
XSD2Java – generuje kod java z xsd. Mocno niedorobione.\\

\url{http://stackoverflow.com/questions/6920175/how-to-generate-java-classes-from-wsdl-file}\\
\url{http://blog.tourgeek.com/2011/12/xml-data-binding-for-java-on-android.html}\\

\subsection{Jakieś serializacje}
\url{http://simple.sourceforge.net/}\\
\url{http://code.google.com/p/dbdroid-remoting/} - klient web serviców serializujący i deserializujący xmle\\

\subsection{Reszta}
Crest, Ksoap \\
\url{https://code.google.com/p/android-json-rpc/} -- bazuje na JSON-RPC, wspomaga w~robieniu klientów na Androida.\\
\url{http://software.dzhuvinov.com/json-rpc-2.0-server.html} -- też jakiś niby niezależny serwer. \\ 
\url{http://en.wikipedia.org/wiki/JSON-RPC#Implementations} -- cała lista implementacji JSON-RPC

%Może bez zborczej tabeli na końcu, a~tabelka na koniec każdego frameworku z tym jakie nadzieje (pod kontem użycia u mnie) spełnia?
%Albo taka tabela tych moich nadzei i w niej w rubryczkach powpisywane frameworki, które mogą je spełnić.

%Może przerzucić to na początek i uwzględnić więcej technologii? Takich pobierznie przejrzanych?
\section{Porównanie możliwości tych technologii}
Zestawienie ogólne -- czy można coś zrobić z tym na Androidzie, czy możliwe są metody polimorficzne (i jak z resztą poszukiwanych przeze mnie cech ze wstępu), jaka jest moja subiektywna ocena pracy z danym frameworkiem, jak ciężko się instaluje, na ile potrafią współpracować z innymi rozwiązaniami (jak bardzo trzymają się standardów).

%współpraca powinna być polem opisowym; powinny być dwa, na współpracę przewidywan przez twórców (albo jakąkolwiek) i na polimorficzną

\begin{table}[htbp]
	\centering
		\begin{tabular}{ | c || c | c | c | c | c | c |}
			\hline
				Technologia & Android & Hostowanie & Współpraca & Polimorfizm & Rozszerzalność & Prostota  \\
				\hline \hline
				WCF & & + & + & + & &\\
				\hline
				JAX-WS & & + & +/- & + & &\\
				\hline
				JSON-RPC & + & + & & & &\\
				\hline
		\end{tabular}
	\caption[Podsumowanie możliwości frameworków.]{Podsumowanie możliwości frameworków. ``+'' oznacza ``tak'', puste miejsce oznacza ``nie''. We współpracy chodzi o to, czy może współpracować z .NETem bez jakiś dedykowanych klientów.}
	\label{tab:frameworks-summary}
\end{table}

%podsekcje znowu będą trafiać do spisu treści
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

%powinienem dodać plik z licencjmi używanych bibliotek