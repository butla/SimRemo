%podsekcje nie trafią do spisu treści
\addtocontents{toc}{\protect\setcounter{tocdepth}{1}}

\chapter{Pokrewne technologie}
\label{similar-technologies}
W~tym rozdziale przeanalizuję technologie, które według mnie są powiązane z~projektem tworzonym w~niniejszej pracy.
Wśród nich będę szukał takich, które mogę wkomponować w~moje rozwiązanie.

\section{Metoda analizy technologii}
Będą one poddane testom, które sprawdzą obecność pożądanych przeze mnie cech (opisanych w~punkcie~\ref{lib-requirements}).
Niektóre własności, takie jak np.\ łatwość instalacji będą poddane bardziej subiektywnej ocenie.
Nie wszystkie testowane kryteria będą dotyczyć wszystkich technologii, ponieważ te należą do różnych dziedzin.
Testy przedstawione są w~tabeli~\ref{tab:frameworks-criteria}.

\begin{table}[htbp]
	\centering
		\begin{tabular}{ | c | c | p{8cm} |}
			\hline
				\textbf{Nazwa} & \textbf{Dziedzina} & \textbf{Opis}\\
				\hline \hline
				Klasyfikacja & Ogólna & Czym dana technologia jest, co potrafi (z mojej dziedziny zainteresowania)? Czy tłumaczy kod, czy serializuje, czy może być klientem RPC, czy może być serwerem RPC? Poza tym, do których dziedzin z~tej tabeli się zalicza? Czy jej kod jest otwarty?\\
				\hline
				Docelowa platforma & Ogólna & Czy technologia działa na platformie docelowej (Android, .NET)? Której?\\
				\hline
				Łatwość instalacji & Ogólna & Na ile intuicyjne i mało czasochłonne jest zinstalowane danego narzędzia/biblioteki? Na ile łatwo można go użyć, żeby zweryfikować, że działa?  Wyznacznik użyteczności.\\
				\hline
				Łatwość użycia & Ogólna & Dotyczy bardziej sensownego wykorzystania technologii. U mnie to będzie przedstawiać jak trudno było wykonać testy polimorfizmu. Wyznacznik użyteczności.\\
				\hline
				Zgodność & Ogólna & Z~jakimi technologiami dany projekt projekt może współpracować? Na jakich zasadach? Jeśli projekt jest klientem/serwerem RPC to z~jakimi klientami/serwerami może działać? Jak (czy w~ogóle?) to się zmienia po wymuszeniu polimorfizmu? \\
				\hline
				%Może to nazwać Zewnętrzne moduły
				Zewnętrzne moduły & Ogólna & Czy można do danej technologii podpiąć, albo wykorzystać z~nią jakieś istniejące biblioteki napisane na tę samą platformę? Np. dla technologii Javowych -- Jary.\\
				\hline
				%Może to nazwać rozszerzalność?
				Rozszerzalność & RPC & Czy można do serwera i~klienta dodać moduł, np. z~nowymi klasami danych dziedziczącymi istniejące i~używać ich ze starymi metodami?\\
				\hline
				Integracja z~Androidem & RPC & Dotyczy serwerów RPC na Androida. Czy można na zewnątrz wystawić możliwość komunikacji z systemem operacyjnym? Np.\ uruchamianie innych aplikacji?\\
				\hline
				Polimorfizm metod & RPC & Czy zdalne metody mogą być przeładowywane?\\
				\hline
				Polimorfizm danych & Serializacja, RPC & Sprowadza się do zachowania informacji o~typach w~serializowanych danych. Sprawdzane przez serializację i~deserializację jednego obiektu (TestDataB widocznego jako TestDataA) a~następnie sprawdzenie, czy jest taki sam.\\
				\hline
				Tłumaczenie kodu & Tłumaczenie kodu & Jeśli dany projekt pozwala na generację kodu w~jednym języku na bazie kodu w~innym, to w~jaki sposób to robi? Czy umożliwia przekładanie z~Javy na C\# lub odwrotnie? \\
				\hline
		\end{tabular}
	\caption[Kryteria oceny technologii.]{Kryteria oceny technologii.}
	\label{tab:frameworks-criteria}
\end{table}

Większość testów wykonywana będzie na systemie Windows 7 Professional x64.
Te, które będą tego wymagać będą uruchamiane na emulowanym (w~Windowsie) Androidzie 4.4.2, który szerzej jest opisany w~punkcie~\ref{system-configuration}.


\subsection{Dane do testów polimorfizmu}
W~testach polimorfizmu będą brały dwie klasy danych. Obie są zapisane w~Javie, we fragmencie~\ref{code:testData}, chociaż ich odpowiedniki będą tworzone też w~innych językach. Posiadają one domyślne wartości pól, które będą przydatne w~trakcie weryfikacji wyników testów. Wszystkie dalsze pseudokody będą zbliżone do Javy.

\begin{lstlisting}[float, frame=single, caption={Testowe klasy danych; jedna dziedzicząca drugą.}, label=code:testData]
public class DaneA
{
	public int liczbaA = 13;
	public string tekstA = "cokolwiek";
}

public class DaneB extends DaneA
{
	public double liczbaB = 5.25;
}
\end{lstlisting}


\subsection{Testowanie serializacji}
W~przypadku samej serializacji będzie tylko jeden test, operujący na jednym obiekcie danych -- generycznej tablicy zawierającej obiekty różnego typu.
Sposób jej tworzenia został opisany we fragmencie kodu \ref{code:testArray}.
Test sprawdza, czy informacja o~typach obiektu przeżywa serializację.
Jest to niezbędne aby uzyskać polimorfizm parametrów zdalnych metod.
Właściwe kroki testu:
\begin{enumerate}
	\item Serializacja obiektu (w sumie powinno się go serializować w jakimś kontekście).
	\item Stworzenie nowego obiektu przez deserializację zapisu pierwszego obiektu.
	\item Porównanie nowego i~odtworzonego obiektu. Oba powinny być identyczne pod względem typu i~zawartości.
\end{enumerate}

\begin{lstlisting}[frame=single, caption={Tablica obiektów różnych typów służąca do sprawdzenia, czy informacja o~typie zostaje zachowana.}, label=code:testArray]
Object[] testowaTablica =
		new Object[]{28, "tekst", new DaneA(), new DaneB()};
\end{lstlisting}

\subsection{Testowanie polimorfizmu metod zdalnych}
Testy polimorfizmu metod zdalnych będą weryfikować trzy rzeczy.
\begin{enumerate}
	\item Czy metoda potrafi poprawnie zidentyfikować argument typu dziędziczącego typ spodziewany?
	\item Czy można przeciążać zdalne metody?
	\item Czy dane wchodzące i~wychodzące z~metody są poprawnie serializowane i~deserializowane?
\end{enumerate}

Odpowiedzialne za tę weryfikacje będą testy polegające na stworzeniu zdalnych metod przy pomocy sprawdzanego narzędzia i~próby ich wywołania.
Nawet jeśli metoda się wykona, to mogła nie zwrócić odpowiedniego wyniku, dlatego go też trzeba będzie weryfikować.
Tym testom będą podlegać tylko biblioteki, którą pozwalają tworzyć lub konsumować zdalne metody.
Kody klasy zawierającej testowe zdalne metody (zwanej też serwisem) oraz jej interfejsu znajdują się we fragmencie~\ref{code:testService}

\begin{lstlisting}[float, frame=single, caption={Przykładowa zdalna metoda testowana pod kątem polimorfizmu}, label=code:testService]
public interface ITestowySerwis
{
    String testPodstawowy();
    String testPodstawowy(String argument);    
    DaneA testPolimorfizmuA(DaneA testowyObiekt);    
    Object[] testPolimorfizmuB(Object[] testowaTablica);
}

public class TestowySerwis implements ITestowySerwis
{
    String testPodstawowy()
    {
        return "Dziala!";
    }
        
    String testPodstawowy(String argument)
    {
        return "Dostalem " + argument;
    }
    
    DaneA testPolimorfizmuA(DaneA testowyObiekt)
    {
        testowyObiekt.liczbaA += 1;
        testowyObiekt.tekstA += " cos dodano!";
        return testowyObiekt;
    }
    
    Object[] testPolimorfizmuB(Object[] testowaTablica)
    {
        int dlugoscTablicy = testowaTablica.length;
        Object[] nowaTablica = new Object[dlugoscTablicy+1];
        for(int i = 0; i < dlugoscTablicy; i++)
        {
            nowaTablic[i] = testowaTablica[i];
        }
        nowaTablica[dlugoscTablicy] = 3.14;
    }
}
\end{lstlisting}

\subsection{Testowanie tłumaczenia danych}
\begin{enumerate}
	\item Przetłumaczenie klasy zawierającej podstawowe typy, listy, tablicy, mapy, jakąś inną klasę, domyślne wartości.
	\item Przetłumaczenie prostej metody. To nie jest priorytetem, ponieważ głównie zależy mi na tłumaczenia klas danych, które będą służyć za argumenty metod zdalnych.
\end{enumerate}



\section{Jackson}
\label{jackson}
Jackson to zestaw narzędzi do przetwarzania danych stworzony dla Javy (i~platformy JVM).
Wspiera wiele kodowań: JSON, Avro, CBOR, CSV, Smile, XML i~YAML.
Najbardziej znany jego komponent to biblioteka do parsowania i~generacji danych w~formacie JSON.
Można jej używać jako narzędzia do serializacji i~deserializacji obiektów.
Spośród całego zastawu przyglądał się będę tylko jej.
Więcej informacji na temat Jacksona można znaleźć na jego oficjalnej stronie w~serwisie Github: \url{https://github.com/FasterXML/jackson}.

\subsection{Ocena}

\begin{description}
\itemtitle{Klasyfikacja}
Serializator JSON pod Javę. Otwarty kod.

\itemtitle{Docelowa platforma}
Działa na Androidzie. Skierowane pod maszynę wirtualną Javy (JVM).

\itemtitle{Łatwość instalacji}
Instalacja łatwa, ale nie banalna.
Wymaga odnalezienia się pośród kilku przestarzałych stron, zawierających sprzeczne informacje.
Na właściwej stronie głównej, potrzebne biblioteki mogłyby być wyraźniej wskazane.
To, że wszystko narzędzie jest do pobrania z~Githuba może być odebrane dwojako; z~jednej strony trzeba się z~nim przez chwilę zaznajomić, z~drugiej, jest to popularna platforma standaryzująca dystrybucję wielu bibliotek i~dla niektórych może być bardziej intuicyjna niż osobna, unikatowa strona domowa projektu.

\itemtitle{Łatwość użycia}
Sensowne i łatwe, ale może nie oczywiste. Niektóre bardziej zaawansowane cechy, np. zmiana stylu oznaczania typów słabo udokumentowana.

\itemtitle{Zgodność}
JSON jest powszechnym standardem, a~Jackson się do niego stosuje.
Co prawda, JSON nie przewiduje zawierania informacji o~typach.
Jackson musi robić to na własną rękę, dodając informację o~typach do zapisywanych grafów. Oczywiście, musi być w~stanie także je odczytać.
Jednak styl oznaczania typów jest konfigurowalny, dlatego teoretycznie można go dopasować do innego stylu oznaczeń, np.\ tego stosowanego przez klasę \texttt{DataContractJsonSerializer} z~.NET\@.
To pozwalałoby na używanie różnych silników serializacyjnych po obu stronach kanału komunikacyjnego, jednocześnie zachowując informację o~typach.

\itemtitle{Zewnętrzne moduły}
Można serializować i~deserializować klasy wzięte z~zewnętrznych bibliotek.

%Może jakaś sekcja ze spostrzeżeniami albo każda z tych ocen jako osobne subsubsection?
\itemtitle{Polimorfizm danych}
Jest. Realizowany przy pomocy wpisywania dodatkowych danych o~typach wtedy, gdy nie wynika on jasno z~kontekstu\footnote{Faktycznie to jedno z~możliwych ustawień. Generalnie można konfigurować kiedy ma być dodawana informacja o~typach.}.
Sposób wpisywania tej informacji może być konfigurowany.
Jednym sposobem jest dodanie do obiektu specjalnego pola; jak we fragmencie kodu~\ref{code:typeInfoField}, gdzie obiekt typu DaneB był w~kontekście sugerującym DaneA i~musiało to być oznaczone.
Innym sposobem jest owinięcie obiektu w~tablicę i~dodanie nazwy typu jako jej pierwszy element, jak w~kodzie~\ref{code:typeInfoArray}.
Zastrzeżeniem jest serializacja tablic -- w~tym przypadku można to zrobić tylko przez owijanie w~kolejną tablicę.

Trzeba zaznaczyć, że dodawanie informacji o~typach nie jest zachowaniem domyślnym. Aby to osiągnąć należy odpowiednio skonfigurować klasę odpowiedzialną za serializację i~deserializację (\texttt{ObjectMapper}) lub dodać adnotację \texttt{JsonTypeInfo} do konkretnego typu danych (przykład na fragmencie~\ref{code:typeInfoAnnotation}). Wszystkie klasy dziedziczącej po klasie z~\texttt{JsonTypeInfo} będą, w~przypadku serializacji, opisywane w~analogiczny sposób.

\begin{lstlisting}[float, frame=single, caption={Oznaczanie typu przez dodatkowe pole.}, label=code:typeInfoField]
{
    "@class":"test.DaneB",
    "liczbaA":13,
    "tekstA":"domyslny",
    "liczbaB":5.25
}
\end{lstlisting}

\begin{lstlisting}[float, frame=single, caption={Oznaczanie typu przez owinięcie w~tablicę i~dodanie do niej elementu.}, label=code:typeInfoArray]
{
    [
        "test.DaneB",
        {
            "liczbaA":13,
            "tekstA":"domyslny",
            "liczbaB":5.25
        }
    ]
}
\end{lstlisting}

\begin{lstlisting}[float, frame=single, caption={Parametryzacja przekazywania informacji o~typie w~definicji klasy.}, label=code:typeInfoAnnotation]
@JsonTypeInfo(
    use=JsonTypeInfo.Id.CLASS,
    include=JsonTypeInfo.As.PROPERTY,
    property="@class")
public class DaneA
{
    ...
\end{lstlisting}
\end{description}

\subsection{Podsumowanie}
Jackson to solidna i~konfigurowalna biblioteka serializacyjna dla Javy, dodatkowo działająca na Androidzie.
Dlatego ma dużą szansę na wykorzystanie w~Androidowej części mojego projektu.

%Polimorfizm w Jacksonie:
%\url{http://wiki.fasterxml.com/JacksonPolymorphicDeserialization}\\
%\url{http://www.cowtowncoder.com/blog/archives/2010/03/entry_372.html}\\
%\url{http://stackoverflow.com/questions/14454028/polymorphic-serialization-of-collections-with-custom-serializer-in-jackson}\\
%
%Informacja o typach w Jacksonie:
%\url{http://stackoverflow.com/questions/12350571/how-can-i-change-global-type-information-format-in-jackson}\\
%%sprawdzić jak się wymienia ze wszystkim opisanym adnotacjami (dodać jeszcze rozszerzenie defaulttyperesolvera), wtedy sprawdzić mixed iny; lista objectów, na którą wpakuję stringi i inty
%
%Jackson i .NET:
%\url{http://stackoverflow.com/questions/8368873/deserialize-json-string-generated-from-net-using-jackson}\\
%
%Ogólne:
%\url{http://stackoverflow.com/questions/10329706/json-deserialization-into-another-class-hierarchy-using-jackson}\\
%\url{http://wiki.fasterxml.com/JacksonHowToIgnoreUnknown}\\



\section{JSON-RPC for Java (jsonrpc4j)}
Biblioteko umożliwiająca łatwą implementacji standardu JSON-RPC 2.0 w~języku Java.
jsonrpc4j używa biblioteki Jackson do konwersji pomiędzy obiektami Javy a~dokumentami JSONa oraz do innych czynności związanych z~JSON-RPC.
Umożliwia wywoływanie zdalnych metod nie tylko przez HTTP, ale też przez sockety TCP.
Informacje na jego temat oraz jego kod źródłowy dostępne są na jego oficjalnej stronie w~serwisie Github: \url{https://github.com/briandilley/jsonrpc4j}

\subsection{Ocena}

\begin{description}
\itemtitle{Klasyfikacja}
Klient i~serwer RPC. Otwarty kod. Serializacja dostarczana przez zewnętrzną bibliotekę -- Jackson.

\itemtitle{Docelowa platforma}
Java SE.
Teoretycznie na Androidzie powinien działać zarówno klient jak i~serwer (taka informacja znajduje się w~README).
Tak jednak nie jest, a~to dlatego, że biblioteka zawiera referencje do klas z~klasycznej wersji Javy (w~tym Javy EE).
Standardowe środowisko deweloperskie (Eclipse z~wtyczką ADT) do aplikacji na Androida wykrywa to jako znany błąd.

\itemtitle{Łatwość instalacji}
Instalacja średnio skomplikowana.
Bibliotekę trzeba ściągnąć w~formie kodu (używając Gita lub ściągając paczkę), a~następnie zbudować korzystając z~narzędzia Maven.
Nie wszyscy mają na swoich systemach Mavena, a~jego instalacja także wymaga kilku czynności (co prawda nieskomplikowanych).

Napisanego pierwszego programu nie uda się najprawdopodobniej uruchomić za pierwszym razem, z~powodu braku niektórych klas.
Należy czytać błędy, dedukować jakich bibliotek brakuje po pełnych nazwach klas, a~następnie ściągać i~dodawać te biblioteki do programu.
Biblioteki, których brakuje to trzon Jacksona (\texttt{jackson-core}, \texttt{jackson-databind}, \texttt{jackson-annotations}) oraz \texttt{javax.servlet-api}.

\itemtitle{Łatwość użycia}
Użycie jest łatwe. Kod jest logicznie ustrukturalizowany i~elastyczny.
Dobrze rozdzielone są warstwy tłumacząca dane i~komunikacyjna.
Na głównej stronie projektu można znaleźć przykłady, dzięki którym można szybko rozpocząć pracę.

Przeprowadziłem testy wzorując się na najprostszym przykładzie niekorzystającym z~frameworku Spring, wykorzystując klasę \texttt{StreamServer}.
W~moim zastosowaniu zarówno klient jak i~serwer działały lokalnie na jednej maszynie. Dodatkowo, serwer musiał być niezależną aplikacją niekorzystającą z~kontenera Javy EE\footnote{Przykładem takiego kontenera mogą być Glassfish lub serwer Apache.}.
Takiego przypadku nie było w~przykładach, ale dzięki sensownej strukturze biblioteki szybko rozwiązałem mój problem odpowiednio konfigurując klasy.0

Nie da się, niestety, tak skonfigurować ,,serwera strumieniowego''(\texttt{StreamServer}), żeby działał w~jednym procesie na strumieniach w~pamięci. Trzeba użyć socketów. Nie jest to duży problem, ale wymaga większej finezji przy przechwytywaniu wiadomości w~celu analizy. Chociaż warto znowu pochwalić budowę biblioteki za to, że takie przechwytywanie jest w~ogóle możliwe.

%Można jeszcze zaznaczyć, że wersja Jacksona, którą ściąga Maven w~trakcie budowania tego projektu, ma błąd w~domyślnym typowaniu korzystając z metody valueToTree (można używać innej, która działa). Trzeba ściągnąć nowszą.

\itemtitle{Zgodność}
Jest zgodność ze standardem JSON-RPC 2.0. Ale standard ten nie mówi nic o~danych zawierających dodatkowe informacje o typach.
Dlatego zgodność z~drugą stroną możliwa jest tylko w~przypadku analogicznie skonfigurowanej warstwy serializacyjnej (więcej informacji w~punkcie~\ref{jackson}).

\itemtitle{Zewnętrzne moduły}
Można używać klas z~zewnętrznych bibliotek jako danych w~metodach zdalnych, można też wystawiać je jako serwisy (obiekty wystawiające na zewnątrz zdalne metody).

\itemtitle{Rozszerzalność}
Jest -- można dodać nowe klasy dziedziczące po argumentach zdalnej metody i~ta metoda może je obsługiwać. Nie wymaga to żadnych zmian w~kodzie samej metody. Nowe klasy muszą się znaleźć na kliencie i~na serwerze.

\itemtitle{Integracja z Androidem}
Nie ma, ponieważ serwer nie działa na Androidzie. Gdyby jednak działał, to jako aplikacja Javowa nie miałby żadnych przeszkód w~komunikowaniu się z~systemem.

\itemtitle{Polimorfizm metod}
Jest.

\itemtitle{Polimorfizm danych}
Jest. Zależny od Jacksona, można odnieść się do jego opisu w~punkcie~\ref{jackson}.
\end{description}

\subsection{Podsumowanie}
Ta biblioteka to poważny kandydat na wykorzystanie w~moim projekcie.
Jest kompletna, zrozumiała i~łatwa w~użyciu.
Może też współpracować z~klientem JSON-RPC w~.NET, którego serializator będzie tak samo skonfigurowany, jak Jackson po stronie Androida.
Niestety, mimo obietnicy twórcy, nie można na Androidzie stworzyć serwera\footnote{Zgłosiłem ten problem na oficjalnej stronie.}, ale zdaje się, że można by to naprawić przez wycięcie fragmentów kodu, które i~tak nie są potrzebne w~moim scenariuszu użycia.

%Ok, prosty test z przekazaniem dziedziczącego argumentu wywala się z~uwagi na nierozpoznanie dodatkowego pola parametru. Nie wie, że to inny typ.
%%{"id":"3199114083297069103","jsonrpc":"2.0","method":"testDataA","params":[{"numberA":13,"stringA":"domyslny","numberB":5.25}]}
%%Unrecognized field "numberB" (class jsonrpc4jtestse.TestDataA), not marked as ignorable (2 known properties: , "numberA", "stringA"])

%Readme nic o~tym nie mówi, dokumentacji nie ma. Ale w~błędzie jackson, więc trzeba się udać do Jacksona.
%Najwyraźniej potrzeba dodatkowych informacji, żeby serializacja mogła się udać. Z~pomocą przychodzi funkcja oznaczania typów obiektów we wiadomości\cite{jackson-polymorphic}.
%Nawet mimo tego są jakieś problemy... Robi się to irytujące.
%Używa valueToTree zamiast po prostu write i~przez to nie chce przejść z~oznaczaniem typów.

%A po dodaniu do klasy głównej danych znacznika nakazującego oznaczenie typów wszystko działa.
%%{"id":"4653019993893876656","jsonrpc":"2.0","method":"testDataA","params":[{"@class":"jsonrpc4jtestse.TestDataB","numberA":13,"stringA":"domyslny","numberB":5.25}]}
%%{"jsonrpc":"2.0","id":"4653019993893876656","result":{"@class":"jsonrpc4jtestse.TestDataB","numberA":14,"stringA":"domyslny dodałem coś!","numberB":5.25}}
%Wraca obiekt o poprawnym typie. Bez ustawiania czegokolwiek w~Mapperach.
%Dodanie jednego znacznika do głównej klasy w~hierarchii nie jest straszne, ale sprawdźmy jeszcze domyślne typowanie z~najnowszą wersją Jacksona (bo do jsonrpc4j zrobiła się jakaś 2.0.2).
%Z wersją 2.4.2, działa teraz bez oznaczeń na klasie. Ale za to trzeba i~serwer, i~klienta stworzyć z~ObjectMapperem, w~którym włączy się enableDefaultTyping(). W moim przypadku było to
%%mapper.enableDefaultTyping(
                %%ObjectMapper.DefaultTyping.NON_FINAL,
                %%JsonTypeInfo.As.PROPERTY);
%Które dodaje informację o~klasie jako dodatkowe pole obiektu (\emph{property}), przy wszystkich obiektach, które nie są oznaczone jako final (takie, po których się nie da dziedziczyć).
%%{"id":"-6659082740394205036","jsonrpc":"2.0","method":"testDataA","params":[{"@class":"jsonrpc4jtestse.TestDataB","numberA":13,"stringA":"domyslny","numberB":5.25}]}
%Wygląda tak samo, jak przy oznaczaniu w~klasie.



\section{Xamarin}
\subsection{Opis}
Xamarin jest środowiskiem do tworzenia aplikacji mobilnych na platformy Android, iOS i~Windows\cite{xamarin-overview}.
Pozwala na stworzenie jednego kodu w~C\#z~którego może powstać aplikacja na dowolny z~wcześniej wymienionych systemów. Tylko nieznaczna część aplikacji musi być świadoma, a~zatem zależna od systemu operacyjnego.
Twórcy twierdzą, że C\# jest najlepszym językiem do tworzenia aplikacji mobilnych, posiadając cechy takie jak lekkość składni, silne typowanie, operacje asynchroniczne, czy wyrażenia lambda\footnote{Dostępne dopiero w~Javie 8\cite{java-8-features}, podczas gdy Android ma co najwyżej 7\cite{android-java-7}} .

Na korzyść Xamarina może przemawiać to, że znalazł użytek wśród znanych organizacji, takich jak Bosch, Github czy Dow Jones\cite{xamarin-overview}.
Ponadto, jego twórcy współpracują z~Microsoftem.

%\url{http://docs.xamarin.com/guides/cross-platform/application_fundamentals/web_services/}\\

\subsection{Ocena}

\begin{description}
\itemtitle{Klasyfikacja}
Jest to port platformy .NET, a~więc powinien zapewniać, m.in.\ możliwość serializacji, tworzenia i~konsumowania zdalnych metod.
Kod źródłowy nie jest dostępny.

\itemtitle{Docelowa platforma}
Android, iOS i~mobilne wersje Windows. W~tej analizie skupiam się tylko na Androidzie. 

\itemtitle{Łatwość instalacji}
Instalacja banalna. Instalator ściąga się z~głównej strony projektu (czyli źródła~\cite{xamarin-overview}).
Jedyne wyzwanie to stworzenie odpowiedniej wirtualnej maszyny (AVD, \emph{Android Virtual Device}) pod emulator Androida.
Instalacja wymaga także podania swoich danych osobowych.

Na pochwałę zasługuje sprytny instalator, który przeszukuje system i~tłumaczy dokładnie jakie elementy są potrzebne.
W~moim przypadku, kiedy miałem już zainstalowaną Javę 7 i~Android SDK, instalator wytłumaczył jakich elementów Android SDK mi brakuje i~dlaczego potrzebna jest konkretnie Java 6 , a~nie 7. Następnie (za moim pozwoleniem) doinstalował brakujące elementy.

\itemtitle{Łatwość użycia}
Użycie jest proste; bardzo intuicyjne dla kogoś, kto korzystał z~IDE takich jak Visual Studio, Netbeans itp.

Jedyny zgrzyt był w~tym, że moja testowa aplikacja nie chciała się uruchomić, ponieważ rzekomo mój emulator był w~za starej wersji Androida.
Aplikacja domyślnie budowała się najnowszą dostępną wersję Androida. Można było jednak wybrać też wersję ręcznie z~listy. Najwyżej znajdowała się najnowsza wersja -- 4.4 -- taka sama, jak na moim emulatorze. Jednak wybranie ręczne tej opcji poskutkowało, aplikacja wgrała się na emulator i~uruchomiła. Według mnie przyczyną tego zachowania było to, że najnowsza wersja środowiska dostępna dla mojego Android SDK to 4.4W (jeden poziom API wyżej niż Android 4.4). Najwyraźniej Xamarin automatycznie wybierał 4.4W, jednak nie wyświetlał go jako osobnej opcji. Takie zachowanie środowiska mogłoby speszyć programistów niedoświadczonych w~pracy z~Androidem.

\itemtitle{Zgodność}
Xamarin jako platforma ma takie same możliwości co pewien podzbiór .NET\@. Dzięki odpowiednim \emph{wrapperom} ma też dostęp do najnowszym wersjom API Androida.

Wykonywanie kodu po stronie Androida odbywa się dzięki silnikowi Mono\footnote{O~którym była już mowa w~rozdziale \ref{android}}\cite{xamarin-android-arch}.
Podobnie jak przy użyciu Mono\cite{mono-compatibility}, nie można korzystać z~pełni możliwości .NET\cite{xamarin-dot-net}.
Faktyczny zakres wspieranych bibliotek .NET jest zbliżony do tych, które są wspierane w~technologii Silverlight, czyli około .NET 3.5 (czasami wyżej).
Mono nie umożliwia też tworzenia serwerów WCF (silnik RPC), może tylko działać jako klient. Nawet to nie jest do końca dopracowane, stoi na poziomie alfa.

Skoro aplikacja na Androidzie działa w~środowisku .NET, to teoretycznie wymiana danych (w~sensie zserializowanych obiektów) z~inną aplikacją .NET na PC powinna być łatwa, podobnie jak w~przypadku JVM na różnych platformach. Tak jednak nie jest.
Pod Mono, standardowe narzędzia serializacyjne .NET (serializacja do XML) nie działają w~pełni, a~dane serializowane binarnie nie dają się odczytać przez ,,duży'' .NET\@. Najprawdopodobniej różne wersje platformy mają po prostu inny binarny format obiektów.
Możliwe, że dałoby się uzyskać łatwą wymianę danych przez użycie po obu stronach (Mono i~,,duży'' .NET) jednej zewnętrznej biblioteki serializacyjnej

\itemtitle{\emph{Code reuse}}
Do aplikacji Androidowej tworzonej Xamarinem można podłączyć zewnętrzne biblioteki zarówno .NET, jak i~Javy.
W~obu przypadkach wymaga to jednak specjalnego przygotowania tychże bibliotek.
W~przypadku .NET trzeba dostać źródła, co nie zawsze jest możliwe, i~przekompilować Xamarinem\cite{xamarin-dot-net}.
Biblioteki Javowe trzeba owinąć kodem C\#, czyli stworzyć tzw.\ \emph{wrappery}\footnote{Dokładniej opisane pod adresem \url{http://developer.xamarin.com/guides/android/advanced_topics/java_integration_overview/binding_a_java_library_(.jar)/}}.

Ogólnie, wykorzystanie zewnętrznych bibliotek wymaga pracy i~nie zawsze może się udać, np.\ w~przypadku bibliotek .NET z~zamkniętym kodem.

\itemtitle{Modularność (taka rozszerzalność)}
Podobnie jak w~powyższym punkcie -- nie ma RPC, więc nie ma co o~tym pisać.

\itemtitle{Integracja z Androidem}
Aplikacja stworzona Xamarinem może komunikować się z~systemem Androida oraz z~innymi (też ,,normalnymi'', napisanymi w~Javie) aplikacjami działającymi w~systemie.

%W sumie chodzi o wyslanie intentu, to takie androidowe wiadomosci (źródło, z książki o androidzie).
%Dzięki nim aplikacje komunikują się z~systemem i~ze sobą nawzajem.
%Wysyłając intent można też uruchomić inną aplikację.
%Skoro odpalenie aplikacji działa, to działają intenty i~można zarządzać całym systemem (jeśli aplikacja ma odpowiednie prawa) (może w tej książce jest o tym).

\itemtitle{Polimorfizm metod}
Mono nie zawiera klas .NET odpowiedzialnych za tworzenie serwerów RPC, dlatego nie można nawet mówić o~polimorfizmie zdalnych metod.
Nie wyklucza to jednak tego, że na Androidzie z~Mono można uruchomić jakąś zewnętrzną bibliotekę .NET posiadającą takie możliwości.

\itemtitle{Polimorfizm danych}
Nie spełnia moich oczekiwań.
Podstawowa serializacja .NETa (korzystjąca z~klasy \texttt{DataContractSerializer}) jest ograniczona i~nie pozwala na zachowanie pełni danych o~typach w~przypadku tablic (więcej o~tym poniżej).
Obiekty zserializowane binarnie (używając klasy \texttt{BinaryFormatter}) zachowują informację o~typach, ale nie mogą być odtworzone na innej platformie, np.\ desktopowym .NET\@. 

W~przypadku serializacji testowej tablicy\footnote{Obiekt \texttt{DataContractSerializer} stworzony dla typu \texttt{DaneA}, dodatkowo został ,,nauczony'' typów \texttt{DaneB} i~\texttt{object[]}.} wszystko wydaje się być w~porządku. Dokument, który powstaje znajduje się we fragmencie~\ref{code:xamrinArray}. Udaje się go nawet zdeserializować, ale obiekt, który powstaje nie ma sensu. Zamiast tablicy powstaje obiekt typu \texttt{DaneA} (podstawowy typ serilizatora), który zamiast domyślnych wartości ma 0 i~\texttt{null}.

W~przypadku standardowej, poprawnie działającej serializacji dostaniemy podobnie wyglądający, a~nawet trochę lżejszy zapis (widoczny we fragmencie~\ref{code:dotNetArray}).
Serializator na Androidzie rzuci wyjątek, jeśli każe mu się zdeserializować ten zapis.
Można zauważyć, że główny element w~drugim (\ref{code:dotNetArray}) fragmencie zawiera oznaczenie typu -- \texttt{i:type="a:ArrayOfanyType"}, podczas gdy pierwszy go nie posiada. Przez to tablica na Androidzie jest  deserializowana jako obiekt typu \texttt{DaneA}.

Mono potrafi sobie jednak poradzić z~oznaczeniem i~odszyfrowaniem pojedynczego obiektu. Sprawdziłem to podając serializatorowi spodziewającemu się obiektu typu \texttt{DaneA} obiekt typu \texttt{DaneB}\footnote{Między innymi w~takiej sytuacji \texttt{DataContractSerializer} dodaje informację o~typie.} -- odtworzony obiekt był identyczny.

.NET posiada też standardowy serializator/deserializator JSON -- \texttt{DataContractJsonSerializer}.
W~przeciwieństwie do tego, jak działa on na standardowym .NET, na Mono nie zachowuje on informacji o~typie.
Przy konfiguracji obiektu \texttt{DataContractJsonSerializer} wymuszającej zawieranie tej informacji, próba serializacji owocuje rzuceniem mało mówiącego wyjątku o~treści ,,\texttt{There was an error during serialization for object of type XamarinTest.DaneB}''.

\begin{lstlisting}[float, caption={Testowa tablica zserializowana przez \texttt{DataContractSerializer} pod Mono.}, label=code:xamrinArray]
<DaneA xmlns:i="http://www.w3.org/2001/XMLSchema-instance"
    xmlns="http://schemas.datacontract.org/2004/07/XamarinTest">
  
  <anyType xmlns:d2p1="http://www.w3.org/2001/XMLSchema"
      i:type="d2p1:int"
      xmlns="http://schemas.microsoft.com/2003/10/Serialization/Arrays">
    28
  </anyType>
  
  <anyType xmlns:d2p1="http://www.w3.org/2001/XMLSchema"
      i:type="d2p1:string"
      xmlns="http://schemas.microsoft.com/2003/10/Serialization/Arrays">
    jakis tekst
  </anyType>
  
  <anyType xmlns:d2p1="http://schemas.datacontract.org/2004/07/XamarinTest"
      i:type="d2p1:DaneA"
      xmlns="http://schemas.microsoft.com/2003/10/Serialization/Arrays">
    <d2p1:numberA>13</d2p1:numberA>
    <d2p1:stringA>domyslny</d2p1:stringA>
  </anyType>
  
  <anyType xmlns:d2p1="http://schemas.datacontract.org/2004/07/XamarinTest"
      i:type="d2p1:DaneB"
      xmlns="http://schemas.microsoft.com/2003/10/Serialization/Arrays">
    <d2p1:numberA>13</d2p1:numberA>
    <d2p1:numberB>5.25</d2p1:numberB>
    <d2p1:stringA>domyslny</d2p1:stringA>
  </anyType>
</DaneA>
\end{lstlisting}

\begin{lstlisting}[float, caption={Testowa tablica zserializowana przez \texttt{DataContractSerializer} pod .NET 4.5.}, label=code:dotNetArray]
<DaneA i:type="a:ArrayOfanyType"
    xmlns="http://schemas.datacontract.org/2004/07/CSharpTest"
    xmlns:i="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:a="http://schemas.microsoft.com/2003/10/Serialization/Arrays">
    
  <a:anyType i:type="b:int"
      xmlns:b="http://www.w3.org/2001/XMLSchema">
    28
  </a:anyType>
  
  <a:anyType i:type="b:string"
      xmlns:b="http://www.w3.org/2001/XMLSchema">
    jakis tekst
  </a:anyType>
  
  <a:anyType i:type="DaneA">
    <numberA>13</numberA>
    <stringA>domyslny</stringA>
  </a:anyType>
  
  <a:anyType i:type="DaneB">
    <numberA>13</numberA>
    <stringA>domyslny</stringA>
    <numberB>5.25</numberB>
  </a:anyType>
</DaneA>
\end{lstlisting}

\end{description}

\subsection{Podsumowanie}
Wydaje się, że cały projekt jest dynamicznie rozwijany i~cieszy się wsparciem kilku ,,poważnych graczy''. To może mu wróżyć dalszy rozwój i~stopniową likwidację problemów.
Twórcy inwestują w~komunikację z~użytkownikiem-programistą i~ogólne wrażenie z~pracy z~Xamarinem jest bardzo pozytywne.
Na pewno ma duże możliwości, jeśli o~tworzenie aplikacji mobilnych.
Ma też ciekawe techniki generowania \emph{wrapperów} na biblioteki Javowe, które może są warte uwagi nawet w~oderwaniu od reszty środowiska.

Niestety podzbiór .NET wspierany przez Mono na Androidzie nie wystarczy na tworzenie serwerów RPC, czy na serializację danych pod kątem wykorzystania w~polimorficznych zdalnych metodach. Teoretycznie, jakaś zewnętrzna biblioteka .NET mogłaby w~tym pomóc.
Współpraca z~zewnętrznymi bibliotekami, mimo, że z~założenia możliwa, wymaga wysiłku.

%\subsection{Instalacja i~hello world}
%Tworzę projekt Androidowy.
%Ponieważ miałem już stworzone AVD\footnote{O~emulatorze piszę w~punkcie~\ref{android-emulator}} widzę je już do wyboru do odpalenia.
%Może trzeba mieć doświadczenie z~emulatorem minimalne. Żeby wiedzieć, że jest osobna aplikacja zarządzająca nim.
%Po prostu odpalam Run na świeżo uruchomionym projkecie.
%
%Musi się zainstalować jeszcze Mono, żeby aplikacja mogła działać. Dzieje się to automatycznie.
%Oj... odpalenie nie powiodło się, bo rzekomo mój Android nie jest w~wersji wystarczającej dla aplikacji.
%Automatycznie brało najnowszą, oznaczoną jako 4.4, ale niby była za nowa. Jak przestawiłem ręcznie na 4.4 to zaczęło działać. Pewnie brało 4.4W, a~więc nowszą, ale źle sygnalizowało. Już jest minus, bo jeślibym nic nie wiedział o~Androidach, to mógłbym się speszyć.

%\subsection{Testy}
%Ponieważ nie ma serwerów WCF (jak napisano... gdzieśtam), użyję innego podejścia do zdalnego wywołania.
%Teraz mam .NET na Androidzie, czyli komunikacja z~.NETem na PC powinna być bardzo łatwa. Może nawet mogę zserializować binarnie jakąś domyślną serializatorką .NETa i~przepchnąć przez socket? To by było moje RPC całe. No potrzeba jeszcze jakiś ID obiektu i~metody, ale to jest banalne do uzyskania, jeśli po obu stronach mamy, np. takie same biblioteki .NET.
%
%Ponieważ .NET po stronie Androida może wysyłać wołania do systemu i~wołać biblioteki Javowe (przy użyciu jakiś bindingów, LINK) to mogłoby się to liczyć jako wywoływanie kodu w~Javie, a~więc cel mojej magisterki.
%Trzeba to sprawdzić.
%
%Żeby tylko dostępne typy serializacji mogły przenieść informacje o~niepewnych typach\ldots
%Chociaż może domyślna, jakaś wewnętrzna (nie chcemy tego wysyłać na inną platformę, wszystko zostaje wewnątrz .NET) zachowuje wszystkie informacje o~obiekcie?



\section{Thrift (TODO)}
\url{http://thrift.apache.org/static/files/thrift-20070401.pdf}\\

Thrift is a software library and set of code-generation tools developed
at Facebook to expedite development and implementation of
efficient and scalable backend services. Its primary goal is to enable
efficient and reliable communication across programming languages
by abstracting the portions of each language that tend to
require the most customization into a common library that is implemented
in each language. Specifically, Thrift allows developers to
define datatypes and service interfaces in a single language-neutral
file and generate all the necessary code to build RPC clients and
servers.

%Też się z tym zgadzam i chciałbym, żeby tak w moim było
The same application code should be able to run against TCP stream sockets, raw data in memory, or files on disk.

Jest IDL, który opisuje interfejsy usług i dane przez nie wykorzystywane.

Pozwala na asynchroniczność -- coś, czego nie przewidywałem dla mojej biblioteki, ale też może być przydatne.


\subsection{Ocena}

\begin{description}
\itemtitle{Klasyfikacja}
Pozwala na tworzenie pełnej architektury RPC z~klientami, serwerami i~serializacją przesyłanych danych. Umożliwia generację kodu w~wielu językach. Otwarty kod. 

\itemtitle{Docelowa platforma}
Kompilator przeznaczony dla środowisk Unixowych. Pod Windowsem działa w~środowisku Cygwin.
Generuje kod w~wielu językach: Actionscript 3, C, C++, C\#, Cocoa, Delphi, Erlang, Go, Haskell, Java, Javascript, OCaml, Perl, PHP, Python, Ruby, Smalltalk\cite{thrift-features}.

\itemtitle{Łatwość instalacji(TODO)}
Wydzielić kompilator i biblioteki do użycia w kodzie.
Sprawdzę na Linuxie (wirtualne Kubuntu 14.04), bo nie chce mi się meczyć z Cygwinem. Nie jest to tragedia, ale może chwilkę zająć.

Na pochodnym od Debiana Linuxie, konkretnie Kubuntu jest banalna. Na innych platformach nie też skomplikowana, ale w~tym przypadku ogranicza się do wpisania jednej, co prawda przydługiej, komendy: \texttt{sudo apt-get install libboost-dev libboost-test-dev libboost-program-options-dev libboost-system-dev libboost-filesystem-dev libevent-dev automake libtool flex bison pkg-config g++ libssl-dev}.

Na Windowsie kompilator można ściągnąć jako jednego egzeka (nawet nie instalator, tylko działający kompilator).

\itemtitle{Łatwość użycia(TODO)}
Wydaje się łatwe. W sumie prosty system. Dobrze wytłumaczony.

\itemtitle{Zgodność(TODO)}
Kod serwisów i~klientów Thrifta może być wygenerowany do wielu języków, a~następnie osadzony w~programach stworzonych w~tych samych językach.
Para klient-serwer może ze sobą rozmawiać niezależnie od tego, w~jakiej technologii zaimplementowane są obie strony.
Ale wszystko pozostaje hermetyczne w~obrębie Thrifta -- korzystając z~innej technologii nie da się skomunikować z~serwerem stworzonym w~Thrifcie.

Służy do robienia i klienta i serwera. Nie można np.\ zrobić serwera, do którego inni będą mogli wołać jakimś standardowym kanałem. Muszą mieć konkretny, wygenerowany kod klienta (no ewentualnie mogą zrobić swój kod korzystając z API Thrift). Moje może tak wyjść.

\itemtitle{Zewnętrzne moduły(TODO)}
Nie można podłączać pod system zewnętrznych bibliotek. Serwisy, parametry ich metod oraz klienty są powiązane definicjami jeżyka Thrifta. Aby w~nie ingerować trzeba zmienić ich definicje, a~następnie znowu wygenerować kod w~rzeczywistych językach programowania. Nie ma miejsca na ,,wplecenie'' zbudowanych bibliotek, np.\ javowych.

Można podczepić zewnętrzne definicje Thrift pod swoje. Ale nie można nijak podczepić typów z gotowego kodu, np. Javy, w swoich definicjach serwisów lub danych. Można też użyć zewnętrznych bibliotek w implementacjach serwisów.

\itemtitle{Rozszerzalność(TODO)}
Nie ma. Aby wpłynąć na działanie metod trzeba zmienić ich (lub ich parametrów) definicje i~ponownie wygenerować kod użytkowy.

Teoretycznie można podmieniać implementację usług. Musi ona spełniać generowany interfejs, ale nie jest w inny sposób ograniczana.

Jeszcze jest to wersjonowanie, które pozwala starszym elementom gadać z nowszymi i na odwrót. Przynajmniej w~pewnym stopniu. 

\itemtitle{Integracja z Androidem(TODO)}
Ale może można zrobić serwer na Androidzie? (\url{http://stackoverflow.com/questions/19141177/thrift-client-on-android}) Pewnie się nie da bez przerabiania kodu Thrifta.

\itemtitle{Polimorfizm metod}
Nie ma. Każda metoda usługi musi mieć unikatową nazwę\cite{thrift-features}.

\itemtitle{Polimorfizm danych}
Nie ma. Struktury Thrift IDL nie wspierają dziedziczenia\cite{thrift-features}.

\itemtitle{Tłumaczenie kodu}
Thrift pozwala na opisanie serwisów i~struktur danych przy pomocy swojego ,,języku opisu interfejsów'' (ang. \emph{interface description language}).
Z~tego opisu może generować kod kliencki, interfejsy serwisów oraz klasy lub struktury danych do dla wspieranych języków. \cite{thrift-features}
Interfejsy serwisów muszą być zaimplementowane przez programistę w~jednym z~,,normalnych'' języków.

\end{description}


\subsection{Podsumowanie}
Gdyby tylko można było jakoś podłączać zewnętrzne biblioteki i~tworzyć kod Thrifta z~gotowych klas w~Javie lub C\# to byłby idealnym i~kompletnym rozwiązaniem (jeśli działa na Androidzie).



\section{Sharpen (TODO)}
Wtyczka do IDE Eclipse tłumacząca kod w~Javie do C\#.
Nie jest dynamicznie rozwijany. Mimo to polecana przez Xamarina (\url{http://developer.xamarin.com/guides/android/advanced_topics/java_integration_overview/}).
Istnieje kilka jego wersji rozsianych po kilku stronach. Wszystkie różnią się nieco kodem, ponieważ są rozwijane niezależnie.

Strony, na których można znaleźć informacje o~nim to: BLABLABN LA

\subsection{Ocena}

\begin{description}
\itemtitle{Klasyfikacja}
Narzędzie do tłumaczenia kodu z~Javy na C\#.

\itemtitle{Docelowa platforma}
Tworzony jest kod skierowany na platformę .NET\@. Dane wejściowe to kod Java (w~formie źródeł), niezależny od żadnej konkretnej platformy.

\itemtitle{Łatwość instalacji}
Instalacja trudna na tyle, że nie udało mi się jej przeprowadzić. Może jest to możliwe, ale w~tej chwili nie chcę na to tracić więcej czasu.

Przewodników po instalacji (i~użycia) jest kilka różnych, co wprowadza w~zakłopotanie: \\
\url{https://github.com/slluis/sharpen}\\
\url{https://github.com/xamarin/XobotOS/tree/master/sharpen}\\
\url{http://blog.xamarin.com/android-in-c-sharp/}\\
\url{http://community.versant.com/documentation/reference/db4o-7.12/java/reference/html/Content/sharpen/how_to_setup_sharpen.html}\\
\url{http://pauldb.tumblr.com/post/14916717048/a-guide-to-sharpen-a-great-tool-for-converting-java}\\

\itemtitle{Łatwość użycia}
Średnio trudne.
Trzeba przeprowadzić dużą konfigurację, ale jest ona zrozumiała i~dość elastyczna. Można też zdobyć gotowe pliki, które można  szybko dopasować do potrzeb.

To niestety tylko teoria, bo nie udało mi się sprawić, żeby narzędzie działało.
Nieważne z~jakich porad korzystałem, dostawałem błędy przy generacji kodu.
Po poszukiwaniach w~Internecie widać, że nie jestem jedyną osobą z~takimi problemami\footnote{\url{http://stackoverflow.com/questions/10539105/using-sharpen-and-eclipse-error-application-sharpen-core-application-could}}.
Niestety nie mają one ogólnego rowiązania.

\itemtitle{Zgodność}
Produkowany kod powinien dać się skompilować i~działać pod .NET\@.
Tłumaczone powinny być nie tylko struktury danych, ale działająca logika. Można to zrealizować dzięki precyzyjnej konfiguracji narzędzia pozwalającej też na tłumaczenie wywołań charakterystycznych metod, np.\ pisania do konsoli, tworzenia map itp.

\itemtitle{Zewnętrzne moduły (Code reuse)}
Można tłumaczyć dowolny kod Javowy. Ale trzeba mieć dostęp do źródeł.

\itemtitle{Tłumaczenie kodu}
Wystarczy raz skonfigurować i~jest spokój. Kod można rozwijać, bo ponownie wygenerowanie jest proste.
Konfiguracja to kilka ustawień ogólnych i~rozległy plik z~parami zawierającymi klasy, metody itp. Javy i~ich odpowiedniki w~C\#.

Żeby przetestować stworzyłem przykładowy projekt z~klasą, którą będę chciał przetłumaczyć. Tylko jedną na razie, żeby zobaczyć, że działa.
Do projektu dodałem pliki konfiguracyjne, zgodnie z~jednym z~poradników. Zmapowałem też \emph{namespace} do docelowego.
\end{description}

\subsection{Podsumowanie}
Nie udało mi się użyć. Najwyraźniej dwa lata, a~z~tego, co widać to tyle minęło od większych aktualizacji kodu, to za dużo dla wtyczki do Eclipse'a\footnote{Ofiara zjawiska \emph{bit rot}.}.
Nie ma dobrego wsparcia, ponieważ jest to ,,bezpański'' projekt, nad którym nie nie sprawuje faktycznej kontroli.
Dziwne, że Xamarin cały czas go poleca. Może ich wersja kodu Sharpena pasuje do ich zastosowania.

Generowanie kodu C\# ze źródeł Javy mogłoby się bardzo przydać w~moim projekcie. Konwersja w~tę stronę jest preferowana, ponieważ w~Javie będzie logika metod zdalnych, w~tym komunikacja z~Androidem, a~to coś, czego raczej nie da się automatycznie przełożyć z~C\#.
Natomiast przeniesienie typów danych używanych przez te metody z~Javy powinno być stosunkowo mało skomplikowane.



\section{JsonRpc (Ritwik Saikia) (TODO)}
\subsection{Opis}
Przez autora przedstawiony jako łatwy i~lekki klient/serwer RPC oparty o~JSON (,,Easy and lightweight Json-Rpc Client/Server'')\cite{json-rpc-lib}.
Oparcie o~JSONa oznacza, że wiadomości, zawierające zserializowane obiekty, przesyłane między klientem a~serwerem zapisane są JSONem. Biblioteka powinnna działać dla Androida, Google App Engine i~aplikacji Javascript.

Jest to jedna z~wielu bibliotek, a~jej nazwa pokrywa się (konkretna pisownia może być inna) z~nazwą standardu. To może być mylące. 

\subsection{Ocena}

\begin{description}
\itemtitle{Klasyfikacja}
Klient i~serwer RPC. Otwarty kod. Serializacja dostarczana (najprawdopodobniej) przez zewnętrzną bibliotekę -- Gson.

\itemtitle{Docelowa platforma}
Java. Autor twierdzi, że działa też na Androidzie.

\itemtitle{Łatwość instalacji}
Średnia.
Źródła trzeba ściągnąć Gitem ze strony na Gihubie (nieduży problem), a~następnie zbudować Mavenem (jeśli ktoś nie ma zainstalowanego to wymaga to chwili pracy). Nie jest to jasno opisane, wszystkiego trzeba się domyślić.

Nie ma także mowy o~tym co konkretnie zawiera się w~bibliotekach powstających w~wyniku zbudowania projektu, ale jest to intuicyjne. Plik \texttt{jsonrpc-1.1.jar} zdaje się zawierać całość klas projektu, pliki \texttt{jsonrpc-1.1-server.jar}) i~\texttt{jsonrpc-1.1-client.jar} zawierają odpowiednio klasy potrzebne do stworzenia serwera i~klienta. Jest też część wspólna 

\itemtitle{Łatwość użycia}
Średnie. Teoretycznie powinno się łatwo korzystać z~tej biblioteki, ale w~moim przypadku (nie mogę tego zrobić jako servlet) musiałbym sam zaimplementować serwer, co jest czasochłonne.
Nie zrobiłem tego, dlatego nie mam więcej danych na temat tej biblioteki.

Według autora API klienta i~serwera jest zaprojektowane tak, aby programista nie musiał być świadomy szczegółów protokołu komunikacyjnego.
Aby stworzyć zdalną metodę wystarczy zarejestrować klasę zawierającą tę metodę po stronie serwera, a~następnie po stronie klienta dynamicznie\footnote{Dosłownie ,,w locie'', z~ang. \emph{,,on the fly''}} stworzyć do niej proxy.

\itemtitle{Zgodność}


\itemtitle{Zewnętrzne moduły}


\itemtitle{Rozszerzalność}


\itemtitle{Integracja z Androidem}


\itemtitle{Polimorfizm metod}

\itemtitle{Polimorfizm danych}
Serializacja do JSONa (i~deserializacja z~niego) najprawdopodobniej nie jest zaimplementowana w~samym JsonRpc, a~przez bibliotekę Gson, która wchodzi w~skład JsonRpc. Gson\footnote{\url{https://code.google.com/p/google-gson/}} jest serializatorem napisanym w~Javie przez Google.

Trzeba przeanalizować, jak sobie radzi Gson.

\end{description}

\subsection{Podsumowanie}
Ponieważ nie ma dostarczonej implementacji serwera, która mogłaby działać na Androidzie nie mogłem przeprowadzić testów.
Stąd nie mam żadnych godnych uwagi wniosków.
Ale nie zapowiada się, żeby ta biblioteka była lepsza niż jsonrpc4j. Chociaż faktycznie ani jednej z~nich nie uruchomiłem jeszcze na Androidzie.

%Nie ma za bardzo instrukcji jak to zbudować. Są jakieś skrypy, ale są tylko pod Linuxa. Są w~readme jakieś fragmenty Mavena, sugerujące chyba co zrobić, w~zależności od tego, jaki build chce się uzyskać (wkleić je, pokazać, jak wygląda folder, może jakimś wydrukiem z command line).



\section{WCF (TODO)}
Potężny framework Web Serviceów od Microsoftu. Może posłużyć za wzór jak wszystko może działać. Może dość dynamicznie tworzyć hierarchie obiektów, które mogą funkcjonować jako usługi.
Poza frameworkiem są też narzędzia do generacji kodu ze schemy i wsdl.
Można robić JSONa: \url{http://msdn.microsoft.com/en-us/library/system.runtime.serialization.json.datacontractjsonserializer.aspx}\\

Generowanie z JAX-WS przy pomocy wsdl toola nie do końca działało.
%http://docs.oracle.com/cd/E21764_01/web.1111/e13759/interop.htm

Opisać o co chodzi z tym polimorfizmem, że w WCF trzeba wypisywać KnownType, co jest robieniem wzajemnych zależności, co jest straszną praktyką programowania (źródło).

Napisać jak łatwo można zrobić to, co chcę mieć.

%\subsection{Rozszerzalność}
%Standardowo używa się DataContract, ale nie trzeba.
%DataContractSerializerowi trzeba dać informacje o~wszystkich typach, jakich ma się spodziewać. Albo zrobić oznaczenia. Oznaczenia blokują rozwijanie kodu. Podawanie wszystkich klas też trzeba jakoś rozwiązać, np. przez analizę bibliotek i~ładowanie wszystkich możliwych klas (DataContractów).



\section{JAX-WS (TODO)}
Standardowy framework Javy do Web Serviceów. Podobne możliwości co WCF\@. Ja też niby chcę web service'y w Javie, ale na Androidzie, któremu JAX-WS został wycięty.
%Niestandardowe podejście z użyciem JSONa zamiast XMLa\url{http://jax-ws-commons.java.net/json/}\\
Poza frameworkiem są też narzędzia do generacji kodu ze schemy i wsdl.

W JVM jest mały serwerek, który może hostować, można to też robić z jakiegoś Glassfisha albo innego serwera Javy EE\@. Podobnie ma WCF.

Co by trzeba było po kolei zrobić w normalnej javie żeby połączyć z~WCF? (tłumaczenia do xsd, ujednolicanie namespaców, mamy do czynienia z jakimiś ArrayOfString, dziedziczenie chyba słabo działa przy generacji, nie da się używać DataContractSerializera żeby nie serializować części klas ogólnie syf, ale wszystko udokumentować). 

Napisać jak łatwo można zrobić to, co chcę mieć.



\section{JSON-RPC.NET (TODO)}
\url{https://github.com/Astn/JSON-RPC.NET} \\
Wygląda na ciekawą sprawę. JSON.NET, którego ta biblioteka używa ma chodzić nawet na Mono na Androidzie. Ten Json.NET ma JsonSchemę.

Nie za bardzo ma klienta. \url{http://jsonrpc2.codeplex.com/discussions/547022} \\
No... jest propozycja jak zrobić: \url{https://jsonrpc2.codeplex.com/SourceControl/latest#AustinHarris.JsonRpc/AustinHarris.JsonRpc.Client/client.cs}
W ogóle w .NETcie coś dziwnie trudno o kod kliencki. Jest Jayrock \url{https://code.google.com/p/jayrock/}


\section{gSOAP (TODO)}
Web Service'y i REST w C/C++. Pytanie, czy można posadzić serwer na Androidzie i połączyć z Javą?
Pewnie by się dało przez JNI, ale tłumaczenie danych pełne byłoby bolesne. Wołanie API Androida też.
\url{http://trac.e-technik.uni-rostock.de/projects/ws4d-gsoap/wiki/AndroidNDK}\\ 



\section{Inne (TODO)}
Chociaż wymienić pozostałe rozwiązania, które mogą być warte uwagi, choć raczej nie nadają się dla rozwiązania problemu tej pracy magisterskiej.

\subsection{android-xml-rpc}
W~jednym wątku na Google Groups \cite{android-rpc-thread} mówili, że niby zrobili serwer. I faktycznie na to wygląda.
Też na android-json-rpc(\url{https://code.google.com/p/android-json-rpc/}).


\subsection{Apache Avro}
Otwarty system serializacji danych


\subsection{Google Protocol Buffers}
\url{https://developers.google.com/protocol-buffers/docs/overview}
Podobne do Apache Thrift, ale źródła zamknięte. Od Googla. Służy do wyabstrachowania wiadomości (danych w nich zawartych) przesyłanych między częściami twojej aplikacji.
Nie ma tu mowy o serwisach jak w Thrifcie, tylko wiadomości, czyli właściwie dane.
Też jest generowanie do kilku języków i~jeden odmienny język wspólny, z którego robi się tę generację. Przez to podobne wady, jak Thrift.

Forma tekstowa przypomina JSONa.


\subsection{GSON}
Gson is a Java library that can be used to convert Java Objects into their JSON representation. It can also be used to convert a JSON string to an equivalent Java object. Gson can work with arbitrary Java objects including pre-existing objects that you do not have source-code of.

Provide simple toJson() and fromJson() methods to convert Java objects to JSON and vice-versa
Allow pre-existing unmodifiable objects to be converted to and from JSON
Extensive support of Java Generics
Allow custom representations for objects
Support arbitrarily complex objects (with deep inheritance hierarchies and extensive use of generic types)

Prostszy niż Jackson, ale nie zachowuje informacji o typach. 


\subsection{I-jetty}
Serwer webowy dla Androida. Niby port Jetty. Może ma jakiś kontener Web-serviceów?


\subsection{Pyro}
Pythonowe, niby obiektowe. Ale dla pythona będzie łatwo uzyskać polimorfizm, bo nie ma ostrego typowania. Także może sobie luźno traktować XMLa lub JSONa.


\subsection{Restlet}
\url{http://restlet.org/learn/tutorial/2.1/#/docs_2.0/13-restlet/275-restlet/266-restlet.html}\\
Używa Jacksona, nieciekawy. Ale coś restowego by się przydało.


\subsection{Spring}
Javowy framework web serviceów.
\url{http://forum.springsource.org/showthread.php?129058-Spring-Remoting-for-Android}\\


\subsection{ZeroMQ}
\url{http://zguide.zeromq.org/page:all}
\url{http://stackoverflow.com/questions/8062212/difference-between-apache-thrift-and-zeromq}\\
ØMQ (also known as ZeroMQ, 0MQ, or zmq) looks like an embeddable networking library but acts like a concurrency framework. It gives you sockets that carry atomic messages across various transports like in-process, inter-process, TCP, and multicast. You can connect sockets N-to-N with patterns like fan-out, pub-sub, task distribution, and request-reply. It's fast enough to be the fabric for clustered products. Its asynchronous I/O model gives you scalable multicore applications, built as asynchronous message-processing tasks. It has a score of language APIs and runs on most operating systems. ØMQ is from iMatix and is LGPLv3 open source.



\subsection{Jakieś pythonowe}
WSME: \url{http://wsme.readthedocs.org/en/latest/}\\
Python EVE (Rest framework)\\


\subsection{Java to C\# itp.}
\url{http://sourceforge.net/projects/ikvm/}
\url{http://jni4net.com/} -- most (umożliwia wywoływanie), nie translator kodu, aktywnie utrzymywany \\
\url{http://sourceforge.net/projects/j2cstranslator/}\\
Przejście do schemy a~potem na inny kod może być alternatywą dla tych rzeczy.


\subsection{Jeśli chciałbym się bawić w schemy}
To może poszukać jakiś frameworków pozwalających oznakować klasy do serializacji (binding) do xmla albo jsona (a może nawet WSDL).
W końcu jak mamy schemę po obu stronach, to można przetłumaczyć z Javy do XMLa a dalej do C\# i z powrotem.

JiBX!!! Tworzenie klas ze schemy i robienie wsdl z javy\\
Wsdl2Java: tworzenie klas z wsdl, głównie chodzi o klasy danych\\

Generacja javovego kodu z bindingu:\\
XSD2Java – generuje kod java z xsd. Mocno niedorobione.\\

\url{http://stackoverflow.com/questions/6920175/how-to-generate-java-classes-from-wsdl-file}\\
\url{http://blog.tourgeek.com/2011/12/xml-data-binding-for-java-on-android.html}\\

\subsection{Jakieś serializacje}
\url{http://simple.sourceforge.net/}\\
\url{http://code.google.com/p/dbdroid-remoting/} - klient web serviców serializujący i deserializujący xmle\\


\subsection{Reszta}
Crest, Ksoap \\
\url{https://code.google.com/p/android-json-rpc/} -- bazuje na JSON-RPC, wspomaga w~robieniu klientów na Androida.\\
\url{http://software.dzhuvinov.com/json-rpc-2.0-server.html} -- też jakiś niby niezależny serwer. \\ 
\url{http://en.wikipedia.org/wiki/JSON-RPC#Implementations} -- cała lista implementacji JSON-RPC \\
\url{https://github.com/cowtowncoder/java-classmate} -- introspekcja typów w Javie. Powinno sobie dawać radę z~ ,,type erasure''.


%\section{Wrappery pythonowe}
%Może zamiast równoważnych implementacji na pythona, C\# i javę zrobić tylko pythona i wrappery w jythonie i iron pythonie?



%\section{Porównanie możliwości tych technologii}
%Zestawienie ogólne -- czy można coś zrobić z tym na Androidzie, czy możliwe są metody polimorficzne (i jak z resztą poszukiwanych przeze mnie cech ze wstępu), jaka jest moja subiektywna ocena pracy z danym frameworkiem, jak ciężko się instaluje, na ile potrafią współpracować z innymi rozwiązaniami (jak bardzo trzymają się standardów).
%
%%Jeśli ta tabela przejdzie, to powinna zawierać cechy podobne do tych z tabeli kryteriów, ale tak zmienione, żeby można było odpowiedzieć: jest, nie ma, nie dotyczy
%
%\begin{table}[htbp]
	%\centering
		%\begin{tabular}{ | c || c | c | c | c | c | c |}
			%\hline
				%Technologia & Android & Hostowanie & Współpraca & Polimorfizm & Rozszerzalność & Prostota  \\
				%\hline \hline
				%WCF & & + & + & + & &\\
				%\hline
				%JAX-WS & & + & +/- & + & &\\
				%\hline
				%JSON-RPC & + & + & & & &\\
				%\hline
		%\end{tabular}
	%\caption[Podsumowanie możliwości frameworków.]{Podsumowanie możliwości frameworków. ,,+'' oznacza ,,tak'', puste miejsce oznacza ,,nie''. We współpracy chodzi o to, czy może współpracować z .NETem bez jakiś dedykowanych klientów.}
	%\label{tab:frameworks-summary}
%\end{table}

%podsekcje znowu będą trafiać do spisu treści
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}

%powinienem dodać plik z licencjmi używanych bibliotek