\chapter{Pokrewne technologie (TODO)}
Tu o rozwiązaniach robiących to co chcemy albo rzeczy podobne. Przy użyciu każdego z tych frameworków spróbuję zrealizować mój cel, a więc dynamiczne web service'y na Androidzie. Czyli takie, jakie można robić przy pomocy WCF.

Może nawet okaże się, że jest tutaj coś, co spełnia moje oczekiwania? Albo wymaga tylko pewnego opakowania, żeby robić to, co ja chce?
Jeśli nie, to może chociaż mogę użyć jako moduł w swojej bibliotecę?

Dla każdego obiecującego frameworku powinienem wykonać i opisać test, jaki wykonałem, żeby sprawdzić czy nadaje się dla moich celów.

Jak ogólnie wygląda oznaczanie typów -- może być spójne między różnymi frameworkami.

%Konkretne porównania osiągów w rozdziale o eksperymentach (chociaż tutaj już zrobić porównanie wysiłku programisty, po prostu zamieścić je na końcu). Tutaj napisać o funkcjonalności żeby w ogóle wiedzieć, czy to czegoś warte i na ile mam się inspirować.
\section{Metoda analizy technologii}
Czyli z jakiej strony będę patrzył na frameworki, co będe sprawdzał, na co zwracał uwagę. Jak będzie jeden wzorzec to łatwiej zrobić tabelkę, czy coś.

W sumie będę sprawdzał, czy każda z technologii ma cechy, które opisałem w~\ref{lib-requirements}.

Wyjaśnić ogólną zasadę działania dla każdego.

Dla każdego wypisać wady i zalety względem moich celów.

Najpierw przedstawiam każdy framework ``cytując'' jego słowa (README). A~więc przedstawiam jego obietnice.

Głównie zależy mi na serwerach dla Androida i~klientach na .NET\@. Ale też jakieś frameworki obrazujące jakieś założenia albo wiodące w~przemyśle przez popularność.

\subsection{Użyteczność}
\begin{itemize}
	\item Jak przebiega instalacja? Jest oczywista, automatyczna? Wszystko łatwo znaleźć?
	\item Jak można uruchomić helloWorld?
	\item Na ile to elastyczne i potężne? Czyli jak łatwo można zrobić swoją robotę i to tak, jak się chce?
\end{itemize}

\subsection{Czy może być hostem}
Czyli czy pozwala na wystawianie serwisu, czy może tylko być klientem. Czy może ani tym, ani tym? Tylko w czymś możee pomóc?

\subsection{Współpraca}
Można tym połączyć Androida z C\#?
Łączy się jakoś standardowo, czy własne łączniki po obu stronach implementować? Czy wystarczy skonfigurować istniejące?

Może łączyć analizy dwóch technologii, np.\ JAX-WS i~WCF, jsonrpc4j z~jakimś JSON-RPC dla .NET\@.

\subsection{Sprawdzanie polimorfizmu}
Jak sprawdzam polimorfizm?
Przede wszystkim trzeba sprawdzić, czy metody spełniają założenia polimorfizmu. Poza tym templateowym, bo tego nie chce. Czyli jak z argumentami dziedziczącymi, jak z przeładowaniem metod. Jak z listami różnych elementów, które dziedziczą po typie bazowym.
Potem przyjrzenie się liście rzeczy, które stworzyłem na bazie doświadczenia z ktorymi silniki serializacyjne maja problemy, a sa ta sensowne przypadki. Np.\ listy list, listy obiektów o różnych typach (też listach). Puste tablice.

\subsubsection{Testy polimorfizmu}
Odpowiedzialne za tę weryfikacje będą testy polegające na stworzeniu opisanych zdalnych metod przy pomocy sprawdzanego narzędzia i~próby jej wywołania. Nawet jeśli metoda się wykona, to mogła nie zwrócić odpowiedniego wyniku, dlatego go też trzeba będzie weryfikować. No i~tym testom będą podlegać tylko biblioteki, którą pozwalają tworzyć zdalne metody, nie te, które tylko je konsumują.

CHYBA JEDNAK TE ``PODSTAWOWE'' METODY I DANE TO BEZSENS. KAŻDE DANE I METODE OPISAĆ OSOBNO. TEST POLEGA NA ODPALENIU METODY I DOSTANIU SPODZIEWANEGO WYNIKU (PODAĆ INPUT I OUTPUT). KODY Z TESTÓW W REPO JAKO ZAŁĄCZNIKI.

Przy opisach testów pewna metoda i pewien typ danych będą uznawane za podstawowe. Opisy będą się odnosiły do tych ``podstawowych'' definicji. A~one są opisane poniżej.

Kod podstawowej klasy danych. Jej obiekty będę przekazywane i~zwracane w~większości testów.
Szczegóły składni nie będą ważne, można traktować to jako pseudokod, ale faktycznie na ogół będzie to C\#.

\begin{lstlisting}[frame=single, caption={Przykładowa klasa danych używana w testach polimorfizmu zdalnych metod}, label=kod:testData]
public class DaneA
{
	public int liczba;
	public string tekst;
}
\end{lstlisting}

Kod podstawowej metody testowej. Będzie ona wykonywana w~większości testów.
Po prostu zwraca lekko zmodyfikowaną kopię parametru.

\begin{lstlisting}[frame=single, caption={Przykładowa zdalna metoda testowana pod kątem polimorfizmu}, label=kod:testMethod]
public DaneA MetodaA(DaneA dane)
{
	DaneA noweDane = new DaneA();
	noweDane.liczba = dane.liczba + 1;
	noweDane.tekst = dane.tekst + "xxx";	
	return noweDane;
}
\end{lstlisting}

\subsection{Swoboda rozszerzania kodu}
Czy na tym, co się stworzy danym narzędziem można dalej budować. Zgodnie z obiektową zasadą reuse?

Też testy tutaj. Tylko jakie?



\section{JSON-RPC for Java (jsonrpc4j)}
\subsection{Opis}
\url{https://github.com/briandilley/jsonrpc4j}

Używa Jacksona, który sam w~sobie jest ciekawą biblioteką do serializacji.

Niby ma działać na Androidzie zarówno klient jak i~serwer.

\subsection{Instalacja i~hello world}
Ściągam z~Githuba (repozytorium Gita).
Buduję Mavenem.
Wczepiłem do projektu Androidowego zrobionego Eclipsem z~ADT.
Dodałem jacksona (databind), którego Jar i~tak zbudował się w~trakcie budowania Mavenem (leży sobie w~lokalnym repozytorium, c:\textbackslash{}Users\textbackslash{}Butla\textbackslash{}m2).

Dalej jadę za najprostszym przykładem bez Springa i~serwera webowego, czyli korzystając z~czegoś, co nazywa się StreamServer.

I~nie działa. JsonRpcServer -- jest zależny od rzeczy z~javax od serwletów, a~tego na Androidzie nie ma. Wywala się w~trakcie ładowania klasy. Android Lint od razu przestrzega, że to nie jest.

Napisałem do twórcy, zobaczymy co odpowie, a~tymczasem zrobię testy na normalnej Javie.

Z jacksona trzeba jeszcze wziąć core i~annotation (po prostu wszystko). I~potrzeba javax.servlet-api (też zostaje przy buildzie w~repo mavena), żeby były klasy od servletów (ogólnie szkoda, że nie ma o~tym mowy).

Zrobiłem sobie przykładowego klienta i~serwer (kody powinny być załączone do pracy). Oba działają lokalnie. Chwilkę musiałem się zastanowić jak to złożyć bez żadnych serwletów, ale kod jest logicznie ustrukturalizowany i~elastyczny, dlatego zrobienie takiego klienta jakiego chciałem.

Nie da się, niestety tak skonfigurować ``serwera strumieniowego'', żeby działał w~jednym procesie na strumieniach w~pamięci. Trzeba użyć socketów.
Na szczęście wszystko jest na tyle otwarte, że da się dobrać do socketu klienta i~przekierować to, co jest na niego nadawane (i~z~niego odbierane). Dzięki temu będę widział, jak wyglądają słane wiadomości.

\subsection{Testy}
Teraz pora sprawdzić te obietnice i~poddać bibliotekę testom. Odpalenie tych testów daje zrozumienie jak trudno lub łatwo można realizować bardziej skomplikowane zdalne metody.

Prosty test, że polimorfizm działa.  Np. kiedy przerzuca się obiekt, który będzie analizowany refleksją, albo posiadający przeładowane metody.

Ok, prosty test z przekazaniem dziedziczącego argumentu wywala się z~uwagi na nierozpoznanie dodatkowego pola parametru. Nie wie, że to inny typ.
%{"id":"3199114083297069103","jsonrpc":"2.0","method":"testDataA","params":[{"numberA":13,"stringA":"domyslny","numberB":5.25}]}
%Unrecognized field "numberB" (class jsonrpc4jtestse.TestDataA), not marked as ignorable (2 known properties: , "numberA", "stringA"])

Readme nic o~tym nie mówi, dokumentacji nie ma. Ale w~błędzie jackson, więc trzeba się udać do Jacksona.
Najwyraźniej potrzeba dodatkowych informacji, żeby serializacja mogła się udać. Z~pomocą przychodzi funkcja oznaczania typów obiektów we wiadomości\cite{jackson-polymorphic}.
Nawet mimo tego są jakieś problemy... Robi się to irytujące.

Używa valueToTree zamiast po prostu write i~przez to nie chce przejść z~oznaczaniem typów.

A po dodaniu do klasy głównej danych znacznika nakazującego oznaczenie typów wszystko działa.
%{"id":"4653019993893876656","jsonrpc":"2.0","method":"testDataA","params":[{"@class":"jsonrpc4jtestse.TestDataB","numberA":13,"stringA":"domyslny","numberB":5.25}]}
%{"jsonrpc":"2.0","id":"4653019993893876656","result":{"@class":"jsonrpc4jtestse.TestDataB","numberA":14,"stringA":"domyslny dodałem coś!","numberB":5.25}}
Wraca obiekt o poprawnym typie. Bez ustawiania czegokolwiek w~Mapperach.
Dodanie jednego znacznika do głównej klasy w~hierarchii nie jest straszne, ale sprawdźmy jeszcze domyślne typowanie z~najnowszą wersją Jacksona (bo do jsonrpc4j zrobiła się jakaś 2.0.2).

Ściągnąłem 2.4.2, nową wersje w~której powinien ten problem być już naprawiony. I faktycznie, działa teraz bez oznaczeń na klasie. Ale za to trzeba i~serwer, i~klienta stworzyć z~ObjectMapperem, w~którym włączy się enableDefaultTyping(). W moim przypadku było to
%mapper.enableDefaultTyping(
                %ObjectMapper.DefaultTyping.NON_FINAL,
                %JsonTypeInfo.As.PROPERTY);
Które dodaje informację o~klasie jako dodatkowe pole obiektu (\emph{property}), przy wszystkich obiektach, które nie są oznaczone jako final (takie, po których się nie da dziedziczyć).
%{"id":"-6659082740394205036","jsonrpc":"2.0","method":"testDataA","params":[{"@class":"jsonrpc4jtestse.TestDataB","numberA":13,"stringA":"domyslny","numberB":5.25}]}
Wygląda tak samo, jak przy oznaczaniu w~klasie. Warto zaznaczyć, że są inne style dodawania informacji o~klasach niż dodawanie nowego pola. Można je zobaczyć tu (link!)

Polimorfizm kolekcji -- też działa. Przy tablicach najwyraźniej nie ma wyboru stylu oznaczeń typów.


\subsection{Jakieś spostrzeżenia?}
Wszystko super. Sam standard JSON-RPC powinien zapewniać zgodność elementów z~różnych technologii. Niestety sam standard nie jest przemyślany pod kontem polimorfizmu. W tym przypadku może działać dzięki Jacksonowi.
Może też być zgodny ze wszystkim innym, co używa Jacksona. Ale albo trzeba mieć te same pliki klas po obu stronach albo takie same mappery.

\subsection{Podsumowanie}
Wymienienie plusów i minusów. Może zrobić itemize, gdzie jedna lista ma duże minusy jako znaczki, a~druga plusy?



\section{Xamarin}
\subsection{Opis}
Pozwala tworzyć w .NETcie aplikacje na Androida. Nie wspiera całości .NET.

Testowałem sobie na emulatorze, opis dopiero w dziale z implementacją, bo do całości pracy to się przydało.

\url{http://docs.xamarin.com/guides/cross-platform/application_fundamentals/web_services/}\\
Ddawniej mono dla androida, nie można robić web serviceów (czyli nie ma całego .NETa). Z api Androida nie wiem, jak jest.

\subsection{Instalacja i~hello world}
\subsection{Testy}
\subsection{Jakieś spostrzeżenia?}


\section{JsonRpc}
\subsection{Opis}
Przez autora przedstawiony jako łatwy i~lekki klient/serwer RPC oparty o~JSON (``Easy and lightweight Json-Rpc Client/Server'')\cite{json-rpc}.
Oparcie o~JSONa oznacza, że wiadomości, zawierające zserializowane obiekty, przesyłane między klientem a~serwerem zapisane są JSONem. Biblioteka powinnna działać dla Androida, Google App Engine i~aplikacji Javascript.

Jest napisany w~Javie.
API klienta i~serwera jest zaprojektowane tak, aby programista nie musiał być świadomy szczegółów protokołu komunikacyjnego.
Aby stworzyć zdalną metodę wystarczy zarejestrować klasę zawierającą tę metodę po stronie serwera, a~następnie po stronie klienta dynamicznie\footnote{Dosłownie ``w locie'', z~ang. \emph{``on the fly''}} stworzyć do niej proxy.

Serializacja do JSONa (i~deserializacja z~niego) najprawdopodobniej nie jest zaimplementowana w~samym JsonRpc, a~przez bibliotekę Gson, która wchodzi w~skład JsonRpc. Gson\footnote{\url{https://code.google.com/p/google-gson/}} jest serializatorem napisanym w~Javie przez Google.
 
\subsection{Instalacja i~hello world}
Hostowane jest to na Githubie.

Niby jest jakiś zbudowany release, ale jest to starsza wersja. Release okazuje się naprawdę być tylko spakowanymi źródłami. Dziwne i~wprowadzające w błąd.
Więc muszę ściągnąć najnowsze źródła, żeby mieć najnowsze funkcjonalności.
Wymaga to klienta Gita, ale nie jest to duży problem. 

Nie ma za bardzo instrukcji jak to zbudować. Są jakieś skrypy, ale są tylko pod Linuxa. Są w~readme jakieś fragmenty Mavena, sugerujące chyba co zrobić, w~zależności od tego, jaki build chce się uzyskać (wkleić je, pokazać, jak wygląda folder, może jakimś wydrukiem z command line). Ale nic nie jest jasne.
Jest też Mavenowy POM. Nie jestem doświadczony z Mavenem, ale spróbuję go zbudować. Ogólnie już duży minus -- muszę kombinować, żeby w ogóle to zbudować.

Najpierw zainstalowałem Mavena -- też nie automatyczny proces dla Windowsa, ale przebiega bez problemów. Build prostym poleceniem \texttt{mvn~clean~install}. Wydaje się, że działa.
Powstało wiele jarów.
Znowu nie ma jasnych informacji, ale wydaje się, że jest jeden (\texttt{jsonrpc-1.1.jar}), który zawiera całość biblioteki, czyli klienta i~serwer. Tego będę używał dalej. Są też wersje dedykowane dla serwera (\texttt{jsonrpc-1.1-server.jar}) i~dedykowane dla klienta (\texttt{jsonrpc-1.1-client.jar}). Część klas się zazębia.
Będę używał tego pełnego dla prostoty.

Ze zbudowaną biblioteką spróbujmy zbudować aplikację na Androida.

Coś nie widać do końca jak to hostowanie powinno wyglądać. Odpalę sobie taki przykładowy kod z~readme (ale nie będę używał Calculatora, a~jakiś swój interfejs i~implementację):
\begin{lstlisting}[frame=single, caption={Przykładowy sposób wystawiania serwera bez użycia serwletów}, label=kod:bla]
private JsonRpcExecutor bind() {
   JsonRpcExecutor executor = new JsonRpcExecutor();

   Calculator calcImpl = new SimpleCalculatorImpl();
   executor.addHandler("calc", calcImpl, Calculator.class); 

   // add more services here

   return executor;
}
\end{lstlisting}

O... jednak nie ma żadnej implementacji serwera podstawowej. Olewam to.



\section{android-xml-rpc}
W jednym wątku na Google Groups \cite{android-rpc-thread} mówili, że niby zrobili serwer. I faktycznie na to wygląda.
Też na android-json-rpc(\url{https://code.google.com/p/android-json-rpc/}).



\section{WCF}
Potężny framework Web Serviceów od Microsoftu. Może posłużyć za wzór jak wszystko może działać. Może dość dynamicznie tworzyć hierarchie obiektów, które mogą funkcjonować jako usługi.

Można robić JSONa: \url{http://msdn.microsoft.com/en-us/library/system.runtime.serialization.json.datacontractjsonserializer.aspx}\\

Generowanie z JAX-WS przy pomocy wsdl toola nie do końca działało.

Opisać o co chodzi z tym polimorfizmem, że w WCF trzeba wypisywać KnownType, co jest robieniem wzajemnych zależności, co jest straszną praktyką programowania (źródło).

Napisać jak łatwo można zrobić to, co chcę mieć.



\section{JAX-WS}
Standardowy framework Javy do Web Serviceów. Podobne możliwości co WCF\@. Ja też niby chcę web service'y w Javie, ale na Androidzie, któremu JAX-WS został wycięty.
%Niestandardowe podejście z użyciem JSONa zamiast XMLa\url{http://jax-ws-commons.java.net/json/}\\

W JVM jest mały serwerek, który może hostować, można to też robić z jakiegoś Glassfisha albo innego serwera Javy EE\@. Podobnie ma WCF.

Co by trzeba było po kolei zrobić w normalnej javie żeby połączyć z~WCF? (tłumaczenia do xsd, ujednolicanie namespaców, mamy do czynienia z jakimiś ArrayOfString, dziedziczenie chyba słabo działa przy generacji, nie da się używać DataContractSerializera żeby nie serializować części klas ogólnie syf, ale wszystko udokumentować). 

Napisać jak łatwo można zrobić to, co chcę mieć.



\section{gSOAP}
Pozwala tworzyć i konsumować Web Servicey z poziomu niezależnej biblioteki C++. Może będzie działać na Androidzie?
\url{http://trac.e-technik.uni-rostock.de/projects/ws4d-gsoap/wiki/AndroidNDK}\\



\section{Thrift}
\url{http://thrift.apache.org/static/files/thrift-20070401.pdf}\\

\section{Google Protocol Buffers}
\url{http://stackoverflow.com/questions/8062212/difference-between-apache-thrift-and-zeromq}\\
A co to ZeroMQ?\\

\section{Jackson}
Konfigurowalna i dopracowana biblioteki do serializacji do JSONa. To może się przydać przy komponowaniu wywołań RPC.

Polimorfizm w Jacksonie:
\url{http://wiki.fasterxml.com/JacksonPolymorphicDeserialization}\\
\url{http://www.cowtowncoder.com/blog/archives/2010/03/entry_372.html}\\
\url{http://stackoverflow.com/questions/14454028/polymorphic-serialization-of-collections-with-custom-serializer-in-jackson}\\

Informacja o typach w Jacksonie:
\url{http://stackoverflow.com/questions/12350571/how-can-i-change-global-type-information-format-in-jackson}\\
%sprawdzić jak się wymienia ze wszystkim opisanym adnotacjami (dodać jeszcze rozszerzenie defaulttyperesolvera), wtedy sprawdzić mixed iny; lista objectów, na którą wpakuję stringi i inty

Jackson i .NET:
\url{http://stackoverflow.com/questions/8368873/deserialize-json-string-generated-from-net-using-jackson}\\

Ogólne:
\url{http://stackoverflow.com/questions/10329706/json-deserialization-into-another-class-hierarchy-using-jackson}\\
\url{http://wiki.fasterxml.com/JacksonHowToIgnoreUnknown}\\

\section{Pyro}
Pythonowe, niby obiektowe. Ale dla pythona będzie łatwo uzyskać polimorfizm, bo nie ma ostrego typowania. Także może sobie luźno traktować XMLa lub JSONa.

\section{Spring}
Javowy framework web serviceów.

\url{http://forum.springsource.org/showthread.php?129058-Spring-Remoting-for-Android}\\


\section{I-jetty}
Serwer webowy dla Androida. Niby port Jetty. Może ma jakiś kontener Web-serviceów?

\section{Wrappery pythonowe}
Może zamiast równoważnych implementacji na pythona, C\# i javę zrobić tylko pythona i wrappery w jythonie i iron pythonie?


\section{Inne}
Chociaż wymienić pozostałe rozwiązania, które mogą być warte uwagi, choć raczej nie nadają się dla rozwiązania problemu tej pracy magisterskiej.

\subsection{Apache Avro}

\subsection{Restlet}
\url{http://restlet.org/learn/tutorial/2.1/#/docs_2.0/13-restlet/275-restlet/266-restlet.html}\\
Używa Jacksona, nieciekawy. Ale coś restowego by się przydało.

\subsection{Jakieś pythonowe}
WSME: \url{http://wsme.readthedocs.org/en/latest/}\\
Python EVE (Rest framework)\\

\subsection{Jeśli chciałbym się bawić w schemy}
To może poszukać jakiś frameworków pozwalających oznakować klasy do serializacji (binding) do xmla albo jsona (a może nawet WSDL).
W końcu jak mamy schemę po obu stronach, to można przetłumaczyć z Javy do XMLa a dalej do C\# i z powrotem.

JiBX!!! Tworzenie klas ze schemy i robienie wsdl z javy\\
Wsdl2Java: tworzenie klas z wsdl, głównie chodzi o klasy danych\\

Generacja javovego kodu z bindingu:\\
XSD2Java – generuje kod java z xsd. Mocno niedorobione.\\

\url{http://stackoverflow.com/questions/6920175/how-to-generate-java-classes-from-wsdl-file}\\
\url{http://blog.tourgeek.com/2011/12/xml-data-binding-for-java-on-android.html}\\

\subsection{Jakieś serializacje}
\url{http://simple.sourceforge.net/}\\
\url{http://code.google.com/p/dbdroid-remoting/} - klient web serviców serializujący i deserializujący xmle\\

\subsection{Reszta}
Crest, Ksoap \\
\url{https://code.google.com/p/android-json-rpc/} -- bazuje na JSON-RPC, wspomaga w~robieniu klientów na Androida.\\
\url{http://software.dzhuvinov.com/json-rpc-2.0-server.html} -- też jakiś niby niezależny serwer. \\ 
\url{http://en.wikipedia.org/wiki/JSON-RPC#Implementations} -- cała lista implementacji JSON-RPC



%Może przerzucić to na początek i uwzględnić więcej technologii? Takich pobierznie przejrzanych?
\section{Porównanie możliwości tych technologii}
Zestawienie ogólne -- czy można coś zrobić z tym na Androidzie, czy możliwe są metody polimorficzne (i jak z resztą poszukiwanych przeze mnie cech ze wstępu), jaka jest moja subiektywna ocena pracy z danym frameworkiem, jak ciężko się instaluje, na ile potrafią współpracować z innymi rozwiązaniami (jak bardzo trzymają się standardów).

\begin{table}[htbp]
	\centering
		\begin{tabular}{ | c || c | c | c | c | c | c |}
			\hline
				Technologia & Android & Hostowanie & Współpraca & Polimorfizm & Rozszerzalność & Prostota  \\
				\hline \hline
				WCF & & + & + & + & &\\
				\hline
				JAX-WS & & + & +/- & + & &\\
				\hline
				JSON-RPC & + & + & & & &\\
				\hline
		\end{tabular}
	\caption[Podsumowanie możliwości frameworków.]{Podsumowanie możliwości frameworków. ``+'' oznacza ``tak'', puste miejsce oznacza ``nie''. We współpracy chodzi o to, czy może współpracować z .NETem bez jakiś dedykowanych klientów.}
	\label{tab:frameworks-summary}
\end{table}
